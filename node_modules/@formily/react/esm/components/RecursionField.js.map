{"version":3,"file":"RecursionField.js","sourceRoot":"","sources":["../../src/components/RecursionField.tsx"],"names":[],"mappings":";;;;;;;;;;;AAAA,OAAO,KAAK,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,OAAO,CAAA;AAChD,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAA;AAEvD,OAAO,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAA;AAC7C,OAAO,EAAE,aAAa,EAAE,MAAM,WAAW,CAAA;AAEzC,OAAO,EAAE,QAAQ,EAAE,kBAAkB,EAAE,MAAM,UAAU,CAAA;AACvD,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAA;AAC3C,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAA;AACzC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAA;AAC/B,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAA;AAEvC,IAAM,aAAa,GAAG,UAAC,MAAc;IACnC,IAAM,KAAK,GAAG,kBAAkB,EAAE,CAAA;IAClC,OAAO,MAAM,CAAC,YAAY,CAAC;QACzB,KAAK,OAAA;KACN,CAAQ,CAAA;AACX,CAAC,CAAA;AAED,IAAM,WAAW,GAAG,UAAC,KAA2B;IAC9C,IAAM,MAAM,GAAG,QAAQ,EAAE,CAAA;IACzB,IAAI,KAAK,CAAC,oBAAoB,EAAE;QAC9B,OAAO,KAAK,CAAC,QAAQ,KAAI,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA,CAAA;KAC5D;IACD,OAAO,KAAK,CAAC,QAAQ,KAAI,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,OAAO,CAAA,CAAA;AAC1C,CAAC,CAAA;AAED,MAAM,CAAC,IAAM,cAAc,GAAkC,UAAC,KAAK;IACjE,IAAM,QAAQ,GAAG,WAAW,CAAC,KAAK,CAAC,CAAA;IACnC,IAAM,WAAW,GAAG,OAAO,CAAC,cAAM,OAAA,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,EAAxB,CAAwB,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAA;IAC3E,IAAM,UAAU,GAAG,aAAa,CAAC,WAAW,CAAC,CAAA;IAC7C,IAAM,gBAAgB,GAAG,UAAC,KAAoB;QAC5C,IAAI,KAAK,CAAC,cAAc;YAAE,OAAM;QAChC,IAAM,UAAU,GAAG,MAAM,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAA;QACzD,IAAI,CAAC,UAAU,CAAC,MAAM;YAAE,OAAM;QAC9B,OAAO,CACL,oBAAC,QAAQ,QACN,UAAU,CAAC,GAAG,CAAC,UAAC,EAA2B,EAAE,KAAK;gBAAxB,IAAI,YAAA,EAAO,IAAI,SAAA;YACxC,IAAM,IAAI,GAAG,CAAA,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,OAAO,KAAI,QAAQ,CAAA;YACvC,IAAI,MAAM,GAAW,IAAI,CAAA;YACzB,IAAI,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE;gBAC7B,IAAM,MAAM,GAAG,KAAK,CAAC,aAAa,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;gBAC9C,IAAI,MAAM,EAAE;oBACV,MAAM,GAAG,MAAM,CAAA;iBAChB;aACF;YACD,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE;gBAChC,IAAI,KAAK,CAAC,gBAAgB,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,KAAK,EAAE;oBAClD,OAAO,IAAI,CAAA;iBACZ;aACF;YACD,IAAI,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,KAAK,CAAC,cAAc,EAAE;gBACxD,OAAO,CACL,oBAAC,cAAc,IACb,cAAc,EAAE,IAAI,EACpB,gBAAgB,EAAE,KAAK,CAAC,gBAAgB,EACxC,aAAa,EAAE,KAAK,CAAC,aAAa,EAClC,MAAM,EAAE,MAAM,EACd,GAAG,EAAE,UAAG,KAAK,cAAI,IAAI,CAAE,EACvB,IAAI,EAAE,IAAI,EACV,QAAQ,EAAE,IAAI,GACd,CACH,CAAA;aACF;YACD,OAAO,CACL,oBAAC,cAAc,IACb,MAAM,EAAE,MAAM,EACd,GAAG,EAAE,UAAG,KAAK,cAAI,IAAI,CAAE,EACvB,IAAI,EAAE,IAAI,EACV,QAAQ,EAAE,IAAI,GACd,CACH,CAAA;QACH,CAAC,CAAC,CACO,CACZ,CAAA;IACH,CAAC,CAAA;IAED,IAAM,MAAM,GAAG;QACb,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC;YAAE,OAAO,gBAAgB,EAAE,CAAA;QACnD,IAAI,WAAW,CAAC,IAAI,KAAK,QAAQ,EAAE;YACjC,IAAI,KAAK,CAAC,oBAAoB;gBAAE,OAAO,gBAAgB,EAAE,CAAA;YACzD,OAAO,CACL,oBAAC,WAAW,eAAK,UAAU,IAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,KAC9D,gBAAgB,CACL,CACf,CAAA;SACF;aAAM,IAAI,WAAW,CAAC,IAAI,KAAK,OAAO,EAAE;YACvC,OAAO,CACL,oBAAC,UAAU,eAAK,UAAU,IAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,IAAI,CACrE,CAAA;SACF;aAAM,IAAI,WAAW,CAAC,IAAI,KAAK,MAAM,EAAE;YACtC,IAAI,KAAK,CAAC,oBAAoB;gBAAE,OAAO,gBAAgB,EAAE,CAAA;YACzD,OAAO,CACL,oBAAC,SAAS,eAAK,UAAU,IAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,KAC5D,gBAAgB,CACP,CACb,CAAA;SACF;QACD,OAAO,oBAAC,KAAK,eAAK,UAAU,IAAE,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,IAAI,CAAA;IACxE,CAAC,CAAA;IAED,IAAI,CAAC,WAAW;QAAE,OAAO,oBAAC,QAAQ,OAAG,CAAA;IAErC,OAAO,CACL,oBAAC,aAAa,CAAC,QAAQ,IAAC,KAAK,EAAE,WAAW,IACvC,MAAM,EAAE,CACc,CAC1B,CAAA;AACH,CAAC,CAAA","sourcesContent":["import React, { Fragment, useMemo } from 'react'\nimport { isBool, isFn, isValid } from '@formily/shared'\nimport { GeneralField } from '@formily/core'\nimport { Schema } from '@formily/json-schema'\nimport { SchemaContext } from '../shared'\nimport { IRecursionFieldProps, ReactFC } from '../types'\nimport { useField, useExpressionScope } from '../hooks'\nimport { ObjectField } from './ObjectField'\nimport { ArrayField } from './ArrayField'\nimport { Field } from './Field'\nimport { VoidField } from './VoidField'\n\nconst useFieldProps = (schema: Schema) => {\n  const scope = useExpressionScope()\n  return schema.toFieldProps({\n    scope,\n  }) as any\n}\n\nconst useBasePath = (props: IRecursionFieldProps) => {\n  const parent = useField()\n  if (props.onlyRenderProperties) {\n    return props.basePath || parent?.address.concat(props.name)\n  }\n  return props.basePath || parent?.address\n}\n\nexport const RecursionField: ReactFC<IRecursionFieldProps> = (props) => {\n  const basePath = useBasePath(props)\n  const fieldSchema = useMemo(() => new Schema(props.schema), [props.schema])\n  const fieldProps = useFieldProps(fieldSchema)\n  const renderProperties = (field?: GeneralField) => {\n    if (props.onlyRenderSelf) return\n    const properties = Schema.getOrderProperties(fieldSchema)\n    if (!properties.length) return\n    return (\n      <Fragment>\n        {properties.map(({ schema: item, key: name }, index) => {\n          const base = field?.address || basePath\n          let schema: Schema = item\n          if (isFn(props.mapProperties)) {\n            const mapped = props.mapProperties(item, name)\n            if (mapped) {\n              schema = mapped\n            }\n          }\n          if (isFn(props.filterProperties)) {\n            if (props.filterProperties(schema, name) === false) {\n              return null\n            }\n          }\n          if (isBool(props.propsRecursion) && props.propsRecursion) {\n            return (\n              <RecursionField\n                propsRecursion={true}\n                filterProperties={props.filterProperties}\n                mapProperties={props.mapProperties}\n                schema={schema}\n                key={`${index}-${name}`}\n                name={name}\n                basePath={base}\n              />\n            )\n          }\n          return (\n            <RecursionField\n              schema={schema}\n              key={`${index}-${name}`}\n              name={name}\n              basePath={base}\n            />\n          )\n        })}\n      </Fragment>\n    )\n  }\n\n  const render = () => {\n    if (!isValid(props.name)) return renderProperties()\n    if (fieldSchema.type === 'object') {\n      if (props.onlyRenderProperties) return renderProperties()\n      return (\n        <ObjectField {...fieldProps} name={props.name} basePath={basePath}>\n          {renderProperties}\n        </ObjectField>\n      )\n    } else if (fieldSchema.type === 'array') {\n      return (\n        <ArrayField {...fieldProps} name={props.name} basePath={basePath} />\n      )\n    } else if (fieldSchema.type === 'void') {\n      if (props.onlyRenderProperties) return renderProperties()\n      return (\n        <VoidField {...fieldProps} name={props.name} basePath={basePath}>\n          {renderProperties}\n        </VoidField>\n      )\n    }\n    return <Field {...fieldProps} name={props.name} basePath={basePath} />\n  }\n\n  if (!fieldSchema) return <Fragment />\n\n  return (\n    <SchemaContext.Provider value={fieldSchema}>\n      {render()}\n    </SchemaContext.Provider>\n  )\n}\n"]}