{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import React from 'react'\nimport {\n  Form,\n  Field as FieldType,\n  VoidField,\n  ObjectField,\n  GeneralField,\n  IFieldFactoryProps,\n  IVoidFieldFactoryProps,\n  FormPatternTypes,\n  FieldDisplayTypes,\n  FieldValidator,\n} from '@formily/core'\nimport { ReactFC } from '@formily/reactive-react'\nimport { ISchema, Schema, SchemaKey } from '@formily/json-schema'\nimport { FormPathPattern } from '@formily/shared'\n\nexport type JSXComponent =\n  | keyof JSX.IntrinsicElements\n  | React.JSXElementConstructor<any>\n\nexport type IProviderProps = {\n  form: Form\n}\n\nexport interface IFormSpyProps {\n  children?: (form: Form) => ReactChild\n}\n\nexport type RenderPropsChildren<Payload> =\n  | ((field: Payload, form: Form) => React.ReactNode)\n  | React.ReactNode\n\nexport interface IFieldProps<\n  D extends JSXComponent,\n  C extends JSXComponent,\n  Field = FieldType\n> extends IFieldFactoryProps<D, C> {\n  children?: RenderPropsChildren<Field>\n  decorator?: [] | [D] | [D, React.ComponentProps<D>] | any[]\n  component?: [] | [C] | [C, React.ComponentProps<C>] | any[]\n}\n\nexport interface IVoidFieldProps<\n  D extends JSXComponent,\n  C extends JSXComponent,\n  Field = VoidField\n> extends IVoidFieldFactoryProps<D, C> {\n  children?: RenderPropsChildren<Field>\n  decorator?: [] | [D] | [D, React.ComponentProps<D>] | any[]\n  component?: [] | [C] | [C, React.ComponentProps<C>] | any[]\n}\n\nexport interface IComponentMapper<T extends JSXComponent> {\n  (target: T): JSXComponent\n}\n\nexport type IStateMapper<Props> =\n  | {\n      [key in keyof FieldType]?: keyof Props | boolean\n    }\n  | ((props: Props, field: GeneralField) => Props)\n\nexport type SchemaReactComponents = Record<string, JSXComponent>\n\nexport interface ISchemaFieldReactFactoryOptions<\n  Components extends SchemaReactComponents = any\n> {\n  components?: Components\n  scope?: any\n}\n\nexport interface ISchemaFieldOptionContext {\n  components: SchemaReactComponents\n}\n\nexport interface ISchemaFieldProps<\n  Decorator extends JSXComponent = any,\n  Component extends JSXComponent = any,\n  InnerField = ObjectField<Decorator, Component>\n> extends Omit<IFieldFactoryProps<Decorator, Component, InnerField>, 'name'> {\n  schema?: ISchema\n  components?: {\n    [key: string]: JSXComponent\n  }\n  scope?: any\n  name?: SchemaKey\n  children?: React.ReactNode\n}\n\nexport interface ISchemaMapper {\n  (schema: Schema, name: SchemaKey): Schema\n}\n\nexport interface ISchemaFilter {\n  (schema: Schema, name: SchemaKey): boolean\n}\nexport interface IRecursionFieldProps {\n  schema: ISchema\n  name?: SchemaKey\n  basePath?: FormPathPattern\n  propsRecursion?: boolean\n  onlyRenderProperties?: boolean\n  onlyRenderSelf?: boolean\n  mapProperties?: ISchemaMapper\n  filterProperties?: ISchemaFilter\n}\n\nexport type ObjectKey = string | number | boolean | symbol\n\nexport type Path<T, Key extends keyof T = keyof T> = Key extends string\n  ? T[Key] extends Record<string, any>\n    ?\n        | `${Key}.${Path<T[Key], Exclude<keyof T[Key], keyof Array<any>>> &\n            string}`\n        | `${Key}.${Exclude<keyof T[Key], keyof Array<any>> & string}`\n        | Key\n    : Key\n  : never\n\nexport type PathValue<\n  T,\n  P extends Path<T>\n> = P extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof T\n    ? Rest extends Path<T[Key]>\n      ? PathValue<T[Key], Rest>\n      : never\n    : never\n  : P extends keyof T\n  ? T[P]\n  : never\n\nexport type KeyOfReactComponent<T> = Exclude<\n  keyof T,\n  'contextTypes' | 'displayName' | 'propTypes' | 'defaultProps'\n>\n\nexport type ReactComponentPath<\n  T,\n  Key extends KeyOfReactComponent<T> = KeyOfReactComponent<T>\n> = Key extends string\n  ? T[Key] extends Record<string, any>\n    ?\n        | `${Key}.${Exclude<KeyOfReactComponent<T[Key]>, keyof Array<any>> &\n            string}`\n        | Key\n    : Key\n  : never\n\nexport type ReactComponentPropsByPathValue<\n  T extends Record<string, any>,\n  P extends ReactComponentPath<T>\n> = P extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof T\n    ? Rest extends ReactComponentPath<T[Key]>\n      ? ReactComponentPropsByPathValue<T[Key], Rest>\n      : never\n    : React.ComponentProps<T[P]>\n  : P extends keyof T\n  ? React.ComponentProps<T[P]>\n  : never\nexport interface ISchemaMarkupFieldProps<\n  Components extends SchemaReactComponents,\n  Decorator extends ReactComponentPath<Components>,\n  Component extends ReactComponentPath<Components>\n> extends ISchema<\n    Decorator,\n    Component,\n    ReactComponentPropsByPathValue<Components, Decorator>,\n    ReactComponentPropsByPathValue<Components, Component>,\n    FormPatternTypes,\n    FieldDisplayTypes,\n    FieldValidator,\n    React.ReactNode,\n    GeneralField\n  > {\n  children?: React.ReactNode\n}\n\nexport type ISchemaTypeFieldProps<\n  Components extends SchemaReactComponents,\n  Decorator extends ReactComponentPath<Components>,\n  Component extends ReactComponentPath<Components>\n> = ISchemaMarkupFieldProps<Components, Decorator, Component>\n\nexport interface IExpressionScopeProps {\n  value?: any\n}\n\nexport interface IRecordScopeProps {\n  getIndex?(): number\n  getRecord(): any\n}\n\nexport interface IRecordsScopeProps {\n  getRecords(): any[]\n}\n\nexport type ReactChild = React.ReactElement | string | number\n\nexport { ReactFC }\n"]}