{"version":3,"file":"array.js","sourceRoot":"","sources":["../src/array.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,YAAY,CAAA;AAiChD,MAAM,CAAC,IAAM,KAAK,GAAG,UAAC,GAAQ,IAAY,OAAA,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAArC,CAAqC,CAAA;AAgB/E,MAAM,UAAU,IAAI,CAAC,GAAQ,EAAE,QAAa,EAAE,MAAgB;IAC5D,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;QAC5B,IAAI,MAAM,EAAE;YACV,KAAK,IAAI,CAAC,GAAW,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;gBAChD,IAAI,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;oBACjC,OAAM;iBACP;aACF;SACF;aAAM;YACL,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACnC,IAAI,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;oBACjC,OAAM;iBACP;aACF;SACF;KACF;SAAM,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;QACrB,IAAI,GAAG,SAAQ,CAAA;QACf,KAAK,GAAG,IAAI,GAAG,EAAE;YACf,IAAI,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;gBACxC,IAAI,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,KAAK,EAAE;oBACrC,OAAM;iBACP;aACF;SACF;KACF;AACH,CAAC;AAiBD,MAAM,UAAU,GAAG,CAAC,GAAQ,EAAE,QAAa,EAAE,MAAY;IACvD,IAAM,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAA;IAC9C,IAAI,CACF,GAAG,EACH,UAAC,IAAI,EAAE,GAAG;QACR,IAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,CAAA;QACjC,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;YACd,CAAC;YAAC,GAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;SAC1B;aAAM;YACL,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAA;SACjB;IACH,CAAC,EACD,MAAM,CACP,CAAA;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAoBD,MAAM,UAAU,MAAM,CACpB,GAAQ,EACR,QAAa,EACb,WAAiB,EACjB,MAAgB;IAEhB,IAAI,MAAM,GAAG,WAAW,CAAA;IACxB,IAAI,CACF,GAAG,EACH,UAAC,IAAI,EAAE,GAAG;QACR,MAAM,GAAG,QAAQ,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,CAAC,CAAA;IACtC,CAAC,EACD,MAAM,CACP,CAAA;IACD,OAAO,MAAM,CAAA;AACf,CAAC;AAiBD,MAAM,UAAU,KAAK,CAAC,GAAQ,EAAE,QAAa,EAAE,MAAgB;IAC7D,IAAI,GAAG,GAAG,IAAI,CAAA;IACd,IAAI,CACF,GAAG,EACH,UAAC,IAAI,EAAE,GAAG;QACR,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;YACxB,GAAG,GAAG,KAAK,CAAA;YACX,OAAO,KAAK,CAAA;SACb;IACH,CAAC,EACD,MAAM,CACP,CAAA;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAiBD,MAAM,UAAU,IAAI,CAAC,GAAQ,EAAE,QAAa,EAAE,MAAgB;IAC5D,IAAI,GAAG,GAAG,KAAK,CAAA;IACf,IAAI,CACF,GAAG,EACH,UAAC,IAAI,EAAE,GAAG;QACR,IAAI,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;YACvB,GAAG,GAAG,IAAI,CAAA;YACV,OAAO,KAAK,CAAA;SACb;IACH,CAAC,EACD,MAAM,CACP,CAAA;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAiBD,MAAM,UAAU,SAAS,CACvB,GAAQ,EACR,QAAa,EACb,MAAgB;IAEhB,IAAI,GAAG,GAAoB,CAAC,CAAC,CAAA;IAC7B,IAAI,CACF,GAAG,EACH,UAAC,IAAI,EAAE,GAAG;QACR,IAAI,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;YACvB,GAAG,GAAG,GAAG,CAAA;YACT,OAAO,KAAK,CAAA;SACb;IACH,CAAC,EACD,MAAM,CACP,CAAA;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAiBD,MAAM,UAAU,IAAI,CAAC,GAAQ,EAAE,QAAa,EAAE,MAAgB;IAC5D,IAAI,GAAQ,CAAA;IACZ,IAAI,CACF,GAAG,EACH,UAAC,IAAI,EAAE,GAAG;QACR,IAAI,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;YACvB,GAAG,GAAG,IAAI,CAAA;YACV,OAAO,KAAK,CAAA;SACb;IACH,CAAC,EACD,MAAM,CACP,CAAA;IACD,OAAO,GAAG,CAAA;AACZ,CAAC;AAYD,MAAM,UAAU,QAAQ,CAAC,GAAQ,EAAE,aAAkB,EAAE,MAAgB;IACrE,IAAI,KAAK,CAAC,GAAG,CAAC;QAAE,OAAO,GAAG,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAA;IAClD,OAAO,IAAI,CAAC,GAAG,EAAE,UAAC,IAAI,IAAK,OAAA,IAAI,KAAK,aAAa,EAAtB,CAAsB,EAAE,MAAM,CAAC,CAAA;AAC5D,CAAC;AAED,MAAM,UAAU,IAAI,CAClB,KAAU,EACV,SAAiB,EACjB,OAAe;IAEf,IAAI,SAAS,KAAK,OAAO;QAAE,OAAO,KAAK,CAAA;IAEvC,IACE,OAAO,GAAG,CAAC;QACX,SAAS,GAAG,CAAC;QACb,OAAO,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC;QAC1B,SAAS,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAC5B;QACA,OAAO,KAAK,CAAA;KACb;IAED,IAAI,SAAS,GAAG,OAAO,EAAE;QACvB,IAAM,QAAQ,GAAG,KAAK,CAAC,SAAS,CAAC,CAAA;QACjC,KAAK,IAAI,KAAK,GAAG,SAAS,EAAE,KAAK,GAAG,OAAO,EAAE,KAAK,EAAE,EAAE;YACpD,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;SAChC;QACD,KAAK,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAA;KAC1B;SAAM;QACL,IAAM,QAAQ,GAAG,KAAK,CAAC,SAAS,CAAC,CAAA;QACjC,KAAK,IAAI,KAAK,GAAG,SAAS,EAAE,KAAK,GAAG,OAAO,EAAE,KAAK,EAAE,EAAE;YACpD,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;SAChC;QACD,KAAK,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAA;KAC1B;IACD,OAAO,KAAK,CAAA;AACd,CAAC","sourcesContent":["import { isArr, isObj, isStr } from './checkers'\n\ntype EachArrayIterator<T> = (currentValue: T, key: number) => void | boolean\ntype EachStringIterator = (currentValue: string, key: number) => void | boolean\ntype EachObjectIterator<T = any> = (\n  currentValue: T,\n  key: string\n) => void | boolean\ntype MapArrayIterator<TItem, TResult> = (\n  currentValue: TItem,\n  key: number\n) => TResult\ntype MapStringIterator<TResult> = (currentValue: string, key: number) => TResult\ntype MapObjectIterator<TItem, TResult> = (\n  currentValue: TItem,\n  key: string\n) => TResult\ntype MemoArrayIterator<T, U> = (\n  previousValue: U,\n  currentValue: T,\n  key: number\n) => U\ntype MemoStringIterator<T> = (\n  previousValue: T,\n  currentValue: string,\n  key: number\n) => T\ntype MemoObjectIterator<TValue, TResult> = (\n  previousValue: TResult,\n  currentValue: TValue,\n  key: string\n) => TResult\n\nexport const toArr = (val: any): any[] => (isArr(val) ? val : val ? [val] : [])\nexport function each(\n  val: string,\n  iterator: EachStringIterator,\n  revert?: boolean\n): void\nexport function each<T>(\n  val: T[],\n  iterator: EachArrayIterator<T>,\n  revert?: boolean\n): void\nexport function each<T extends {}, TValue extends T[keyof T]>(\n  val: T,\n  iterator: EachObjectIterator<TValue>,\n  revert?: boolean\n): void\nexport function each(val: any, iterator: any, revert?: boolean): void {\n  if (isArr(val) || isStr(val)) {\n    if (revert) {\n      for (let i: number = val.length - 1; i >= 0; i--) {\n        if (iterator(val[i], i) === false) {\n          return\n        }\n      }\n    } else {\n      for (let i = 0; i < val.length; i++) {\n        if (iterator(val[i], i) === false) {\n          return\n        }\n      }\n    }\n  } else if (isObj(val)) {\n    let key: string\n    for (key in val) {\n      if (Object.hasOwnProperty.call(val, key)) {\n        if (iterator(val[key], key) === false) {\n          return\n        }\n      }\n    }\n  }\n}\n\nexport function map<T>(\n  val: string,\n  iterator: MapStringIterator<T>,\n  revert?: boolean\n): T[]\nexport function map<TItem, TResult>(\n  val: TItem[],\n  iterator: MapArrayIterator<TItem, TResult>,\n  revert?: boolean\n): TResult[]\nexport function map<T extends {}, TResult>(\n  val: T,\n  iterator: MapObjectIterator<T[keyof T], TResult>,\n  revert?: boolean\n): Record<keyof T, TResult>\nexport function map(val: any, iterator: any, revert?: any): any {\n  const res = isArr(val) || isStr(val) ? [] : {}\n  each(\n    val,\n    (item, key) => {\n      const value = iterator(item, key)\n      if (isArr(res)) {\n        ;(res as any).push(value)\n      } else {\n        res[key] = value\n      }\n    },\n    revert\n  )\n  return res\n}\n\nexport function reduce<T, U>(\n  val: T[],\n  iterator: MemoArrayIterator<T, U>,\n  accumulator?: U,\n  revert?: boolean\n): U\nexport function reduce<T>(\n  val: string,\n  iterator: MemoStringIterator<T>,\n  accumulator?: T,\n  revert?: boolean\n): T\nexport function reduce<T extends {}, TValue extends T[keyof T], TResult = any>(\n  val: T,\n  iterator: MemoObjectIterator<TValue, TResult>,\n  accumulator?: TResult,\n  revert?: boolean\n): TResult\nexport function reduce(\n  val: any,\n  iterator: any,\n  accumulator?: any,\n  revert?: boolean\n): any {\n  let result = accumulator\n  each(\n    val,\n    (item, key) => {\n      result = iterator(result, item, key)\n    },\n    revert\n  )\n  return result\n}\n\nexport function every<T extends string>(\n  val: T,\n  iterator: EachStringIterator,\n  revert?: boolean\n): boolean\nexport function every<T>(\n  val: T[],\n  iterator: EachArrayIterator<T>,\n  revert?: boolean\n): boolean\nexport function every<T extends {}>(\n  val: T,\n  iterator: EachObjectIterator,\n  revert?: boolean\n): boolean\nexport function every(val: any, iterator: any, revert?: boolean): boolean {\n  let res = true\n  each(\n    val,\n    (item, key) => {\n      if (!iterator(item, key)) {\n        res = false\n        return false\n      }\n    },\n    revert\n  )\n  return res\n}\n\nexport function some<T extends string>(\n  val: T,\n  iterator: EachStringIterator,\n  revert?: boolean\n): boolean\nexport function some<T>(\n  val: T[],\n  iterator: EachArrayIterator<T>,\n  revert?: boolean\n): boolean\nexport function some<T extends {}>(\n  val: T,\n  iterator: EachObjectIterator,\n  revert?: boolean\n): boolean\nexport function some(val: any, iterator: any, revert?: boolean): boolean {\n  let res = false\n  each(\n    val,\n    (item, key) => {\n      if (iterator(item, key)) {\n        res = true\n        return false\n      }\n    },\n    revert\n  )\n  return res\n}\n\nexport function findIndex<T extends string>(\n  val: T,\n  iterator: EachStringIterator,\n  revert?: boolean\n): number\nexport function findIndex<T>(\n  val: T[],\n  iterator: EachArrayIterator<T>,\n  revert?: boolean\n): number\nexport function findIndex<T extends {}>(\n  val: T,\n  iterator: EachObjectIterator,\n  revert?: boolean\n): keyof T\nexport function findIndex(\n  val: any,\n  iterator: any,\n  revert?: boolean\n): string | number {\n  let res: number | string = -1\n  each(\n    val,\n    (item, key) => {\n      if (iterator(item, key)) {\n        res = key\n        return false\n      }\n    },\n    revert\n  )\n  return res\n}\n\nexport function find<T extends string>(\n  val: T,\n  iterator: EachStringIterator,\n  revert?: boolean\n): any\nexport function find<T>(\n  val: T[],\n  iterator: EachArrayIterator<T>,\n  revert?: boolean\n): T\nexport function find<T extends {}>(\n  val: T,\n  iterator: EachObjectIterator,\n  revert?: boolean\n): T[keyof T]\nexport function find(val: any, iterator: any, revert?: boolean): any {\n  let res: any\n  each(\n    val,\n    (item, key) => {\n      if (iterator(item, key)) {\n        res = item\n        return false\n      }\n    },\n    revert\n  )\n  return res\n}\n\nexport function includes<T extends string>(\n  val: T,\n  searchElement: string,\n  revert?: boolean\n): boolean\nexport function includes<T>(\n  val: T[],\n  searchElement: T,\n  revert?: boolean\n): boolean\nexport function includes(val: any, searchElement: any, revert?: boolean) {\n  if (isStr(val)) return val.includes(searchElement)\n  return some(val, (item) => item === searchElement, revert)\n}\n\nexport function move<T extends any>(\n  array: T[],\n  fromIndex: number,\n  toIndex: number\n) {\n  if (fromIndex === toIndex) return array\n\n  if (\n    toIndex < 0 ||\n    fromIndex < 0 ||\n    toIndex > array.length - 1 ||\n    fromIndex > array.length - 1\n  ) {\n    return array\n  }\n\n  if (fromIndex < toIndex) {\n    const fromItem = array[fromIndex]\n    for (let index = fromIndex; index < toIndex; index++) {\n      array[index] = array[index + 1]\n    }\n    array[toIndex] = fromItem\n  } else {\n    const fromItem = array[fromIndex]\n    for (let index = fromIndex; index > toIndex; index--) {\n      array[index] = array[index - 1]\n    }\n    array[toIndex] = fromItem\n  }\n  return array\n}\n"]}