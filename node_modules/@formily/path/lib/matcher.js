"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Matcher = void 0;
var types_1 = require("./types");
var shared_1 = require("./shared");
var Matcher = /** @class */ (function () {
    function Matcher(tree, record) {
        this.tree = tree;
        this.stack = [];
        this.excluding = false;
        this.wildcards = [];
        this.record = record;
    }
    Matcher.prototype.next = function (node, pos) {
        //  const isOverToken = pos > this.path.length
        if (node.after) {
            // if (isOverToken) {
            //   return false
            // }
            return this.matchNode(node.after, pos);
        }
        if ((0, types_1.isWildcardOperator)(node) && !node.filter) {
            if (this.excluding) {
                return false;
            }
            else {
                if (pos === 0 || node.optional)
                    return true;
                return !!this.take(pos);
            }
        }
        var isLastToken = pos === this.path.length - 1;
        if (isLastToken) {
            return !!this.take(pos);
        }
        else {
            var wildcard = this.wildcards.pop();
            if (wildcard && wildcard.after) {
                return this.next(wildcard, pos);
            }
        }
        return false;
    };
    Matcher.prototype.shot = function () {
        var _a;
        if (((_a = this.record) === null || _a === void 0 ? void 0 : _a.score) >= 0) {
            this.record.score++;
        }
    };
    Matcher.prototype.take = function (pos) {
        var _a;
        return String((_a = this.path[pos]) !== null && _a !== void 0 ? _a : '');
    };
    Matcher.prototype.matchExcludeIdentifier = function (matched, node, pos) {
        var isLastToken = pos === this.path.length - 1;
        var isContainToken = pos < this.path.length;
        if (!node.after) {
            this.excluding = false;
        }
        if (matched) {
            if (node.after) {
                return this.next(node, pos);
            }
            if (isLastToken) {
                return false;
            }
        }
        if (isLastToken) {
            return true;
        }
        return isContainToken;
    };
    Matcher.prototype.matchIdentifier = function (node, pos) {
        var current = this.take(pos);
        var matched = false;
        if ((0, types_1.isExpandOperator)(node.after)) {
            if (current.indexOf(node.value) === 0) {
                this.shot();
                matched = true;
            }
            if (this.excluding) {
                return this.matchExcludeIdentifier(matched, node.after, pos);
            }
            else {
                return matched && this.next(node.after, pos);
            }
        }
        else if (current === node.value) {
            this.shot();
            matched = true;
        }
        if (this.excluding) {
            return this.matchExcludeIdentifier(matched, node, pos);
        }
        else {
            return matched && this.next(node, pos);
        }
    };
    Matcher.prototype.matchIgnoreExpression = function (node, pos) {
        return (0, shared_1.isEqual)(node.value, this.take(pos)) && this.next(node, pos);
    };
    Matcher.prototype.matchDestructorExpression = function (node, pos) {
        return (0, shared_1.isEqual)(node.source, this.take(pos)) && this.next(node, pos);
    };
    Matcher.prototype.matchExpandOperator = function (node, pos) {
        return this.next(node, pos);
    };
    Matcher.prototype.matchWildcardOperator = function (node, pos) {
        var matched = false;
        if (node.filter) {
            this.stack.push(node);
            matched = this.matchNode(node.filter, pos);
            this.stack.pop();
        }
        else {
            matched = this.next(node, pos);
        }
        return matched;
    };
    Matcher.prototype.matchGroupExpression = function (node, pos) {
        var _this = this;
        var excluding = false;
        if (node.isExclude) {
            excluding = !this.excluding;
        }
        return (0, shared_1.toArr)(node.value)[excluding ? 'every' : 'some'](function (item) {
            _this.wildcards = _this.stack.slice();
            _this.excluding = excluding;
            return _this.matchNode(item, pos);
        });
    };
    Matcher.prototype.matchRangeExpression = function (node, pos) {
        var current = Number(this.take(pos));
        if (node.start) {
            if (node.end) {
                return (current >= Number(node.start.value) &&
                    current <= Number(node.end.value));
            }
            else {
                return current >= Number(node.start.value);
            }
        }
        else {
            if (node.end) {
                return current <= Number(node.end.value);
            }
            else {
                this.wildcards = this.stack.slice();
                return this.next(node, pos);
            }
        }
    };
    Matcher.prototype.matchNode = function (node, pos) {
        if (pos === void 0) { pos = 0; }
        if ((0, types_1.isDotOperator)(node)) {
            return this.next(node, pos + 1);
        }
        else if ((0, types_1.isIdentifier)(node)) {
            return this.matchIdentifier(node, pos);
        }
        else if ((0, types_1.isIgnoreExpression)(node)) {
            return this.matchIgnoreExpression(node, pos);
        }
        else if ((0, types_1.isDestructorExpression)(node)) {
            return this.matchDestructorExpression(node, pos);
        }
        else if ((0, types_1.isExpandOperator)(node)) {
            return this.matchExpandOperator(node, pos);
        }
        else if ((0, types_1.isWildcardOperator)(node)) {
            return this.matchWildcardOperator(node, pos);
        }
        else if ((0, types_1.isGroupExpression)(node)) {
            return this.matchGroupExpression(node, pos);
        }
        else if ((0, types_1.isRangeExpression)(node)) {
            return this.matchRangeExpression(node, pos);
        }
        return false;
    };
    Matcher.prototype.match = function (path) {
        this.path = path;
        return { matched: this.matchNode(this.tree), record: this.record };
    };
    Matcher.matchSegments = function (source, target, record) {
        if (source.length !== target.length)
            return { matched: false, record: record };
        var match = function (pos) {
            if (pos === void 0) { pos = 0; }
            var current = (0, shared_1.isSegmentEqual)(source[pos], target[pos]);
            if ((record === null || record === void 0 ? void 0 : record.score) >= 0) {
                record.score++;
            }
            return current && (pos < source.length - 1 ? match(pos + 1) : true);
        };
        return { matched: match(), record: record };
    };
    return Matcher;
}());
exports.Matcher = Matcher;
//# sourceMappingURL=matcher.js.map