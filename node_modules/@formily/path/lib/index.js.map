{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Parser } from './parser'\nimport { isStr, isArr, isFn, isEqual, isObj, isNum, isRegExp } from './shared'\nimport {\n  getDestructor,\n  getInByDestructor,\n  setInByDestructor,\n  deleteInByDestructor,\n  existInByDestructor,\n} from './destructor'\nimport { Segments, Node, Pattern } from './types'\nimport { Matcher } from './matcher'\n\nconst pathCache = new Map()\n\nconst isMatcher = Symbol('PATH_MATCHER')\n\nconst isValid = (val: any) => val !== undefined && val !== null\n\nconst isSimplePath = (val: string) =>\n  val.indexOf('*') === -1 &&\n  val.indexOf('~') === -1 &&\n  val.indexOf('[') === -1 &&\n  val.indexOf(']') === -1 &&\n  val.indexOf(',') === -1 &&\n  val.indexOf(':') === -1 &&\n  val.indexOf(' ') === -1 &&\n  val[0] !== '.'\n\nconst isAssignable = (val: any) =>\n  typeof val === 'object' || typeof val === 'function'\n\nconst isNumberIndex = (val: any) =>\n  isStr(val) ? /^\\d+$/.test(val) : isNum(val)\n\nconst getIn = (segments: Segments, source: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (!isValid(source)) return\n      source = source[index]\n    } else {\n      source = getInByDestructor(source, rules, { setIn, getIn })\n      break\n    }\n  }\n  return source\n}\n\nconst setIn = (segments: Segments, source: any, value: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (!isValid(source) || !isAssignable(source)) return\n      if (isArr(source) && !isNumberIndex(index)) {\n        return\n      }\n      if (!isValid(source[index])) {\n        if (value === undefined) {\n          if (source[index] === null) source[index] = value\n          return\n        }\n        if (i < segments.length - 1) {\n          source[index] = isNum(segments[i + 1]) ? [] : {}\n        }\n      }\n      if (i === segments.length - 1) {\n        source[index] = value\n      }\n      source = source[index]\n    } else {\n      setInByDestructor(source, rules, value, { setIn, getIn })\n      break\n    }\n  }\n}\n\nconst deleteIn = (segments: Segments, source: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (i === segments.length - 1 && isValid(source)) {\n        delete source[index]\n        return\n      }\n\n      if (!isValid(source) || !isAssignable(source)) return\n      source = source[index]\n      if (!isObj(source)) {\n        return\n      }\n    } else {\n      deleteInByDestructor(source, rules, {\n        setIn,\n        getIn,\n        deleteIn,\n      })\n      break\n    }\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nconst existIn = (segments: Segments, source: any, start: number | Path) => {\n  if (start instanceof Path) {\n    start = start.length\n  }\n  for (let i = start; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (i === segments.length - 1) {\n        return hasOwnProperty.call(source, index)\n      }\n\n      if (!isValid(source) || !isAssignable(source)) return false\n      source = source[index]\n\n      if (!isObj(source)) {\n        return false\n      }\n    } else {\n      return existInByDestructor(source, rules, start, {\n        setIn,\n        getIn,\n        deleteIn,\n        existIn,\n      })\n    }\n  }\n}\n\nconst parse = (pattern: Pattern, base?: Pattern) => {\n  if (pattern instanceof Path) {\n    return {\n      entire: pattern.entire,\n      segments: pattern.segments.slice(),\n      isRegExp: false,\n      haveRelativePattern: pattern.haveRelativePattern,\n      isWildMatchPattern: pattern.isWildMatchPattern,\n      isMatchPattern: pattern.isMatchPattern,\n      haveExcludePattern: pattern.haveExcludePattern,\n      tree: pattern.tree,\n    }\n  } else if (isStr(pattern)) {\n    if (!pattern) {\n      return {\n        entire: '',\n        segments: [],\n        isRegExp: false,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    }\n    if (isSimplePath(pattern)) {\n      return {\n        entire: pattern,\n        segments: pattern.split('.'),\n        isRegExp: false,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    }\n    const parser = new Parser(pattern, Path.parse(base))\n    const tree = parser.parse()\n    if (!parser.isMatchPattern) {\n      const segments = parser.data.segments\n      return {\n        entire: segments.join('.'),\n        segments,\n        tree,\n        isRegExp: false,\n        haveRelativePattern: parser.haveRelativePattern,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    } else {\n      return {\n        entire: pattern,\n        segments: [],\n        isRegExp: false,\n        haveRelativePattern: false,\n        isWildMatchPattern: parser.isWildMatchPattern,\n        haveExcludePattern: parser.haveExcludePattern,\n        isMatchPattern: true,\n        tree,\n      }\n    }\n  } else if (isFn(pattern) && pattern[isMatcher]) {\n    return parse(pattern['path'])\n  } else if (isArr(pattern)) {\n    return {\n      entire: pattern.join('.'),\n      segments: pattern.reduce((buf, key) => {\n        return buf.concat(parseString(key))\n      }, []),\n      isRegExp: false,\n      haveRelativePattern: false,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: false,\n    }\n  } else if (isRegExp(pattern)) {\n    return {\n      entire: pattern,\n      segments: [],\n      isRegExp: true,\n      haveRelativePattern: false,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: true,\n    }\n  } else {\n    return {\n      entire: '',\n      isRegExp: false,\n      segments: pattern !== undefined ? [pattern] : [],\n      haveRelativePattern: false,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: false,\n    }\n  }\n}\n\nconst parseString = (source: any) => {\n  if (isStr(source)) {\n    source = source.replace(/\\s*/g, '')\n    try {\n      const { segments, isMatchPattern } = parse(source)\n      return !isMatchPattern ? segments : source\n    } catch (e) {\n      return source\n    }\n  } else if (source instanceof Path) {\n    return source.segments\n  }\n  return source\n}\n\nexport class Path {\n  public entire: string | RegExp\n  public segments: Segments\n  public isMatchPattern: boolean\n  public isWildMatchPattern: boolean\n  public isRegExp: boolean\n  public haveRelativePattern: boolean\n  public haveExcludePattern: boolean\n  public matchScore: number\n  public tree: Node\n  private matchCache: any\n  private includesCache: any\n\n  constructor(input: Pattern, base?: Pattern) {\n    const {\n      tree,\n      segments,\n      entire,\n      isRegExp,\n      isMatchPattern,\n      isWildMatchPattern,\n      haveRelativePattern,\n      haveExcludePattern,\n    } = parse(input, base)\n    this.entire = entire\n    this.segments = segments\n    this.isMatchPattern = isMatchPattern\n    this.isWildMatchPattern = isWildMatchPattern\n    this.haveRelativePattern = haveRelativePattern\n    this.isRegExp = isRegExp\n    this.haveExcludePattern = haveExcludePattern\n    this.tree = tree as Node\n    this.matchCache = new Map()\n    this.includesCache = new Map()\n  }\n\n  toString() {\n    return this.entire?.toString()\n  }\n\n  toArr() {\n    return this.segments?.slice()\n  }\n\n  get length() {\n    return this.segments.length\n  }\n\n  concat = (...args: Pattern[]) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be concat`)\n    }\n    const path = new Path('')\n    path.segments = this.segments.concat(...args.map((s) => parseString(s)))\n    path.entire = path.segments.join('.')\n    return path\n  }\n\n  slice = (start?: number, end?: number) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be slice`)\n    }\n    const path = new Path('')\n    path.segments = this.segments.slice(start, end)\n    path.entire = path.segments.join('.')\n    return path\n  }\n\n  push = (...items: Pattern[]) => {\n    return this.concat(...items)\n  }\n\n  pop = () => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be pop`)\n    }\n    return new Path(this.segments.slice(0, this.segments.length - 1))\n  }\n\n  splice = (\n    start: number,\n    deleteCount?: number,\n    ...items: Array<string | number>\n  ) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be splice`)\n    }\n    items = items.reduce((buf, item) => buf.concat(parseString(item)), [])\n    const segments_ = this.segments.slice()\n    segments_.splice(start, deleteCount, ...items)\n    return new Path(segments_)\n  }\n\n  forEach = (callback: (key: string | number) => any) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be each`)\n    }\n    this.segments.forEach(callback)\n  }\n\n  map = (callback: (key: string | number) => any) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be map`)\n    }\n    return this.segments.map(callback)\n  }\n\n  reduce = <T>(\n    callback: (buf: T, item: string | number, index: number) => T,\n    initial: T\n  ): T => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be reduce`)\n    }\n    return this.segments.reduce(callback, initial)\n  }\n\n  parent = () => {\n    return this.slice(0, this.length - 1)\n  }\n\n  includes = (pattern: Pattern) => {\n    const { entire, segments, isMatchPattern } = Path.parse(pattern)\n    const cache = this.includesCache.get(entire)\n    if (cache !== undefined) return cache\n    const cacheWith = (value: boolean): boolean => {\n      this.includesCache.set(entire, value)\n      return value\n    }\n    if (this.isMatchPattern) {\n      if (!isMatchPattern) {\n        return cacheWith(this.match(segments))\n      } else {\n        throw new Error(`${this.entire} cannot be used to match ${entire}`)\n      }\n    }\n    if (isMatchPattern) {\n      throw new Error(`${this.entire} cannot be used to match ${entire}`)\n    }\n    if (segments.length > this.segments.length) return cacheWith(false)\n    for (let i = 0; i < segments.length; i++) {\n      if (!isEqual(String(segments[i]), String(this.segments[i]))) {\n        return cacheWith(false)\n      }\n    }\n    return cacheWith(true)\n  }\n\n  transform = <T>(\n    regexp: string | RegExp,\n    callback: (...args: string[]) => T\n  ): T | string => {\n    if (!isFn(callback)) return ''\n    if (this.isMatchPattern) {\n      throw new Error(`${this.entire} cannot be transformed`)\n    }\n    const reg = new RegExp(regexp)\n    const args = this.segments.filter((key) =>\n      reg.test(key as string)\n    ) as string[]\n    return callback(...args)\n  }\n\n  match = (pattern: Pattern): boolean => {\n    const path = Path.parse(pattern)\n    const cache = this.matchCache.get(path.entire)\n    if (cache !== undefined) {\n      if (cache.record && cache.record.score !== undefined) {\n        this.matchScore = cache.record.score\n      }\n      return cache.matched\n    }\n    const cacheWith = (value: any) => {\n      this.matchCache.set(path.entire, value)\n      return value\n    }\n    if (path.isMatchPattern) {\n      if (this.isMatchPattern) {\n        throw new Error(`${path.entire} cannot match ${this.entire}`)\n      } else {\n        this.matchScore = 0\n        return cacheWith(path.match(this.segments))\n      }\n    } else {\n      if (this.isMatchPattern) {\n        if (this.isRegExp) {\n          try {\n            return this['entire']?.['test']?.(path.entire)\n          } finally {\n            ;(this.entire as RegExp).lastIndex = 0\n          }\n        }\n        const record = {\n          score: 0,\n        }\n        const result = cacheWith(\n          new Matcher(this.tree, record).match(path.segments)\n        )\n        this.matchScore = record.score\n        return result.matched\n      } else {\n        const record = {\n          score: 0,\n        }\n        const result = cacheWith(\n          Matcher.matchSegments(this.segments, path.segments, record)\n        )\n        this.matchScore = record.score\n        return result.matched\n      }\n    }\n  }\n\n  //别名组匹配\n  matchAliasGroup = (name: Pattern, alias: Pattern) => {\n    const namePath = Path.parse(name)\n    const aliasPath = Path.parse(alias)\n    const nameMatched = this.match(namePath)\n    const nameMatchedScore = this.matchScore\n    const aliasMatched = this.match(aliasPath)\n    const aliasMatchedScore = this.matchScore\n    if (this.haveExcludePattern) {\n      if (nameMatchedScore >= aliasMatchedScore) {\n        return nameMatched\n      } else {\n        return aliasMatched\n      }\n    } else {\n      return nameMatched || aliasMatched\n    }\n  }\n\n  existIn = (source?: any, start: number | Path = 0) => {\n    return existIn(this.segments, source, start)\n  }\n\n  getIn = (source?: any) => {\n    return getIn(this.segments, source)\n  }\n\n  setIn = (source?: any, value?: any) => {\n    setIn(this.segments, source, value)\n    return source\n  }\n\n  deleteIn = (source?: any) => {\n    deleteIn(this.segments, source)\n    return source\n  }\n\n  ensureIn = (source?: any, defaults?: any) => {\n    const results = this.getIn(source)\n    if (results === undefined) {\n      this.setIn(source, defaults)\n      return this.getIn(source)\n    }\n    return results\n  }\n\n  static match(pattern: Pattern) {\n    const path = Path.parse(pattern)\n    const matcher = (target) => {\n      return path.match(target)\n    }\n    matcher[isMatcher] = true\n    matcher.path = path\n    return matcher\n  }\n\n  static isPathPattern(target: any): target is Pattern {\n    return !!(\n      isStr(target) ||\n      isArr(target) ||\n      isRegExp(target) ||\n      (isFn(target) && target[isMatcher])\n    )\n  }\n\n  static transform<T>(\n    pattern: Pattern,\n    regexp: string | RegExp,\n    callback: (...args: string[]) => T\n  ): any {\n    return Path.parse(pattern).transform(regexp, callback)\n  }\n\n  static parse(path: Pattern = '', base?: Pattern): Path {\n    if (path instanceof Path) {\n      const found = pathCache.get(path.entire)\n      if (found) {\n        return found\n      } else {\n        pathCache.set(path.entire, path)\n        return path\n      }\n    } else if (path && path[isMatcher]) {\n      return Path.parse(path['path'])\n    } else {\n      const key_ = base ? Path.parse(base) : ''\n      const key = `${path}:${key_}`\n      const found = pathCache.get(key)\n      if (found) {\n        return found\n      } else {\n        path = new Path(path, base)\n        pathCache.set(key, path)\n        return path\n      }\n    }\n  }\n\n  static getIn = (source: any, pattern: Pattern) => {\n    const path = Path.parse(pattern)\n    return path.getIn(source)\n  }\n\n  static setIn = (source: any, pattern: Pattern, value: any) => {\n    const path = Path.parse(pattern)\n    return path.setIn(source, value)\n  }\n\n  static deleteIn = (source: any, pattern: Pattern) => {\n    const path = Path.parse(pattern)\n    return path.deleteIn(source)\n  }\n\n  static existIn = (source: any, pattern: Pattern, start?: number | Path) => {\n    const path = Path.parse(pattern)\n    return path.existIn(source, start)\n  }\n\n  static ensureIn = (source: any, pattern: Pattern, defaultValue?: any) => {\n    const path = Path.parse(pattern)\n    return path.ensureIn(source, defaultValue)\n  }\n}\n\nexport { Pattern }\n"]}