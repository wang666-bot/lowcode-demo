{"version":3,"file":"matcher.js","sourceRoot":"","sources":["../src/matcher.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Segments,\n  Node,\n  isIdentifier,\n  isExpandOperator,\n  isWildcardOperator,\n  isGroupExpression,\n  isRangeExpression,\n  isIgnoreExpression,\n  isDotOperator,\n  isDestructorExpression,\n  IdentifierNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  GroupExpressionNode,\n  RangeExpressionNode,\n} from './types'\nimport { isEqual, toArr, isSegmentEqual } from './shared'\nexport interface IRecord {\n  score: number\n}\n\nexport class Matcher {\n  private tree: Node\n\n  private stack: Node[]\n\n  private record: IRecord\n\n  private excluding: boolean\n\n  private wildcards: WildcardOperatorNode[]\n\n  private path: Segments\n\n  constructor(tree: Node, record?: any) {\n    this.tree = tree\n    this.stack = []\n    this.excluding = false\n    this.wildcards = []\n    this.record = record\n  }\n\n  next(node: Node, pos: number) {\n    //  const isOverToken = pos > this.path.length\n    if (node.after) {\n      // if (isOverToken) {\n      //   return false\n      // }\n      return this.matchNode(node.after, pos)\n    }\n\n    if (isWildcardOperator(node) && !node.filter) {\n      if (this.excluding) {\n        return false\n      } else {\n        if (pos === 0 || node.optional) return true\n        return !!this.take(pos)\n      }\n    }\n\n    const isLastToken = pos === this.path.length - 1\n    if (isLastToken) {\n      return !!this.take(pos)\n    } else {\n      const wildcard = this.wildcards.pop()\n      if (wildcard && wildcard.after) {\n        return this.next(wildcard, pos)\n      }\n    }\n\n    return false\n  }\n\n  shot() {\n    if (this.record?.score >= 0) {\n      this.record.score++\n    }\n  }\n\n  take(pos: number) {\n    return String(this.path[pos] ?? '')\n  }\n\n  matchExcludeIdentifier(matched: boolean, node: Node, pos: number) {\n    const isLastToken = pos === this.path.length - 1\n    const isContainToken = pos < this.path.length\n    if (!node.after) {\n      this.excluding = false\n    }\n    if (matched) {\n      if (node.after) {\n        return this.next(node, pos)\n      }\n      if (isLastToken) {\n        return false\n      }\n    }\n    if (isLastToken) {\n      return true\n    }\n    return isContainToken\n  }\n\n  matchIdentifier(node: IdentifierNode, pos: number) {\n    const current = this.take(pos)\n    let matched = false\n    if (isExpandOperator(node.after)) {\n      if (current.indexOf(node.value) === 0) {\n        this.shot()\n        matched = true\n      }\n      if (this.excluding) {\n        return this.matchExcludeIdentifier(matched, node.after, pos)\n      } else {\n        return matched && this.next(node.after, pos)\n      }\n    } else if (current === node.value) {\n      this.shot()\n      matched = true\n    }\n    if (this.excluding) {\n      return this.matchExcludeIdentifier(matched, node, pos)\n    } else {\n      return matched && this.next(node, pos)\n    }\n  }\n\n  matchIgnoreExpression(node: IgnoreExpressionNode, pos: number) {\n    return isEqual(node.value, this.take(pos)) && this.next(node, pos)\n  }\n\n  matchDestructorExpression(node: DestructorExpressionNode, pos: number) {\n    return isEqual(node.source, this.take(pos)) && this.next(node, pos)\n  }\n\n  matchExpandOperator(node: ExpandOperatorNode, pos: number) {\n    return this.next(node, pos)\n  }\n\n  matchWildcardOperator(node: WildcardOperatorNode, pos: number) {\n    let matched = false\n    if (node.filter) {\n      this.stack.push(node)\n      matched = this.matchNode(node.filter, pos)\n      this.stack.pop()\n    } else {\n      matched = this.next(node, pos)\n    }\n    return matched\n  }\n\n  matchGroupExpression(node: GroupExpressionNode, pos: number) {\n    let excluding = false\n    if (node.isExclude) {\n      excluding = !this.excluding\n    }\n    return toArr(node.value)[excluding ? 'every' : 'some']((item) => {\n      this.wildcards = this.stack.slice() as WildcardOperatorNode[]\n      this.excluding = excluding\n      return this.matchNode(item, pos)\n    })\n  }\n\n  matchRangeExpression(node: RangeExpressionNode, pos: number) {\n    const current = Number(this.take(pos))\n    if (node.start) {\n      if (node.end) {\n        return (\n          current >= Number(node.start.value) &&\n          current <= Number(node.end.value)\n        )\n      } else {\n        return current >= Number(node.start.value)\n      }\n    } else {\n      if (node.end) {\n        return current <= Number(node.end.value)\n      } else {\n        this.wildcards = this.stack.slice() as WildcardOperatorNode[]\n        return this.next(node, pos)\n      }\n    }\n  }\n\n  matchNode(node: Node, pos = 0) {\n    if (isDotOperator(node)) {\n      return this.next(node, pos + 1)\n    } else if (isIdentifier(node)) {\n      return this.matchIdentifier(node, pos)\n    } else if (isIgnoreExpression(node)) {\n      return this.matchIgnoreExpression(node, pos)\n    } else if (isDestructorExpression(node)) {\n      return this.matchDestructorExpression(node, pos)\n    } else if (isExpandOperator(node)) {\n      return this.matchExpandOperator(node, pos)\n    } else if (isWildcardOperator(node)) {\n      return this.matchWildcardOperator(node, pos)\n    } else if (isGroupExpression(node)) {\n      return this.matchGroupExpression(node, pos)\n    } else if (isRangeExpression(node)) {\n      return this.matchRangeExpression(node, pos)\n    }\n    return false\n  }\n\n  match(path: Segments) {\n    this.path = path\n    return { matched: this.matchNode(this.tree), record: this.record }\n  }\n\n  static matchSegments(source: Segments, target: Segments, record?: any) {\n    if (source.length !== target.length) return { matched: false, record }\n    const match = (pos = 0) => {\n      const current = isSegmentEqual(source[pos], target[pos])\n      if (record?.score >= 0) {\n        record.score++\n      }\n      return current && (pos < source.length - 1 ? match(pos + 1) : true)\n    }\n    return { matched: match(), record }\n  }\n}\n"]}