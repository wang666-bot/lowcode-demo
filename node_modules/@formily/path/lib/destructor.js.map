{"version":3,"file":"destructor.js","sourceRoot":"","sources":["../src/destructor.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Segments,\n  Node,\n  DestructorRules,\n  isArrayPattern,\n  isObjectPattern,\n  isIdentifier,\n  isDestructorExpression,\n} from './types'\nimport { isNum } from './shared'\n\ntype Mutators = {\n  getIn: (segments: Segments, source: any) => any\n  setIn: (segments: Segments, source: any, value: any) => void\n  deleteIn?: (segments: Segments, source: any) => any\n  existIn?: (segments: Segments, source: any, start: number) => boolean\n}\n\nconst DestructorCache = new Map()\n\nconst isValid = (val: any) => val !== undefined && val !== null\n\nexport const getDestructor = (source: string) => {\n  return DestructorCache.get(source)\n}\n\nexport const setDestructor = (source: string, rules: DestructorRules) => {\n  DestructorCache.set(source, rules)\n}\n\nexport const parseDestructorRules = (node: Node): DestructorRules => {\n  const rules = []\n  if (isObjectPattern(node)) {\n    let index = 0\n    node.properties.forEach((child) => {\n      rules[index] = {\n        path: [],\n      }\n      rules[index].key = child.key.value\n      rules[index].path.push(child.key.value)\n      if (isIdentifier(child.value)) {\n        rules[index].key = child.value.value\n      }\n      const basePath = rules[index].path\n      const childRules = parseDestructorRules(child.value as Node)\n      let k = index\n      childRules.forEach((rule) => {\n        if (rules[k]) {\n          rules[k].key = rule.key\n          rules[k].path = basePath.concat(rule.path)\n        } else {\n          rules[k] = {\n            key: rule.key,\n            path: basePath.concat(rule.path),\n          }\n        }\n        k++\n      })\n      if (k > index) {\n        index = k\n      } else {\n        index++\n      }\n    })\n    return rules\n  } else if (isArrayPattern(node)) {\n    let index = 0\n    node.elements.forEach((child, key) => {\n      rules[index] = {\n        path: [],\n      }\n      rules[index].key = key\n      rules[index].path.push(key)\n      if (isIdentifier(child)) {\n        rules[index].key = child.value\n      }\n      const basePath = rules[index].path\n      const childRules = parseDestructorRules(child as Node)\n      let k = index\n      childRules.forEach((rule) => {\n        if (rules[k]) {\n          rules[k].key = rule.key\n          rules[k].path = basePath.concat(rule.path)\n        } else {\n          rules[k] = {\n            key: rule.key,\n            path: basePath.concat(rule.path),\n          }\n        }\n        k++\n      })\n      if (k > index) {\n        index = k\n      } else {\n        index++\n      }\n    })\n    return rules\n  }\n  if (isDestructorExpression(node)) {\n    return parseDestructorRules(node.value)\n  }\n  return rules\n}\n\nexport const setInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  value: any,\n  mutators: Mutators\n) => {\n  rules.forEach(({ key, path }) => {\n    mutators.setIn([key], source, mutators.getIn(path, value))\n  })\n}\n\nexport const getInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  mutators: Mutators\n) => {\n  let response = {}\n  if (rules.length) {\n    if (isNum(rules[0].path[0])) {\n      response = []\n    }\n  }\n  source = isValid(source) ? source : {}\n  rules.forEach(({ key, path }) => {\n    mutators.setIn(path, response, source[key])\n  })\n  return response\n}\n\nexport const deleteInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  mutators: Mutators\n) => {\n  rules.forEach(({ key }) => {\n    mutators.deleteIn([key], source)\n  })\n}\n\nexport const existInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  start: number,\n  mutators: Mutators\n) => {\n  return rules.every(({ key }) => {\n    return mutators.existIn([key], source, start)\n  })\n}\n"]}