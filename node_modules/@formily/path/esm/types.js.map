{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAmGA,MAAM,CAAC,IAAM,MAAM,GACjB,UAAI,IAAY;IAChB,OAAA,UAAC,GAAQ;QACP,OAAO,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,IAAI,CAAA;IACjC,CAAC;AAFD,CAEC,CAAA;AAEH,MAAM,CAAC,IAAM,YAAY,GAAG,MAAM,CAAiB,YAAY,CAAC,CAAA;AAEhE,MAAM,CAAC,IAAM,kBAAkB,GAC7B,MAAM,CAAuB,kBAAkB,CAAC,CAAA;AAElD,MAAM,CAAC,IAAM,aAAa,GAAG,MAAM,CAAkB,aAAa,CAAC,CAAA;AAEnE,MAAM,CAAC,IAAM,kBAAkB,GAC7B,MAAM,CAAuB,kBAAkB,CAAC,CAAA;AAElD,MAAM,CAAC,IAAM,gBAAgB,GAAG,MAAM,CAAqB,gBAAgB,CAAC,CAAA;AAE5E,MAAM,CAAC,IAAM,iBAAiB,GAAG,MAAM,CAAsB,iBAAiB,CAAC,CAAA;AAE/E,MAAM,CAAC,IAAM,iBAAiB,GAAG,MAAM,CAAsB,iBAAiB,CAAC,CAAA;AAE/E,MAAM,CAAC,IAAM,sBAAsB,GAAG,MAAM,CAC1C,sBAAsB,CACvB,CAAA;AAED,MAAM,CAAC,IAAM,eAAe,GAAG,MAAM,CAAoB,eAAe,CAAC,CAAA;AAEzE,MAAM,CAAC,IAAM,uBAAuB,GAAG,MAAM,CAC3C,uBAAuB,CACxB,CAAA;AAED,MAAM,CAAC,IAAM,cAAc,GAAG,MAAM,CAAmB,cAAc,CAAC,CAAA","sourcesContent":["import { Path } from './index'\ninterface INode {\n  type?: string\n  after?: Node\n  depth?: number\n}\n\nexport type Node =\n  | IdentifierNode\n  | WildcardOperatorNode\n  | GroupExpressionNode\n  | RangeExpressionNode\n  | DestructorExpressionNode\n  | ObjectPatternNode\n  | ArrayPatternNode\n  | DotOperatorNode\n  | ExpandOperatorNode\n  | INode\n\nexport type IdentifierNode = {\n  type: 'Identifier'\n  value: string\n  arrayIndex?: boolean\n} & INode\n\nexport type IgnoreExpressionNode = {\n  type: 'IgnoreExpression'\n  value: string\n} & INode\n\nexport type DotOperatorNode = {\n  type: 'DotOperator'\n} & INode\n\nexport type WildcardOperatorNode = {\n  type: 'WildcardOperator'\n  filter?: GroupExpressionNode | RangeExpressionNode\n  optional?: boolean\n} & INode\n\nexport type ExpandOperatorNode = {\n  type: 'ExpandOperator'\n} & INode\n\nexport type GroupExpressionNode = {\n  type: 'GroupExpression'\n  value: Node[]\n  isExclude?: boolean\n} & INode\n\nexport type RangeExpressionNode = {\n  type: 'RangeExpression'\n  start?: IdentifierNode\n  end?: IdentifierNode\n} & INode\n\nexport type DestructorExpressionNode = {\n  type: 'DestructorExpression'\n  value?: ObjectPatternNode | ArrayPatternNode\n  source?: string\n} & INode\n\nexport type ObjectPatternNode = {\n  type: 'ObjectPattern'\n  properties: ObjectPatternPropertyNode[]\n} & INode\n\nexport type ObjectPatternPropertyNode = {\n  type: 'ObjectPatternProperty'\n  key: IdentifierNode\n  value?: ObjectPatternNode[] | ArrayPatternNode[] | IdentifierNode\n} & INode\n\nexport type ArrayPatternNode = {\n  type: 'ArrayPattern'\n  elements: ObjectPatternNode[] | ArrayPatternNode[] | IdentifierNode[]\n} & INode\n\nexport type DestructorRule = {\n  key?: string | number\n  path?: Array<number | string>\n}\n\nexport type MatcherFunction = ((path: Segments) => boolean) & {\n  path: Path\n}\n\nexport type Pattern =\n  | string\n  | number\n  | Path\n  | Segments\n  | MatcherFunction\n  | RegExp\n\nexport type DestructorRules = DestructorRule[]\n\nexport type Segments = Array<string | number>\n\nexport const isType =\n  <T>(type: string) =>\n  (obj: any): obj is T => {\n    return obj && obj.type === type\n  }\n\nexport const isIdentifier = isType<IdentifierNode>('Identifier')\n\nexport const isIgnoreExpression =\n  isType<IgnoreExpressionNode>('IgnoreExpression')\n\nexport const isDotOperator = isType<DotOperatorNode>('DotOperator')\n\nexport const isWildcardOperator =\n  isType<WildcardOperatorNode>('WildcardOperator')\n\nexport const isExpandOperator = isType<ExpandOperatorNode>('ExpandOperator')\n\nexport const isGroupExpression = isType<GroupExpressionNode>('GroupExpression')\n\nexport const isRangeExpression = isType<RangeExpressionNode>('RangeExpression')\n\nexport const isDestructorExpression = isType<DestructorExpressionNode>(\n  'DestructorExpression'\n)\n\nexport const isObjectPattern = isType<ObjectPatternNode>('ObjectPattern')\n\nexport const isObjectPatternProperty = isType<ObjectPatternPropertyNode>(\n  'ObjectPatternProperty'\n)\n\nexport const isArrayPattern = isType<ArrayPatternNode>('ArrayPattern')\n\nexport type KeyType = string | number | symbol\n\nexport type IAccessors = {\n  get?: (source: any, key: KeyType) => any\n  set?: (source: any, key: KeyType, value: any) => any\n  has?: (source: any, key: KeyType) => boolean\n  delete?: (source: any, key: KeyType) => any\n}\n\nexport type IRegistry = {\n  accessors?: IAccessors\n}\n"]}