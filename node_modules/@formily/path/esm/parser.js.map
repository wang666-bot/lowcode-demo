{"version":3,"file":"parser.js","sourceRoot":"","sources":["../src/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tokenizer } from './tokenizer'\nimport {\n  Token,\n  nameTok,\n  colonTok,\n  dotTok,\n  starTok,\n  bangTok,\n  bracketLTok,\n  bracketRTok,\n  braceLTok,\n  braceRTok,\n  bracketDLTok,\n  parenLTok,\n  parenRTok,\n  commaTok,\n  expandTok,\n  eofTok,\n  dbStarTok,\n} from './tokens'\nimport { bracketArrayContext, destructorContext } from './contexts'\nimport {\n  IdentifierNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  RangeExpressionNode,\n  GroupExpressionNode,\n  DotOperatorNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ObjectPatternNode,\n  ObjectPatternPropertyNode,\n  ArrayPatternNode,\n  Node,\n  Segments,\n} from './types'\nimport { parseDestructorRules, setDestructor } from './destructor'\nimport { isNumberLike } from './shared'\nimport { Path } from './index'\n\nconst createTreeBySegments = (segments: Segments = [], afterNode?: Node) => {\n  const segLen = segments.length\n  const build = (start = 0) => {\n    const after = start < segLen - 1 ? build(start + 1) : afterNode\n    const dot = after && {\n      type: 'DotOperator',\n      after,\n    }\n    return {\n      type: 'Identifier',\n      value: segments[start],\n      after: dot,\n    }\n  }\n  return build()\n}\n\nconst calculate = (\n  a: string | number,\n  b: string | number,\n  operator: string\n) => {\n  if (isNumberLike(a) && isNumberLike(b)) {\n    if (operator === '+') return String(Number(a) + Number(b))\n    if (operator === '-') return String(Number(a) - Number(b))\n    if (operator === '*') return String(Number(a) * Number(b))\n    if (operator === '/') return String(Number(a) / Number(b))\n  } else {\n    if (operator === '+') return String(a) + String(b)\n    if (operator === '-') return 'NaN'\n    if (operator === '*') return 'NaN'\n    if (operator === '/') return 'NaN'\n  }\n  return String(Number(b))\n}\n\nexport class Parser extends Tokenizer {\n  public isMatchPattern = false\n\n  public isWildMatchPattern = false\n\n  public haveExcludePattern = false\n\n  public haveRelativePattern = false\n\n  public base: Path\n\n  public relative: string | number\n\n  public data: {\n    segments: Segments\n    tree?: Node\n  }\n\n  constructor(input: string, base?: Path) {\n    super(input)\n    this.base = base\n  }\n\n  parse() {\n    let node: Node\n    this.data = {\n      segments: [],\n    }\n    if (!this.eat(eofTok)) {\n      this.next()\n      node = this.parseAtom(this.state.type)\n    }\n    this.data.tree = node\n\n    return node\n  }\n\n  append(parent: Node, node: Node) {\n    if (parent && node) {\n      parent.after = node\n    }\n  }\n\n  parseAtom(type: Token): Node {\n    switch (type) {\n      case braceLTok:\n      case bracketLTok:\n        if (this.includesContext(destructorContext)) {\n          if (type === braceLTok) {\n            return this.parseObjectPattern()\n          } else {\n            return this.parseArrayPattern()\n          }\n        }\n        return this.parseDestructorExpression()\n      case nameTok:\n        return this.parseIdentifier()\n      case expandTok:\n        return this.parseExpandOperator()\n      case dbStarTok:\n      case starTok:\n        return this.parseWildcardOperator()\n      case bracketDLTok:\n        return this.parseIgnoreExpression()\n      case dotTok:\n        return this.parseDotOperator()\n    }\n  }\n\n  pushSegments(key: string | number) {\n    this.data.segments.push(key)\n  }\n\n  parseIdentifier() {\n    const node: IdentifierNode = {\n      type: 'Identifier',\n      value: this.state.value,\n    }\n    const hasNotInDestructor =\n      !this.includesContext(destructorContext) &&\n      !this.isMatchPattern &&\n      !this.isWildMatchPattern\n\n    this.next()\n    if (this.includesContext(bracketArrayContext)) {\n      if (this.state.type !== bracketRTok) {\n        throw this.unexpect()\n      } else {\n        this.state.context.pop()\n        this.next()\n      }\n    } else if (hasNotInDestructor) {\n      this.pushSegments(node.value)\n    }\n    if (this.state.type === bracketLTok) {\n      this.next()\n      if (this.state.type !== nameTok) {\n        throw this.unexpect()\n      }\n      this.state.context.push(bracketArrayContext)\n      let isNumberKey = false\n      if (/^\\d+$/.test(this.state.value)) {\n        isNumberKey = true\n      }\n      const value = this.state.value\n      this.pushSegments(isNumberKey ? Number(value) : value)\n      const after = this.parseAtom(this.state.type) as IdentifierNode\n      if (isNumberKey) {\n        after.arrayIndex = true\n      }\n      this.append(node, after)\n    } else {\n      this.append(node, this.parseAtom(this.state.type))\n    }\n\n    return node\n  }\n\n  parseExpandOperator() {\n    const node: ExpandOperatorNode = {\n      type: 'ExpandOperator',\n    }\n\n    this.isMatchPattern = true\n    this.isWildMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseWildcardOperator(): WildcardOperatorNode {\n    const node: WildcardOperatorNode = {\n      type: 'WildcardOperator',\n    }\n\n    if (this.state.type === dbStarTok) {\n      node.optional = true\n    }\n\n    this.isMatchPattern = true\n    this.isWildMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    if (this.state.type === parenLTok) {\n      node.filter = this.parseGroupExpression(node)\n    } else if (this.state.type === bracketLTok) {\n      node.filter = this.parseRangeExpression(node)\n    }\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseDestructorExpression(): DestructorExpressionNode {\n    const node: DestructorExpressionNode = {\n      type: 'DestructorExpression',\n    }\n    this.state.context.push(destructorContext)\n    const startPos = this.state.pos - 1\n    node.value =\n      this.state.type === braceLTok\n        ? this.parseObjectPattern()\n        : this.parseArrayPattern()\n    const endPos = this.state.pos\n    this.state.context.pop()\n    node.source = this.input\n      .substring(startPos, endPos)\n      .replace(\n        /\\[\\s*([\\+\\-\\*\\/])?\\s*([^,\\]\\s]*)\\s*\\]/,\n        (match, operator, target) => {\n          if (this.relative !== undefined) {\n            if (operator) {\n              if (target) {\n                return calculate(this.relative, target, operator)\n              } else {\n                return calculate(this.relative, 1, operator)\n              }\n            } else {\n              if (target) {\n                return calculate(this.relative, target, '+')\n              } else {\n                return String(this.relative)\n              }\n            }\n          }\n          return match\n        }\n      )\n      .replace(/\\s*\\.\\s*/g, '')\n      .replace(/\\s*/g, '')\n    if (this.relative === undefined) {\n      setDestructor(node.source, parseDestructorRules(node))\n    }\n    this.relative = undefined\n    this.pushSegments(node.source)\n    this.next()\n    this.append(node, this.parseAtom(this.state.type))\n    return node\n  }\n\n  parseArrayPattern(): ArrayPatternNode {\n    const node: ArrayPatternNode = {\n      type: 'ArrayPattern',\n      elements: [],\n    }\n    this.next()\n    node.elements = this.parseArrayPatternElements()\n    return node\n  }\n\n  parseArrayPatternElements() {\n    const nodes = []\n    while (this.state.type !== bracketRTok && this.state.type !== eofTok) {\n      nodes.push(this.parseAtom(this.state.type))\n      if (this.state.type === bracketRTok) {\n        if (this.includesContext(destructorContext)) {\n          this.next()\n        }\n        return nodes\n      }\n      this.next()\n    }\n    return nodes\n  }\n\n  parseObjectPattern(): ObjectPatternNode {\n    const node: ObjectPatternNode = {\n      type: 'ObjectPattern',\n      properties: [],\n    }\n    this.next()\n    node.properties = this.parseObjectProperties()\n    return node\n  }\n\n  parseObjectProperties(): ObjectPatternPropertyNode[] {\n    const nodes = []\n    while (this.state.type !== braceRTok && this.state.type !== eofTok) {\n      const node: ObjectPatternPropertyNode = {\n        type: 'ObjectPatternProperty',\n        key: this.parseAtom(this.state.type) as IdentifierNode,\n      }\n      nodes.push(node)\n      if (this.state.type === colonTok) {\n        this.next()\n        node.value = this.parseAtom(this.state.type) as\n          | IdentifierNode\n          | ObjectPatternNode[]\n          | ArrayPatternNode[]\n      }\n      if (this.state.type === braceRTok) {\n        if (this.includesContext(destructorContext)) {\n          this.next()\n        }\n        return nodes\n      }\n      this.next()\n    }\n    return nodes\n  }\n\n  parseDotOperator(): Node {\n    const node: DotOperatorNode = {\n      type: 'DotOperator',\n    }\n\n    const prevToken = this.type_\n    if (!prevToken && this.base) {\n      if (this.base.isMatchPattern) {\n        throw new Error('Base path must be an absolute path.')\n      }\n      this.data.segments = this.base.toArr()\n      while (this.state.type === dotTok) {\n        this.relative = this.data.segments.pop()\n        this.haveRelativePattern = true\n        this.next()\n      }\n      return createTreeBySegments(\n        this.data.segments.slice(),\n        this.parseAtom(this.state.type)\n      )\n    } else {\n      this.next()\n    }\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseIgnoreExpression() {\n    this.next()\n\n    const value = String(this.state.value).replace(/\\s*/g, '')\n\n    const node: IgnoreExpressionNode = {\n      type: 'IgnoreExpression',\n      value: value,\n    }\n\n    this.pushSegments(value)\n\n    this.next()\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    this.next()\n\n    return node\n  }\n\n  parseGroupExpression(parent: Node) {\n    const node: GroupExpressionNode = {\n      type: 'GroupExpression',\n      value: [],\n    }\n\n    this.isMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    loop: while (true) {\n      switch (this.state.type) {\n        case commaTok:\n          this.next()\n          break\n        case bangTok:\n          node.isExclude = true\n          this.haveExcludePattern = true\n          this.next()\n          break\n        case eofTok:\n          break loop\n        case parenRTok:\n          break loop\n        default:\n          node.value.push(this.parseAtom(this.state.type))\n      }\n    }\n\n    this.next()\n\n    this.append(parent, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseRangeExpression(parent: Node) {\n    const node: RangeExpressionNode = {\n      type: 'RangeExpression',\n    }\n\n    this.next()\n\n    this.isMatchPattern = true\n    this.data.segments = []\n\n    let start = false,\n      hasColon = false\n\n    loop: while (true) {\n      switch (this.state.type) {\n        case colonTok:\n          hasColon = true\n          start = true\n          this.next()\n          break\n        case bracketRTok:\n          if (!hasColon && !node.end) {\n            node.end = node.start\n          }\n          break loop\n        case commaTok:\n          // never reach\n          throw this.unexpect()\n        case eofTok:\n          // never reach\n          break loop\n        default:\n          if (!start) {\n            node.start = this.parseAtom(this.state.type) as IdentifierNode\n          } else {\n            node.end = this.parseAtom(this.state.type) as IdentifierNode\n          }\n      }\n    }\n\n    this.next()\n\n    this.append(parent, this.parseAtom(this.state.type))\n\n    return node\n  }\n}\n"]}