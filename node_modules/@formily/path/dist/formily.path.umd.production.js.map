{"version":3,"file":"formily.path.umd.production.js","sources":["../src/contexts.ts","../src/tokens.ts","../src/tokenizer.ts","../src/types.ts","../src/shared.ts","../src/destructor.ts","../src/parser.ts","../src/matcher.ts","../src/index.ts"],"sourcesContent":["export type Context = {\n  flag: string\n  [key: string]: any\n}\n\nconst ContextType = (flag: string, props?: any): Context => {\n  return {\n    flag,\n    ...props,\n  }\n}\n\nexport const bracketContext = ContextType('[]')\n\nexport const bracketArrayContext = ContextType('[\\\\d]')\n\nexport const bracketDContext = ContextType('[[]]')\n\nexport const parenContext = ContextType('()')\n\nexport const braceContext = ContextType('{}')\n\nexport const destructorContext = ContextType('{x}')\n","import {\n  bracketContext,\n  parenContext,\n  bracketArrayContext,\n  bracketDContext,\n  braceContext,\n  destructorContext,\n} from './contexts'\n\ninterface ITokenProps {\n  expectNext?: (next?: Token) => boolean\n  expectPrev?: (prev?: Token) => boolean\n  updateContext?: (prev?: Token) => void\n}\n\nexport type Token = ITokenProps & {\n  flag: string\n}\n\nconst TokenType = (flag: string, props?: ITokenProps): Token => {\n  return {\n    flag,\n    ...props,\n  }\n}\n\nexport const nameTok = TokenType('name', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === nameTok ||\n        next === commaTok ||\n        next === bracketRTok ||\n        next === braceRTok ||\n        next === colonTok\n      )\n    }\n    return (\n      next === dotTok ||\n      next === commaTok ||\n      next === eofTok ||\n      next === bracketRTok ||\n      next === parenRTok ||\n      next === colonTok ||\n      next === expandTok ||\n      next === bracketLTok\n    )\n  },\n})\nexport const starTok = TokenType('*', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === parenLTok ||\n      next === bracketLTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\nexport const dbStarTok = TokenType('**', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === bracketLTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\nexport const dotTok = TokenType('.', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === starTok ||\n      next === dbStarTok ||\n      next === bracketLTok ||\n      next === braceLTok ||\n      next === eofTok\n    )\n  },\n  expectPrev(prev) {\n    return (\n      prev === dotTok ||\n      prev === nameTok ||\n      prev === bracketDRTok ||\n      prev === starTok ||\n      prev === parenRTok ||\n      prev === bracketRTok ||\n      prev === expandTok ||\n      prev === braceRTok\n    )\n  },\n})\nexport const bangTok = TokenType('!', {\n  expectNext(next) {\n    return next === nameTok || next === bracketDLTok\n  },\n})\nexport const colonTok = TokenType(':', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return next === nameTok || next === braceLTok || next === bracketLTok\n    }\n    return next === nameTok || next === bracketDLTok || next === bracketRTok\n  },\n})\n\nexport const braceLTok = TokenType('{', {\n  expectNext(next) {\n    return next === nameTok\n  },\n  expectPrev(prev) {\n    if (this.includesContext(destructorContext)) {\n      return prev === colonTok || prev === commaTok || prev === bracketLTok\n    }\n    return prev === dotTok || prev === colonTok || prev === parenLTok\n  },\n  updateContext() {\n    this.state.context.push(braceContext)\n  },\n})\n\nexport const braceRTok = TokenType('}', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === commaTok ||\n        next === braceRTok ||\n        next === eofTok ||\n        next === bracketRTok\n      )\n    }\n    return next === dotTok || next === eofTok || next === commaTok\n  },\n  expectPrev(prev) {\n    return prev === nameTok || prev === braceRTok || prev === bracketRTok\n  },\n  updateContext() {\n    this.state.context.pop(braceContext)\n  },\n})\n\nexport const bracketLTok = TokenType('[', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === nameTok ||\n        next === bracketLTok ||\n        next === braceLTok ||\n        next === bracketRTok\n      )\n    }\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === colonTok ||\n      next === bracketLTok ||\n      next === ignoreTok ||\n      next === bracketRTok\n    )\n  },\n  expectPrev(prev) {\n    if (this.includesContext(destructorContext)) {\n      return prev === colonTok || prev === commaTok || prev === bracketLTok\n    }\n    return (\n      prev === starTok ||\n      prev === bracketLTok ||\n      prev === dotTok ||\n      prev === nameTok ||\n      prev === parenLTok ||\n      // never reach\n      prev == commaTok\n    )\n  },\n  updateContext() {\n    this.state.context.push(bracketContext)\n  },\n})\n\nexport const bracketRTok = TokenType(']', {\n  expectNext(next) {\n    if (this.includesContext(destructorContext)) {\n      return (\n        next === commaTok ||\n        next === braceRTok ||\n        next === bracketRTok ||\n        next === eofTok\n      )\n    }\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok ||\n      next === bracketRTok\n    )\n  },\n  updateContext() {\n    if (this.includesContext(bracketArrayContext)) return\n    if (!this.includesContext(bracketContext)) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const bracketDLTok = TokenType('[[', {\n  updateContext() {\n    this.state.context.push(bracketDContext)\n  },\n})\n\nexport const bracketDRTok = TokenType(']]', {\n  updateContext() {\n    if (this.curContext() !== bracketDContext) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const parenLTok = TokenType('(', {\n  expectNext(next) {\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === braceLTok ||\n      next === bangTok ||\n      next === bracketLTok\n    )\n  },\n  expectPrev(prev) {\n    return prev === starTok\n  },\n  updateContext() {\n    this.state.context.push(parenContext)\n  },\n})\nexport const parenRTok = TokenType(')', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n  updateContext() {\n    if (this.curContext() !== parenContext) throw this.unexpect()\n    this.state.context.pop()\n  },\n})\n\nexport const commaTok = TokenType(',', {\n  expectNext(next) {\n    return (\n      next === nameTok ||\n      next === bracketDLTok ||\n      next === bracketLTok ||\n      next === braceLTok\n    )\n  },\n})\nexport const ignoreTok = TokenType('ignore', {\n  expectNext(next) {\n    return next === bracketDRTok\n  },\n  expectPrev(prev) {\n    return prev == bracketDLTok\n  },\n})\n\nexport const expandTok = TokenType('expandTok', {\n  expectNext(next) {\n    return (\n      next === dotTok ||\n      next === eofTok ||\n      next === commaTok ||\n      next === parenRTok\n    )\n  },\n})\n\nexport const eofTok = TokenType('eof')\n","import {\n  Token,\n  nameTok,\n  colonTok,\n  dotTok,\n  starTok,\n  dbStarTok,\n  bangTok,\n  bracketLTok,\n  bracketRTok,\n  bracketDRTok,\n  expandTok,\n  parenLTok,\n  parenRTok,\n  commaTok,\n  eofTok,\n  ignoreTok,\n  braceLTok,\n  braceRTok,\n  bracketDLTok,\n} from './tokens'\nimport { bracketDContext, Context } from './contexts'\n\nconst nonASCIIWhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nconst fullCharCodeAtPos = (input: string, pos: number) => {\n  if (String.fromCharCode) return input.codePointAt(pos)\n  const code = input.charCodeAt(pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n\n  const next = input.charCodeAt(pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\nconst isRewordCode = (code: number) =>\n  code === 42 ||\n  code === 46 ||\n  code === 33 ||\n  code === 91 ||\n  code === 93 ||\n  code === 40 ||\n  code === 41 ||\n  code === 44 ||\n  code === 58 ||\n  code === 126 ||\n  code === 123 ||\n  code === 125\n\nconst getError = (message?: string, props?: any) => {\n  const err = new Error(message)\n  Object.assign(err, props)\n  return err\n}\n\nconst slice = (string: string, start: number, end: number) => {\n  let str = ''\n  for (let i = start; i < end; i++) {\n    const ch = string.charAt(i)\n    if (ch !== '\\\\') {\n      str += ch\n    }\n  }\n  return str\n}\n\nexport class Tokenizer {\n  public input: string\n  public state: {\n    context: Context[]\n    type: Token\n    pos: number\n    value?: any\n  }\n  public type_: Token\n  constructor(input: string) {\n    this.input = input\n    this.state = {\n      context: [],\n      type: null,\n      pos: 0,\n    }\n    this.type_ = null\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1]\n  }\n\n  includesContext(context: Context) {\n    for (let len = this.state.context.length - 1; len >= 0; len--) {\n      if (this.state.context[len] === context) {\n        return true\n      }\n    }\n    return false\n  }\n\n  unexpect(type?: Token) {\n    type = type || this.state.type\n    return getError(\n      `Unexpect token \"${type.flag}\" in ${this.state.pos} char.`,\n      {\n        pos: this.state.pos,\n      }\n    )\n  }\n\n  expectNext(type?: Token, next?: Token) {\n    if (type && type.expectNext) {\n      if (next && !type.expectNext.call(this, next)) {\n        throw getError(\n          `Unexpect token \"${next.flag}\" token should not be behind \"${type.flag}\" token.(${this.state.pos}th char)`,\n          {\n            pos: this.state.pos,\n          }\n        )\n      }\n    }\n  }\n\n  expectPrev(type?: Token, prev?: Token) {\n    if (type && type.expectPrev) {\n      if (prev && !type.expectPrev.call(this, prev)) {\n        throw getError(\n          `Unexpect token \"${type.flag}\" should not be behind \"${prev.flag}\"(${this.state.pos}th char).`,\n          {\n            pos: this.state.pos,\n          }\n        )\n      }\n    }\n  }\n\n  match(type?: Token) {\n    return this.state.type === type\n  }\n\n  skipSpace() {\n    if (this.curContext() === bracketDContext) return\n    loop: while (this.state.pos < this.input.length) {\n      const ch = this.input.charCodeAt(this.state.pos)\n      switch (ch) {\n        case 32:\n        case 160:\n          ++this.state.pos\n          break\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos\n          break\n        default:\n          if (\n            (ch > 8 && ch < 14) ||\n            (ch >= 5760 && nonASCIIWhitespace.test(String.fromCharCode(ch)))\n          ) {\n            ++this.state.pos\n          } else {\n            break loop\n          }\n      }\n    }\n  }\n\n  next() {\n    this.type_ = this.state.type\n    if (this.input.length <= this.state.pos) {\n      return this.finishToken(eofTok)\n    }\n    this.skipSpace()\n    this.readToken(\n      this.getCode(),\n      this.state.pos > 0 ? this.getCode(this.state.pos - 1) : -Infinity\n    )\n  }\n\n  getCode(pos = this.state.pos) {\n    return fullCharCodeAtPos(this.input, pos)\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next()\n      return true\n    } else {\n      return false\n    }\n  }\n\n  readKeyWord() {\n    let startPos = this.state.pos,\n      string = ''\n    while (true) {\n      const code = this.getCode()\n      const prevCode = this.getCode(this.state.pos - 1)\n      if (this.input.length === this.state.pos) {\n        string = slice(this.input, startPos, this.state.pos + 1)\n        break\n      }\n      if (!isRewordCode(code) || prevCode === 92) {\n        if (\n          code === 32 ||\n          code === 160 ||\n          code === 10 ||\n          code === 8232 ||\n          code === 8233\n        ) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        if (code === 13 && this.input.charCodeAt(this.state.pos + 1) === 10) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        if (\n          (code > 8 && code < 14) ||\n          (code >= 5760 && nonASCIIWhitespace.test(String.fromCharCode(code)))\n        ) {\n          string = slice(this.input, startPos, this.state.pos)\n          break\n        }\n        this.state.pos++\n      } else {\n        string = slice(this.input, startPos, this.state.pos)\n        break\n      }\n    }\n\n    this.finishToken(nameTok, string)\n  }\n\n  readIgnoreString() {\n    let startPos = this.state.pos,\n      prevCode,\n      string = ''\n    while (true) {\n      const code = this.getCode()\n      if (this.state.pos >= this.input.length) break\n      if ((code === 91 || code === 93) && prevCode === 92) {\n        this.state.pos++\n        prevCode = ''\n      } else if (code == 93 && prevCode === 93) {\n        string = this.input\n          .slice(startPos, this.state.pos - 1)\n          .replace(/\\\\([\\[\\]])/g, '$1')\n        this.state.pos++\n        break\n      } else {\n        this.state.pos++\n        prevCode = code\n      }\n    }\n\n    this.finishToken(ignoreTok, string)\n    this.finishToken(bracketDRTok)\n  }\n\n  finishToken(type: Token, value?: any) {\n    const preType = this.state.type\n    this.state.type = type\n    if (value !== undefined) this.state.value = value\n    this.expectNext(preType, type)\n    this.expectPrev(type, preType)\n    if (type.updateContext) {\n      type.updateContext.call(this, preType)\n    }\n  }\n\n  readToken(code: number, prevCode: number) {\n    if (prevCode === 92) {\n      return this.readKeyWord()\n    }\n    if (this.input.length <= this.state.pos) {\n      this.finishToken(eofTok)\n    } else if (this.curContext() === bracketDContext) {\n      this.readIgnoreString()\n    } else if (code === 123) {\n      this.state.pos++\n      this.finishToken(braceLTok)\n    } else if (code === 125) {\n      this.state.pos++\n      this.finishToken(braceRTok)\n    } else if (code === 42) {\n      this.state.pos++\n      if (this.getCode() === 42) {\n        this.state.pos++\n        return this.finishToken(dbStarTok)\n      }\n      this.finishToken(starTok)\n    } else if (code === 33) {\n      this.state.pos++\n      this.finishToken(bangTok)\n    } else if (code === 46) {\n      this.state.pos++\n      this.finishToken(dotTok)\n    } else if (code === 91) {\n      this.state.pos++\n      if (this.getCode() === 91) {\n        this.state.pos++\n        return this.finishToken(bracketDLTok)\n      }\n      this.finishToken(bracketLTok)\n    } else if (code === 126) {\n      this.state.pos++\n      this.finishToken(expandTok)\n    } else if (code === 93) {\n      this.state.pos++\n      this.finishToken(bracketRTok)\n    } else if (code === 40) {\n      this.state.pos++\n      this.finishToken(parenLTok)\n    } else if (code === 41) {\n      this.state.pos++\n      this.finishToken(parenRTok)\n    } else if (code === 44) {\n      this.state.pos++\n      this.finishToken(commaTok)\n    } else if (code === 58) {\n      this.state.pos++\n      this.finishToken(colonTok)\n    } else {\n      this.readKeyWord()\n    }\n  }\n}\n","import { Path } from './index'\ninterface INode {\n  type?: string\n  after?: Node\n  depth?: number\n}\n\nexport type Node =\n  | IdentifierNode\n  | WildcardOperatorNode\n  | GroupExpressionNode\n  | RangeExpressionNode\n  | DestructorExpressionNode\n  | ObjectPatternNode\n  | ArrayPatternNode\n  | DotOperatorNode\n  | ExpandOperatorNode\n  | INode\n\nexport type IdentifierNode = {\n  type: 'Identifier'\n  value: string\n  arrayIndex?: boolean\n} & INode\n\nexport type IgnoreExpressionNode = {\n  type: 'IgnoreExpression'\n  value: string\n} & INode\n\nexport type DotOperatorNode = {\n  type: 'DotOperator'\n} & INode\n\nexport type WildcardOperatorNode = {\n  type: 'WildcardOperator'\n  filter?: GroupExpressionNode | RangeExpressionNode\n  optional?: boolean\n} & INode\n\nexport type ExpandOperatorNode = {\n  type: 'ExpandOperator'\n} & INode\n\nexport type GroupExpressionNode = {\n  type: 'GroupExpression'\n  value: Node[]\n  isExclude?: boolean\n} & INode\n\nexport type RangeExpressionNode = {\n  type: 'RangeExpression'\n  start?: IdentifierNode\n  end?: IdentifierNode\n} & INode\n\nexport type DestructorExpressionNode = {\n  type: 'DestructorExpression'\n  value?: ObjectPatternNode | ArrayPatternNode\n  source?: string\n} & INode\n\nexport type ObjectPatternNode = {\n  type: 'ObjectPattern'\n  properties: ObjectPatternPropertyNode[]\n} & INode\n\nexport type ObjectPatternPropertyNode = {\n  type: 'ObjectPatternProperty'\n  key: IdentifierNode\n  value?: ObjectPatternNode[] | ArrayPatternNode[] | IdentifierNode\n} & INode\n\nexport type ArrayPatternNode = {\n  type: 'ArrayPattern'\n  elements: ObjectPatternNode[] | ArrayPatternNode[] | IdentifierNode[]\n} & INode\n\nexport type DestructorRule = {\n  key?: string | number\n  path?: Array<number | string>\n}\n\nexport type MatcherFunction = ((path: Segments) => boolean) & {\n  path: Path\n}\n\nexport type Pattern =\n  | string\n  | number\n  | Path\n  | Segments\n  | MatcherFunction\n  | RegExp\n\nexport type DestructorRules = DestructorRule[]\n\nexport type Segments = Array<string | number>\n\nexport const isType =\n  <T>(type: string) =>\n  (obj: any): obj is T => {\n    return obj && obj.type === type\n  }\n\nexport const isIdentifier = isType<IdentifierNode>('Identifier')\n\nexport const isIgnoreExpression =\n  isType<IgnoreExpressionNode>('IgnoreExpression')\n\nexport const isDotOperator = isType<DotOperatorNode>('DotOperator')\n\nexport const isWildcardOperator =\n  isType<WildcardOperatorNode>('WildcardOperator')\n\nexport const isExpandOperator = isType<ExpandOperatorNode>('ExpandOperator')\n\nexport const isGroupExpression = isType<GroupExpressionNode>('GroupExpression')\n\nexport const isRangeExpression = isType<RangeExpressionNode>('RangeExpression')\n\nexport const isDestructorExpression = isType<DestructorExpressionNode>(\n  'DestructorExpression'\n)\n\nexport const isObjectPattern = isType<ObjectPatternNode>('ObjectPattern')\n\nexport const isObjectPatternProperty = isType<ObjectPatternPropertyNode>(\n  'ObjectPatternProperty'\n)\n\nexport const isArrayPattern = isType<ArrayPatternNode>('ArrayPattern')\n\nexport type KeyType = string | number | symbol\n\nexport type IAccessors = {\n  get?: (source: any, key: KeyType) => any\n  set?: (source: any, key: KeyType, value: any) => any\n  has?: (source: any, key: KeyType) => boolean\n  delete?: (source: any, key: KeyType) => any\n}\n\nexport type IRegistry = {\n  accessors?: IAccessors\n}\n","const toString = Object.prototype.toString\nconst isType =\n  <T>(type: string) =>\n  (obj: unknown): obj is T =>\n    toString.call(obj) === `[object ${type}]`\nexport const isFn = isType<(...args: any[]) => any>('Function')\nexport const isArr = Array.isArray || isType<unknown[]>('Array')\nexport const isPlainObj = isType<object>('Object')\nexport const isStr = isType<string>('String')\nexport const isBool = isType<boolean>('Boolean')\nexport const isNum = isType<number>('Number')\nexport const isObj = (val: unknown): val is object => typeof val === 'object'\nexport const isRegExp = isType<RegExp>('RegExp')\nexport const isNumberLike = (t: any) => {\n  return isNum(t) || /^(\\d+)(\\.\\d+)?$/.test(t)\n}\nconst isArray = isArr\nconst keyList = Object.keys\nconst hasProp = Object.prototype.hasOwnProperty\n\nexport const toArr = <T>(val: T | T[]): T[] =>\n  Array.isArray(val) ? val : val !== undefined ? [val] : []\nexport const isAssignable = (val: any) => {\n  return typeof val === 'object' || typeof val === 'function'\n}\nexport const isEqual = (a: any, b: any) => {\n  if (a === b) {\n    return true\n  }\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    const arrA = isArray(a)\n    const arrB = isArray(b)\n    let i\n    let length\n    let key\n\n    if (arrA && arrB) {\n      length = a.length\n      if (length !== b.length) {\n        return false\n      }\n      for (i = length; i-- !== 0; ) {\n        if (!isEqual(a[i], b[i])) {\n          return false\n        }\n      }\n      return true\n    }\n\n    if (arrA !== arrB) {\n      return false\n    }\n\n    const keys = keyList(a)\n    length = keys.length\n\n    if (length !== keyList(b).length) {\n      return false\n    }\n\n    for (i = length; i-- !== 0; ) {\n      if (!hasProp.call(b, keys[i])) {\n        return false\n      }\n    }\n    for (i = length; i-- !== 0; ) {\n      key = keys[i]\n      if (!isEqual(a[key], b[key])) {\n        return false\n      }\n    }\n\n    return true\n  }\n  return a !== a && b !== b\n}\nexport const isSegmentEqual = (a: any, b: any) => {\n  a = typeof a === 'symbol' ? a : `${a}`\n  b = typeof b === 'symbol' ? b : `${b}`\n  return a === b\n}\n","import {\n  Segments,\n  Node,\n  DestructorRules,\n  isArrayPattern,\n  isObjectPattern,\n  isIdentifier,\n  isDestructorExpression,\n} from './types'\nimport { isNum } from './shared'\n\ntype Mutators = {\n  getIn: (segments: Segments, source: any) => any\n  setIn: (segments: Segments, source: any, value: any) => void\n  deleteIn?: (segments: Segments, source: any) => any\n  existIn?: (segments: Segments, source: any, start: number) => boolean\n}\n\nconst DestructorCache = new Map()\n\nconst isValid = (val: any) => val !== undefined && val !== null\n\nexport const getDestructor = (source: string) => {\n  return DestructorCache.get(source)\n}\n\nexport const setDestructor = (source: string, rules: DestructorRules) => {\n  DestructorCache.set(source, rules)\n}\n\nexport const parseDestructorRules = (node: Node): DestructorRules => {\n  const rules = []\n  if (isObjectPattern(node)) {\n    let index = 0\n    node.properties.forEach((child) => {\n      rules[index] = {\n        path: [],\n      }\n      rules[index].key = child.key.value\n      rules[index].path.push(child.key.value)\n      if (isIdentifier(child.value)) {\n        rules[index].key = child.value.value\n      }\n      const basePath = rules[index].path\n      const childRules = parseDestructorRules(child.value as Node)\n      let k = index\n      childRules.forEach((rule) => {\n        if (rules[k]) {\n          rules[k].key = rule.key\n          rules[k].path = basePath.concat(rule.path)\n        } else {\n          rules[k] = {\n            key: rule.key,\n            path: basePath.concat(rule.path),\n          }\n        }\n        k++\n      })\n      if (k > index) {\n        index = k\n      } else {\n        index++\n      }\n    })\n    return rules\n  } else if (isArrayPattern(node)) {\n    let index = 0\n    node.elements.forEach((child, key) => {\n      rules[index] = {\n        path: [],\n      }\n      rules[index].key = key\n      rules[index].path.push(key)\n      if (isIdentifier(child)) {\n        rules[index].key = child.value\n      }\n      const basePath = rules[index].path\n      const childRules = parseDestructorRules(child as Node)\n      let k = index\n      childRules.forEach((rule) => {\n        if (rules[k]) {\n          rules[k].key = rule.key\n          rules[k].path = basePath.concat(rule.path)\n        } else {\n          rules[k] = {\n            key: rule.key,\n            path: basePath.concat(rule.path),\n          }\n        }\n        k++\n      })\n      if (k > index) {\n        index = k\n      } else {\n        index++\n      }\n    })\n    return rules\n  }\n  if (isDestructorExpression(node)) {\n    return parseDestructorRules(node.value)\n  }\n  return rules\n}\n\nexport const setInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  value: any,\n  mutators: Mutators\n) => {\n  rules.forEach(({ key, path }) => {\n    mutators.setIn([key], source, mutators.getIn(path, value))\n  })\n}\n\nexport const getInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  mutators: Mutators\n) => {\n  let response = {}\n  if (rules.length) {\n    if (isNum(rules[0].path[0])) {\n      response = []\n    }\n  }\n  source = isValid(source) ? source : {}\n  rules.forEach(({ key, path }) => {\n    mutators.setIn(path, response, source[key])\n  })\n  return response\n}\n\nexport const deleteInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  mutators: Mutators\n) => {\n  rules.forEach(({ key }) => {\n    mutators.deleteIn([key], source)\n  })\n}\n\nexport const existInByDestructor = (\n  source: any,\n  rules: DestructorRules,\n  start: number,\n  mutators: Mutators\n) => {\n  return rules.every(({ key }) => {\n    return mutators.existIn([key], source, start)\n  })\n}\n","import { Tokenizer } from './tokenizer'\nimport {\n  Token,\n  nameTok,\n  colonTok,\n  dotTok,\n  starTok,\n  bangTok,\n  bracketLTok,\n  bracketRTok,\n  braceLTok,\n  braceRTok,\n  bracketDLTok,\n  parenLTok,\n  parenRTok,\n  commaTok,\n  expandTok,\n  eofTok,\n  dbStarTok,\n} from './tokens'\nimport { bracketArrayContext, destructorContext } from './contexts'\nimport {\n  IdentifierNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  RangeExpressionNode,\n  GroupExpressionNode,\n  DotOperatorNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ObjectPatternNode,\n  ObjectPatternPropertyNode,\n  ArrayPatternNode,\n  Node,\n  Segments,\n} from './types'\nimport { parseDestructorRules, setDestructor } from './destructor'\nimport { isNumberLike } from './shared'\nimport { Path } from './index'\n\nconst createTreeBySegments = (segments: Segments = [], afterNode?: Node) => {\n  const segLen = segments.length\n  const build = (start = 0) => {\n    const after = start < segLen - 1 ? build(start + 1) : afterNode\n    const dot = after && {\n      type: 'DotOperator',\n      after,\n    }\n    return {\n      type: 'Identifier',\n      value: segments[start],\n      after: dot,\n    }\n  }\n  return build()\n}\n\nconst calculate = (\n  a: string | number,\n  b: string | number,\n  operator: string\n) => {\n  if (isNumberLike(a) && isNumberLike(b)) {\n    if (operator === '+') return String(Number(a) + Number(b))\n    if (operator === '-') return String(Number(a) - Number(b))\n    if (operator === '*') return String(Number(a) * Number(b))\n    if (operator === '/') return String(Number(a) / Number(b))\n  } else {\n    if (operator === '+') return String(a) + String(b)\n    if (operator === '-') return 'NaN'\n    if (operator === '*') return 'NaN'\n    if (operator === '/') return 'NaN'\n  }\n  return String(Number(b))\n}\n\nexport class Parser extends Tokenizer {\n  public isMatchPattern = false\n\n  public isWildMatchPattern = false\n\n  public haveExcludePattern = false\n\n  public haveRelativePattern = false\n\n  public base: Path\n\n  public relative: string | number\n\n  public data: {\n    segments: Segments\n    tree?: Node\n  }\n\n  constructor(input: string, base?: Path) {\n    super(input)\n    this.base = base\n  }\n\n  parse() {\n    let node: Node\n    this.data = {\n      segments: [],\n    }\n    if (!this.eat(eofTok)) {\n      this.next()\n      node = this.parseAtom(this.state.type)\n    }\n    this.data.tree = node\n\n    return node\n  }\n\n  append(parent: Node, node: Node) {\n    if (parent && node) {\n      parent.after = node\n    }\n  }\n\n  parseAtom(type: Token): Node {\n    switch (type) {\n      case braceLTok:\n      case bracketLTok:\n        if (this.includesContext(destructorContext)) {\n          if (type === braceLTok) {\n            return this.parseObjectPattern()\n          } else {\n            return this.parseArrayPattern()\n          }\n        }\n        return this.parseDestructorExpression()\n      case nameTok:\n        return this.parseIdentifier()\n      case expandTok:\n        return this.parseExpandOperator()\n      case dbStarTok:\n      case starTok:\n        return this.parseWildcardOperator()\n      case bracketDLTok:\n        return this.parseIgnoreExpression()\n      case dotTok:\n        return this.parseDotOperator()\n    }\n  }\n\n  pushSegments(key: string | number) {\n    this.data.segments.push(key)\n  }\n\n  parseIdentifier() {\n    const node: IdentifierNode = {\n      type: 'Identifier',\n      value: this.state.value,\n    }\n    const hasNotInDestructor =\n      !this.includesContext(destructorContext) &&\n      !this.isMatchPattern &&\n      !this.isWildMatchPattern\n\n    this.next()\n    if (this.includesContext(bracketArrayContext)) {\n      if (this.state.type !== bracketRTok) {\n        throw this.unexpect()\n      } else {\n        this.state.context.pop()\n        this.next()\n      }\n    } else if (hasNotInDestructor) {\n      this.pushSegments(node.value)\n    }\n    if (this.state.type === bracketLTok) {\n      this.next()\n      if (this.state.type !== nameTok) {\n        throw this.unexpect()\n      }\n      this.state.context.push(bracketArrayContext)\n      let isNumberKey = false\n      if (/^\\d+$/.test(this.state.value)) {\n        isNumberKey = true\n      }\n      const value = this.state.value\n      this.pushSegments(isNumberKey ? Number(value) : value)\n      const after = this.parseAtom(this.state.type) as IdentifierNode\n      if (isNumberKey) {\n        after.arrayIndex = true\n      }\n      this.append(node, after)\n    } else {\n      this.append(node, this.parseAtom(this.state.type))\n    }\n\n    return node\n  }\n\n  parseExpandOperator() {\n    const node: ExpandOperatorNode = {\n      type: 'ExpandOperator',\n    }\n\n    this.isMatchPattern = true\n    this.isWildMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseWildcardOperator(): WildcardOperatorNode {\n    const node: WildcardOperatorNode = {\n      type: 'WildcardOperator',\n    }\n\n    if (this.state.type === dbStarTok) {\n      node.optional = true\n    }\n\n    this.isMatchPattern = true\n    this.isWildMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    if (this.state.type === parenLTok) {\n      node.filter = this.parseGroupExpression(node)\n    } else if (this.state.type === bracketLTok) {\n      node.filter = this.parseRangeExpression(node)\n    }\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseDestructorExpression(): DestructorExpressionNode {\n    const node: DestructorExpressionNode = {\n      type: 'DestructorExpression',\n    }\n    this.state.context.push(destructorContext)\n    const startPos = this.state.pos - 1\n    node.value =\n      this.state.type === braceLTok\n        ? this.parseObjectPattern()\n        : this.parseArrayPattern()\n    const endPos = this.state.pos\n    this.state.context.pop()\n    node.source = this.input\n      .substring(startPos, endPos)\n      .replace(\n        /\\[\\s*([\\+\\-\\*\\/])?\\s*([^,\\]\\s]*)\\s*\\]/,\n        (match, operator, target) => {\n          if (this.relative !== undefined) {\n            if (operator) {\n              if (target) {\n                return calculate(this.relative, target, operator)\n              } else {\n                return calculate(this.relative, 1, operator)\n              }\n            } else {\n              if (target) {\n                return calculate(this.relative, target, '+')\n              } else {\n                return String(this.relative)\n              }\n            }\n          }\n          return match\n        }\n      )\n      .replace(/\\s*\\.\\s*/g, '')\n      .replace(/\\s*/g, '')\n    if (this.relative === undefined) {\n      setDestructor(node.source, parseDestructorRules(node))\n    }\n    this.relative = undefined\n    this.pushSegments(node.source)\n    this.next()\n    this.append(node, this.parseAtom(this.state.type))\n    return node\n  }\n\n  parseArrayPattern(): ArrayPatternNode {\n    const node: ArrayPatternNode = {\n      type: 'ArrayPattern',\n      elements: [],\n    }\n    this.next()\n    node.elements = this.parseArrayPatternElements()\n    return node\n  }\n\n  parseArrayPatternElements() {\n    const nodes = []\n    while (this.state.type !== bracketRTok && this.state.type !== eofTok) {\n      nodes.push(this.parseAtom(this.state.type))\n      if (this.state.type === bracketRTok) {\n        if (this.includesContext(destructorContext)) {\n          this.next()\n        }\n        return nodes\n      }\n      this.next()\n    }\n    return nodes\n  }\n\n  parseObjectPattern(): ObjectPatternNode {\n    const node: ObjectPatternNode = {\n      type: 'ObjectPattern',\n      properties: [],\n    }\n    this.next()\n    node.properties = this.parseObjectProperties()\n    return node\n  }\n\n  parseObjectProperties(): ObjectPatternPropertyNode[] {\n    const nodes = []\n    while (this.state.type !== braceRTok && this.state.type !== eofTok) {\n      const node: ObjectPatternPropertyNode = {\n        type: 'ObjectPatternProperty',\n        key: this.parseAtom(this.state.type) as IdentifierNode,\n      }\n      nodes.push(node)\n      if (this.state.type === colonTok) {\n        this.next()\n        node.value = this.parseAtom(this.state.type) as\n          | IdentifierNode\n          | ObjectPatternNode[]\n          | ArrayPatternNode[]\n      }\n      if (this.state.type === braceRTok) {\n        if (this.includesContext(destructorContext)) {\n          this.next()\n        }\n        return nodes\n      }\n      this.next()\n    }\n    return nodes\n  }\n\n  parseDotOperator(): Node {\n    const node: DotOperatorNode = {\n      type: 'DotOperator',\n    }\n\n    const prevToken = this.type_\n    if (!prevToken && this.base) {\n      if (this.base.isMatchPattern) {\n        throw new Error('Base path must be an absolute path.')\n      }\n      this.data.segments = this.base.toArr()\n      while (this.state.type === dotTok) {\n        this.relative = this.data.segments.pop()\n        this.haveRelativePattern = true\n        this.next()\n      }\n      return createTreeBySegments(\n        this.data.segments.slice(),\n        this.parseAtom(this.state.type)\n      )\n    } else {\n      this.next()\n    }\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseIgnoreExpression() {\n    this.next()\n\n    const value = String(this.state.value).replace(/\\s*/g, '')\n\n    const node: IgnoreExpressionNode = {\n      type: 'IgnoreExpression',\n      value: value,\n    }\n\n    this.pushSegments(value)\n\n    this.next()\n\n    this.append(node, this.parseAtom(this.state.type))\n\n    this.next()\n\n    return node\n  }\n\n  parseGroupExpression(parent: Node) {\n    const node: GroupExpressionNode = {\n      type: 'GroupExpression',\n      value: [],\n    }\n\n    this.isMatchPattern = true\n    this.data.segments = []\n\n    this.next()\n\n    loop: while (true) {\n      switch (this.state.type) {\n        case commaTok:\n          this.next()\n          break\n        case bangTok:\n          node.isExclude = true\n          this.haveExcludePattern = true\n          this.next()\n          break\n        case eofTok:\n          break loop\n        case parenRTok:\n          break loop\n        default:\n          node.value.push(this.parseAtom(this.state.type))\n      }\n    }\n\n    this.next()\n\n    this.append(parent, this.parseAtom(this.state.type))\n\n    return node\n  }\n\n  parseRangeExpression(parent: Node) {\n    const node: RangeExpressionNode = {\n      type: 'RangeExpression',\n    }\n\n    this.next()\n\n    this.isMatchPattern = true\n    this.data.segments = []\n\n    let start = false,\n      hasColon = false\n\n    loop: while (true) {\n      switch (this.state.type) {\n        case colonTok:\n          hasColon = true\n          start = true\n          this.next()\n          break\n        case bracketRTok:\n          if (!hasColon && !node.end) {\n            node.end = node.start\n          }\n          break loop\n        case commaTok:\n          // never reach\n          throw this.unexpect()\n        case eofTok:\n          // never reach\n          break loop\n        default:\n          if (!start) {\n            node.start = this.parseAtom(this.state.type) as IdentifierNode\n          } else {\n            node.end = this.parseAtom(this.state.type) as IdentifierNode\n          }\n      }\n    }\n\n    this.next()\n\n    this.append(parent, this.parseAtom(this.state.type))\n\n    return node\n  }\n}\n","import {\n  Segments,\n  Node,\n  isIdentifier,\n  isExpandOperator,\n  isWildcardOperator,\n  isGroupExpression,\n  isRangeExpression,\n  isIgnoreExpression,\n  isDotOperator,\n  isDestructorExpression,\n  IdentifierNode,\n  IgnoreExpressionNode,\n  DestructorExpressionNode,\n  ExpandOperatorNode,\n  WildcardOperatorNode,\n  GroupExpressionNode,\n  RangeExpressionNode,\n} from './types'\nimport { isEqual, toArr, isSegmentEqual } from './shared'\nexport interface IRecord {\n  score: number\n}\n\nexport class Matcher {\n  private tree: Node\n\n  private stack: Node[]\n\n  private record: IRecord\n\n  private excluding: boolean\n\n  private wildcards: WildcardOperatorNode[]\n\n  private path: Segments\n\n  constructor(tree: Node, record?: any) {\n    this.tree = tree\n    this.stack = []\n    this.excluding = false\n    this.wildcards = []\n    this.record = record\n  }\n\n  next(node: Node, pos: number) {\n    //  const isOverToken = pos > this.path.length\n    if (node.after) {\n      // if (isOverToken) {\n      //   return false\n      // }\n      return this.matchNode(node.after, pos)\n    }\n\n    if (isWildcardOperator(node) && !node.filter) {\n      if (this.excluding) {\n        return false\n      } else {\n        if (pos === 0 || node.optional) return true\n        return !!this.take(pos)\n      }\n    }\n\n    const isLastToken = pos === this.path.length - 1\n    if (isLastToken) {\n      return !!this.take(pos)\n    } else {\n      const wildcard = this.wildcards.pop()\n      if (wildcard && wildcard.after) {\n        return this.next(wildcard, pos)\n      }\n    }\n\n    return false\n  }\n\n  shot() {\n    if (this.record?.score >= 0) {\n      this.record.score++\n    }\n  }\n\n  take(pos: number) {\n    return String(this.path[pos] ?? '')\n  }\n\n  matchExcludeIdentifier(matched: boolean, node: Node, pos: number) {\n    const isLastToken = pos === this.path.length - 1\n    const isContainToken = pos < this.path.length\n    if (!node.after) {\n      this.excluding = false\n    }\n    if (matched) {\n      if (node.after) {\n        return this.next(node, pos)\n      }\n      if (isLastToken) {\n        return false\n      }\n    }\n    if (isLastToken) {\n      return true\n    }\n    return isContainToken\n  }\n\n  matchIdentifier(node: IdentifierNode, pos: number) {\n    const current = this.take(pos)\n    let matched = false\n    if (isExpandOperator(node.after)) {\n      if (current.indexOf(node.value) === 0) {\n        this.shot()\n        matched = true\n      }\n      if (this.excluding) {\n        return this.matchExcludeIdentifier(matched, node.after, pos)\n      } else {\n        return matched && this.next(node.after, pos)\n      }\n    } else if (current === node.value) {\n      this.shot()\n      matched = true\n    }\n    if (this.excluding) {\n      return this.matchExcludeIdentifier(matched, node, pos)\n    } else {\n      return matched && this.next(node, pos)\n    }\n  }\n\n  matchIgnoreExpression(node: IgnoreExpressionNode, pos: number) {\n    return isEqual(node.value, this.take(pos)) && this.next(node, pos)\n  }\n\n  matchDestructorExpression(node: DestructorExpressionNode, pos: number) {\n    return isEqual(node.source, this.take(pos)) && this.next(node, pos)\n  }\n\n  matchExpandOperator(node: ExpandOperatorNode, pos: number) {\n    return this.next(node, pos)\n  }\n\n  matchWildcardOperator(node: WildcardOperatorNode, pos: number) {\n    let matched = false\n    if (node.filter) {\n      this.stack.push(node)\n      matched = this.matchNode(node.filter, pos)\n      this.stack.pop()\n    } else {\n      matched = this.next(node, pos)\n    }\n    return matched\n  }\n\n  matchGroupExpression(node: GroupExpressionNode, pos: number) {\n    let excluding = false\n    if (node.isExclude) {\n      excluding = !this.excluding\n    }\n    return toArr(node.value)[excluding ? 'every' : 'some']((item) => {\n      this.wildcards = this.stack.slice() as WildcardOperatorNode[]\n      this.excluding = excluding\n      return this.matchNode(item, pos)\n    })\n  }\n\n  matchRangeExpression(node: RangeExpressionNode, pos: number) {\n    const current = Number(this.take(pos))\n    if (node.start) {\n      if (node.end) {\n        return (\n          current >= Number(node.start.value) &&\n          current <= Number(node.end.value)\n        )\n      } else {\n        return current >= Number(node.start.value)\n      }\n    } else {\n      if (node.end) {\n        return current <= Number(node.end.value)\n      } else {\n        this.wildcards = this.stack.slice() as WildcardOperatorNode[]\n        return this.next(node, pos)\n      }\n    }\n  }\n\n  matchNode(node: Node, pos = 0) {\n    if (isDotOperator(node)) {\n      return this.next(node, pos + 1)\n    } else if (isIdentifier(node)) {\n      return this.matchIdentifier(node, pos)\n    } else if (isIgnoreExpression(node)) {\n      return this.matchIgnoreExpression(node, pos)\n    } else if (isDestructorExpression(node)) {\n      return this.matchDestructorExpression(node, pos)\n    } else if (isExpandOperator(node)) {\n      return this.matchExpandOperator(node, pos)\n    } else if (isWildcardOperator(node)) {\n      return this.matchWildcardOperator(node, pos)\n    } else if (isGroupExpression(node)) {\n      return this.matchGroupExpression(node, pos)\n    } else if (isRangeExpression(node)) {\n      return this.matchRangeExpression(node, pos)\n    }\n    return false\n  }\n\n  match(path: Segments) {\n    this.path = path\n    return { matched: this.matchNode(this.tree), record: this.record }\n  }\n\n  static matchSegments(source: Segments, target: Segments, record?: any) {\n    if (source.length !== target.length) return { matched: false, record }\n    const match = (pos = 0) => {\n      const current = isSegmentEqual(source[pos], target[pos])\n      if (record?.score >= 0) {\n        record.score++\n      }\n      return current && (pos < source.length - 1 ? match(pos + 1) : true)\n    }\n    return { matched: match(), record }\n  }\n}\n","import { Parser } from './parser'\nimport { isStr, isArr, isFn, isEqual, isObj, isNum, isRegExp } from './shared'\nimport {\n  getDestructor,\n  getInByDestructor,\n  setInByDestructor,\n  deleteInByDestructor,\n  existInByDestructor,\n} from './destructor'\nimport { Segments, Node, Pattern } from './types'\nimport { Matcher } from './matcher'\n\nconst pathCache = new Map()\n\nconst isMatcher = Symbol('PATH_MATCHER')\n\nconst isValid = (val: any) => val !== undefined && val !== null\n\nconst isSimplePath = (val: string) =>\n  val.indexOf('*') === -1 &&\n  val.indexOf('~') === -1 &&\n  val.indexOf('[') === -1 &&\n  val.indexOf(']') === -1 &&\n  val.indexOf(',') === -1 &&\n  val.indexOf(':') === -1 &&\n  val.indexOf(' ') === -1 &&\n  val[0] !== '.'\n\nconst isAssignable = (val: any) =>\n  typeof val === 'object' || typeof val === 'function'\n\nconst isNumberIndex = (val: any) =>\n  isStr(val) ? /^\\d+$/.test(val) : isNum(val)\n\nconst getIn = (segments: Segments, source: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (!isValid(source)) return\n      source = source[index]\n    } else {\n      source = getInByDestructor(source, rules, { setIn, getIn })\n      break\n    }\n  }\n  return source\n}\n\nconst setIn = (segments: Segments, source: any, value: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (!isValid(source) || !isAssignable(source)) return\n      if (isArr(source) && !isNumberIndex(index)) {\n        return\n      }\n      if (!isValid(source[index])) {\n        if (value === undefined) {\n          if (source[index] === null) source[index] = value\n          return\n        }\n        if (i < segments.length - 1) {\n          source[index] = isNum(segments[i + 1]) ? [] : {}\n        }\n      }\n      if (i === segments.length - 1) {\n        source[index] = value\n      }\n      source = source[index]\n    } else {\n      setInByDestructor(source, rules, value, { setIn, getIn })\n      break\n    }\n  }\n}\n\nconst deleteIn = (segments: Segments, source: any) => {\n  for (let i = 0; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (i === segments.length - 1 && isValid(source)) {\n        delete source[index]\n        return\n      }\n\n      if (!isValid(source) || !isAssignable(source)) return\n      source = source[index]\n      if (!isObj(source)) {\n        return\n      }\n    } else {\n      deleteInByDestructor(source, rules, {\n        setIn,\n        getIn,\n        deleteIn,\n      })\n      break\n    }\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nconst existIn = (segments: Segments, source: any, start: number | Path) => {\n  if (start instanceof Path) {\n    start = start.length\n  }\n  for (let i = start; i < segments.length; i++) {\n    const index = segments[i]\n    const rules = getDestructor(index as string)\n    if (!rules) {\n      if (i === segments.length - 1) {\n        return hasOwnProperty.call(source, index)\n      }\n\n      if (!isValid(source) || !isAssignable(source)) return false\n      source = source[index]\n\n      if (!isObj(source)) {\n        return false\n      }\n    } else {\n      return existInByDestructor(source, rules, start, {\n        setIn,\n        getIn,\n        deleteIn,\n        existIn,\n      })\n    }\n  }\n}\n\nconst parse = (pattern: Pattern, base?: Pattern) => {\n  if (pattern instanceof Path) {\n    return {\n      entire: pattern.entire,\n      segments: pattern.segments.slice(),\n      isRegExp: false,\n      haveRelativePattern: pattern.haveRelativePattern,\n      isWildMatchPattern: pattern.isWildMatchPattern,\n      isMatchPattern: pattern.isMatchPattern,\n      haveExcludePattern: pattern.haveExcludePattern,\n      tree: pattern.tree,\n    }\n  } else if (isStr(pattern)) {\n    if (!pattern) {\n      return {\n        entire: '',\n        segments: [],\n        isRegExp: false,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    }\n    if (isSimplePath(pattern)) {\n      return {\n        entire: pattern,\n        segments: pattern.split('.'),\n        isRegExp: false,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    }\n    const parser = new Parser(pattern, Path.parse(base))\n    const tree = parser.parse()\n    if (!parser.isMatchPattern) {\n      const segments = parser.data.segments\n      return {\n        entire: segments.join('.'),\n        segments,\n        tree,\n        isRegExp: false,\n        haveRelativePattern: parser.haveRelativePattern,\n        isWildMatchPattern: false,\n        haveExcludePattern: false,\n        isMatchPattern: false,\n      }\n    } else {\n      return {\n        entire: pattern,\n        segments: [],\n        isRegExp: false,\n        haveRelativePattern: false,\n        isWildMatchPattern: parser.isWildMatchPattern,\n        haveExcludePattern: parser.haveExcludePattern,\n        isMatchPattern: true,\n        tree,\n      }\n    }\n  } else if (isFn(pattern) && pattern[isMatcher]) {\n    return parse(pattern['path'])\n  } else if (isArr(pattern)) {\n    return {\n      entire: pattern.join('.'),\n      segments: pattern.reduce((buf, key) => {\n        return buf.concat(parseString(key))\n      }, []),\n      isRegExp: false,\n      haveRelativePattern: false,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: false,\n    }\n  } else if (isRegExp(pattern)) {\n    return {\n      entire: pattern,\n      segments: [],\n      isRegExp: true,\n      haveRelativePattern: false,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: true,\n    }\n  } else {\n    return {\n      entire: '',\n      isRegExp: false,\n      segments: pattern !== undefined ? [pattern] : [],\n      haveRelativePattern: false,\n      isWildMatchPattern: false,\n      haveExcludePattern: false,\n      isMatchPattern: false,\n    }\n  }\n}\n\nconst parseString = (source: any) => {\n  if (isStr(source)) {\n    source = source.replace(/\\s*/g, '')\n    try {\n      const { segments, isMatchPattern } = parse(source)\n      return !isMatchPattern ? segments : source\n    } catch (e) {\n      return source\n    }\n  } else if (source instanceof Path) {\n    return source.segments\n  }\n  return source\n}\n\nexport class Path {\n  public entire: string | RegExp\n  public segments: Segments\n  public isMatchPattern: boolean\n  public isWildMatchPattern: boolean\n  public isRegExp: boolean\n  public haveRelativePattern: boolean\n  public haveExcludePattern: boolean\n  public matchScore: number\n  public tree: Node\n  private matchCache: any\n  private includesCache: any\n\n  constructor(input: Pattern, base?: Pattern) {\n    const {\n      tree,\n      segments,\n      entire,\n      isRegExp,\n      isMatchPattern,\n      isWildMatchPattern,\n      haveRelativePattern,\n      haveExcludePattern,\n    } = parse(input, base)\n    this.entire = entire\n    this.segments = segments\n    this.isMatchPattern = isMatchPattern\n    this.isWildMatchPattern = isWildMatchPattern\n    this.haveRelativePattern = haveRelativePattern\n    this.isRegExp = isRegExp\n    this.haveExcludePattern = haveExcludePattern\n    this.tree = tree as Node\n    this.matchCache = new Map()\n    this.includesCache = new Map()\n  }\n\n  toString() {\n    return this.entire?.toString()\n  }\n\n  toArr() {\n    return this.segments?.slice()\n  }\n\n  get length() {\n    return this.segments.length\n  }\n\n  concat = (...args: Pattern[]) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be concat`)\n    }\n    const path = new Path('')\n    path.segments = this.segments.concat(...args.map((s) => parseString(s)))\n    path.entire = path.segments.join('.')\n    return path\n  }\n\n  slice = (start?: number, end?: number) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be slice`)\n    }\n    const path = new Path('')\n    path.segments = this.segments.slice(start, end)\n    path.entire = path.segments.join('.')\n    return path\n  }\n\n  push = (...items: Pattern[]) => {\n    return this.concat(...items)\n  }\n\n  pop = () => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be pop`)\n    }\n    return new Path(this.segments.slice(0, this.segments.length - 1))\n  }\n\n  splice = (\n    start: number,\n    deleteCount?: number,\n    ...items: Array<string | number>\n  ) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be splice`)\n    }\n    items = items.reduce((buf, item) => buf.concat(parseString(item)), [])\n    const segments_ = this.segments.slice()\n    segments_.splice(start, deleteCount, ...items)\n    return new Path(segments_)\n  }\n\n  forEach = (callback: (key: string | number) => any) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be each`)\n    }\n    this.segments.forEach(callback)\n  }\n\n  map = (callback: (key: string | number) => any) => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be map`)\n    }\n    return this.segments.map(callback)\n  }\n\n  reduce = <T>(\n    callback: (buf: T, item: string | number, index: number) => T,\n    initial: T\n  ): T => {\n    if (this.isMatchPattern || this.isRegExp) {\n      throw new Error(`${this.entire} cannot be reduce`)\n    }\n    return this.segments.reduce(callback, initial)\n  }\n\n  parent = () => {\n    return this.slice(0, this.length - 1)\n  }\n\n  includes = (pattern: Pattern) => {\n    const { entire, segments, isMatchPattern } = Path.parse(pattern)\n    const cache = this.includesCache.get(entire)\n    if (cache !== undefined) return cache\n    const cacheWith = (value: boolean): boolean => {\n      this.includesCache.set(entire, value)\n      return value\n    }\n    if (this.isMatchPattern) {\n      if (!isMatchPattern) {\n        return cacheWith(this.match(segments))\n      } else {\n        throw new Error(`${this.entire} cannot be used to match ${entire}`)\n      }\n    }\n    if (isMatchPattern) {\n      throw new Error(`${this.entire} cannot be used to match ${entire}`)\n    }\n    if (segments.length > this.segments.length) return cacheWith(false)\n    for (let i = 0; i < segments.length; i++) {\n      if (!isEqual(String(segments[i]), String(this.segments[i]))) {\n        return cacheWith(false)\n      }\n    }\n    return cacheWith(true)\n  }\n\n  transform = <T>(\n    regexp: string | RegExp,\n    callback: (...args: string[]) => T\n  ): T | string => {\n    if (!isFn(callback)) return ''\n    if (this.isMatchPattern) {\n      throw new Error(`${this.entire} cannot be transformed`)\n    }\n    const reg = new RegExp(regexp)\n    const args = this.segments.filter((key) =>\n      reg.test(key as string)\n    ) as string[]\n    return callback(...args)\n  }\n\n  match = (pattern: Pattern): boolean => {\n    const path = Path.parse(pattern)\n    const cache = this.matchCache.get(path.entire)\n    if (cache !== undefined) {\n      if (cache.record && cache.record.score !== undefined) {\n        this.matchScore = cache.record.score\n      }\n      return cache.matched\n    }\n    const cacheWith = (value: any) => {\n      this.matchCache.set(path.entire, value)\n      return value\n    }\n    if (path.isMatchPattern) {\n      if (this.isMatchPattern) {\n        throw new Error(`${path.entire} cannot match ${this.entire}`)\n      } else {\n        this.matchScore = 0\n        return cacheWith(path.match(this.segments))\n      }\n    } else {\n      if (this.isMatchPattern) {\n        if (this.isRegExp) {\n          try {\n            return this['entire']?.['test']?.(path.entire)\n          } finally {\n            ;(this.entire as RegExp).lastIndex = 0\n          }\n        }\n        const record = {\n          score: 0,\n        }\n        const result = cacheWith(\n          new Matcher(this.tree, record).match(path.segments)\n        )\n        this.matchScore = record.score\n        return result.matched\n      } else {\n        const record = {\n          score: 0,\n        }\n        const result = cacheWith(\n          Matcher.matchSegments(this.segments, path.segments, record)\n        )\n        this.matchScore = record.score\n        return result.matched\n      }\n    }\n  }\n\n  //别名组匹配\n  matchAliasGroup = (name: Pattern, alias: Pattern) => {\n    const namePath = Path.parse(name)\n    const aliasPath = Path.parse(alias)\n    const nameMatched = this.match(namePath)\n    const nameMatchedScore = this.matchScore\n    const aliasMatched = this.match(aliasPath)\n    const aliasMatchedScore = this.matchScore\n    if (this.haveExcludePattern) {\n      if (nameMatchedScore >= aliasMatchedScore) {\n        return nameMatched\n      } else {\n        return aliasMatched\n      }\n    } else {\n      return nameMatched || aliasMatched\n    }\n  }\n\n  existIn = (source?: any, start: number | Path = 0) => {\n    return existIn(this.segments, source, start)\n  }\n\n  getIn = (source?: any) => {\n    return getIn(this.segments, source)\n  }\n\n  setIn = (source?: any, value?: any) => {\n    setIn(this.segments, source, value)\n    return source\n  }\n\n  deleteIn = (source?: any) => {\n    deleteIn(this.segments, source)\n    return source\n  }\n\n  ensureIn = (source?: any, defaults?: any) => {\n    const results = this.getIn(source)\n    if (results === undefined) {\n      this.setIn(source, defaults)\n      return this.getIn(source)\n    }\n    return results\n  }\n\n  static match(pattern: Pattern) {\n    const path = Path.parse(pattern)\n    const matcher = (target) => {\n      return path.match(target)\n    }\n    matcher[isMatcher] = true\n    matcher.path = path\n    return matcher\n  }\n\n  static isPathPattern(target: any): target is Pattern {\n    return !!(\n      isStr(target) ||\n      isArr(target) ||\n      isRegExp(target) ||\n      (isFn(target) && target[isMatcher])\n    )\n  }\n\n  static transform<T>(\n    pattern: Pattern,\n    regexp: string | RegExp,\n    callback: (...args: string[]) => T\n  ): any {\n    return Path.parse(pattern).transform(regexp, callback)\n  }\n\n  static parse(path: Pattern = '', base?: Pattern): Path {\n    if (path instanceof Path) {\n      const found = pathCache.get(path.entire)\n      if (found) {\n        return found\n      } else {\n        pathCache.set(path.entire, path)\n        return path\n      }\n    } else if (path && path[isMatcher]) {\n      return Path.parse(path['path'])\n    } else {\n      const key_ = base ? Path.parse(base) : ''\n      const key = `${path}:${key_}`\n      const found = pathCache.get(key)\n      if (found) {\n        return found\n      } else {\n        path = new Path(path, base)\n        pathCache.set(key, path)\n        return path\n      }\n    }\n  }\n\n  static getIn = (source: any, pattern: Pattern) => {\n    const path = Path.parse(pattern)\n    return path.getIn(source)\n  }\n\n  static setIn = (source: any, pattern: Pattern, value: any) => {\n    const path = Path.parse(pattern)\n    return path.setIn(source, value)\n  }\n\n  static deleteIn = (source: any, pattern: Pattern) => {\n    const path = Path.parse(pattern)\n    return path.deleteIn(source)\n  }\n\n  static existIn = (source: any, pattern: Pattern, start?: number | Path) => {\n    const path = Path.parse(pattern)\n    return path.existIn(source, start)\n  }\n\n  static ensureIn = (source: any, pattern: Pattern, defaultValue?: any) => {\n    const path = Path.parse(pattern)\n    return path.ensureIn(source, defaultValue)\n  }\n}\n\nexport { Pattern }\n"],"names":["ContextType","flag","props","__assign","bracketContext","bracketArrayContext","bracketDContext","parenContext","braceContext","destructorContext","TokenType","nameTok","expectNext","next","this","includesContext","commaTok","bracketRTok","braceRTok","colonTok","dotTok","eofTok","parenRTok","expandTok","bracketLTok","starTok","parenLTok","dbStarTok","bracketDLTok","braceLTok","expectPrev","prev","bracketDRTok","bangTok","updateContext","state","context","push","pop","ignoreTok","unexpect","curContext","nonASCIIWhitespace","isRewordCode","code","getError","message","err","Error","Object","assign","slice","string","start","end","str","i","ch","charAt","Tokenizer","input","type","pos","type_","prototype","length","len","concat","call","match","skipSpace","loop","charCodeAt","test","String","fromCharCode","finishToken","readToken","getCode","Infinity","codePointAt","fullCharCodeAtPos","eat","readKeyWord","startPos","prevCode","readIgnoreString","replace","value","preType","undefined","isType","obj","isIdentifier","isIgnoreExpression","isDotOperator","isWildcardOperator","isExpandOperator","isGroupExpression","isRangeExpression","isDestructorExpression","isObjectPattern","isArrayPattern","toString","isFn","isArr","Array","isArray","isStr","isNum","isObj","val","isRegExp","isNumberLike","t","keyList","keys","hasProp","hasOwnProperty","isEqual","a","b","arrA","arrB","key","DestructorCache","Map","getDestructor","source","get","parseDestructorRules","node","rules","index_1","properties","forEach","child","path","basePath","childRules","k","rule","index_2","elements","setInByDestructor","mutators","_a","setIn","getIn","getInByDestructor","response","deleteInByDestructor","deleteIn","existInByDestructor","every","existIn","calculate","operator","Number","Parser","_super","base","_this","isMatchPattern","isWildMatchPattern","haveExcludePattern","haveRelativePattern","__extends","parse","data","segments","parseAtom","tree","append","parent","after","parseObjectPattern","parseArrayPattern","parseDestructorExpression","parseIdentifier","parseExpandOperator","parseWildcardOperator","parseIgnoreExpression","parseDotOperator","pushSegments","hasNotInDestructor","isNumberKey","arrayIndex","optional","filter","parseGroupExpression","parseRangeExpression","endPos","substring","target","relative","set","parseArrayPatternElements","nodes","parseObjectProperties","toArr","afterNode","segLen","build","dot","createTreeBySegments","isExclude","hasColon","Matcher","record","stack","excluding","wildcards","matchNode","take","wildcard","shot","score","matchExcludeIdentifier","matched","isLastToken","isContainToken","matchIdentifier","current","indexOf","matchIgnoreExpression","matchDestructorExpression","matchExpandOperator","matchWildcardOperator","matchGroupExpression","item","matchRangeExpression","matchSegments","pathCache","isMatcher","Symbol","isValid","isAssignable","index","Path","pattern","entire","split","parser","join","reduce","buf","parseString","e","args","_i","arguments","apply","__spreadArray","__read","map","s","items","splice","deleteCount","segments_","callback","initial","includes","cache","includesCache","cacheWith","transform","regexp","reg","RegExp","matchCache","matchScore","_b","lastIndex","result","matchAliasGroup","name","alias","namePath","aliasPath","nameMatched","nameMatchedScore","aliasMatched","aliasMatchedScore","ensureIn","defaults","results","defineProperty","matcher","isPathPattern","key_","defaultValue"],"mappings":"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"}