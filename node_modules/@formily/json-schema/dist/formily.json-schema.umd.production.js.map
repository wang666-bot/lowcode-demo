{"version":3,"file":"formily.json-schema.umd.production.js","sources":["../src/shared.ts","../src/compiler.ts","../src/transformer.ts","../src/patches.ts","../src/polyfills/SPECIFICATION_1_0.ts","../src/schema.ts"],"sourcesContent":["import { isFn, each, isPlainObj, isArr, toArr, FormPath } from '@formily/shared'\nimport { isObservable, untracked } from '@formily/reactive'\nimport { Schema } from './schema'\nimport { ISchema } from './types'\n\nconst REVA_ACTIONS_KEY = Symbol.for('__REVA_ACTIONS')\n\nexport const SchemaNestedMap = {\n  parent: true,\n  root: true,\n  properties: true,\n  patternProperties: true,\n  additionalProperties: true,\n  items: true,\n  additionalItems: true,\n  'x-linkages': true,\n  'x-reactions': true,\n}\n\nexport const SchemaStateMap = {\n  title: 'title',\n  description: 'description',\n  default: 'initialValue',\n  enum: 'dataSource',\n  readOnly: 'readOnly',\n  writeOnly: 'editable',\n  'x-content': 'content',\n  'x-data': 'data',\n  'x-value': 'value',\n  'x-editable': 'editable',\n  'x-disabled': 'disabled',\n  'x-read-pretty': 'readPretty',\n  'x-read-only': 'readOnly',\n  'x-visible': 'visible',\n  'x-hidden': 'hidden',\n  'x-display': 'display',\n  'x-pattern': 'pattern',\n  'x-validator': 'validator',\n  'x-decorator': 'decoratorType',\n  'x-component': 'componentType',\n  'x-decorator-props': 'decoratorProps',\n  'x-component-props': 'componentProps',\n}\n\nexport const SchemaValidatorMap = {\n  required: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  maxLength: true,\n  minLength: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  pattern: true,\n  const: true,\n  multipleOf: true,\n  maxProperties: true,\n  minProperties: true,\n  uniqueItems: true,\n}\n\nexport const SchemaNormalKeys = Object.keys(SchemaStateMap)\n\nexport const SchemaValidatorKeys = Object.keys(SchemaValidatorMap)\n\nexport const hasOwnProperty = Object.prototype.hasOwnProperty\n\nexport const traverse = (\n  target: any,\n  visitor: (value: any, path: Array<string | number>) => void\n) => {\n  const seenObjects = []\n  const root = target\n  const traverse = (target: any, path = []) => {\n    if (isPlainObj(target)) {\n      const seenIndex = seenObjects.indexOf(target)\n      if (seenIndex > -1) {\n        return\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(target)\n      if (isNoNeedCompileObject(target) && root !== target) {\n        visitor(target, path)\n        return\n      }\n      each(target, (value, key) => {\n        traverse(value, path.concat(key))\n      })\n      seenObjects.splice(addIndex, 1)\n    } else {\n      visitor(target, path)\n    }\n  }\n  traverse(target)\n}\n\nexport const traverseSchema = (\n  schema: ISchema,\n  visitor: (value: any, path: any[], omitCompile?: boolean) => void\n) => {\n  if (schema['x-validator'] !== undefined) {\n    visitor(\n      schema['x-validator'],\n      ['x-validator'],\n      schema['x-compile-omitted']?.includes('x-validator')\n    )\n  }\n  const seenObjects = []\n  const root = schema\n  const traverse = (target: any, path = []) => {\n    if (\n      path[0] === 'x-compile-omitted' ||\n      path[0] === 'x-validator' ||\n      path[0] === 'version' ||\n      path[0] === '_isJSONSchemaObject'\n    )\n      return\n    if (String(path[0]).indexOf('x-') == -1 && isFn(target)) return\n    if (SchemaNestedMap[path[0]]) return\n    if (schema['x-compile-omitted']?.indexOf(path[0]) > -1) {\n      visitor(target, path, true)\n      return\n    }\n    if (isPlainObj(target)) {\n      if (path[0] === 'default' || path[0] === 'x-value') {\n        visitor(target, path)\n        return\n      }\n      const seenIndex = seenObjects.indexOf(target)\n      if (seenIndex > -1) {\n        return\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(target)\n      if (isNoNeedCompileObject(target) && root !== target) {\n        visitor(target, path)\n        return\n      }\n      each(target, (value, key) => {\n        traverse(value, path.concat(key))\n      })\n      seenObjects.splice(addIndex, 1)\n    } else {\n      visitor(target, path)\n    }\n  }\n  traverse(schema)\n}\n\nexport const isNoNeedCompileObject = (source: any) => {\n  if ('$$typeof' in source && '_owner' in source) {\n    return true\n  }\n  if (source['_isAMomentObject']) {\n    return true\n  }\n  if (Schema.isSchemaInstance(source)) {\n    return true\n  }\n  if (source[REVA_ACTIONS_KEY]) {\n    return true\n  }\n  if (isFn(source['toJS'])) {\n    return true\n  }\n  if (isFn(source['toJSON'])) {\n    return true\n  }\n  if (isObservable(source)) {\n    return true\n  }\n  return false\n}\n\nexport const createDataSource = (source: any[]) => {\n  return toArr(source).map((item) => {\n    if (typeof item === 'object') {\n      return item\n    } else {\n      return {\n        label: item,\n        value: item,\n      }\n    }\n  })\n}\n\nexport const patchStateFormSchema = (\n  targetState: any,\n  pattern: any[],\n  compiled: any\n) => {\n  untracked(() => {\n    const path = FormPath.parse(pattern)\n    const segments = path.segments\n    const key = segments[0]\n    const isEnum = key === 'enum' && isArr(compiled)\n    const schemaMapKey = SchemaStateMap[key]\n    if (schemaMapKey) {\n      FormPath.setIn(\n        targetState,\n        [schemaMapKey].concat(segments.slice(1)),\n        isEnum ? createDataSource(compiled) : compiled\n      )\n    } else {\n      const isValidatorKey = SchemaValidatorMap[key]\n      if (isValidatorKey) {\n        targetState['setValidatorRule']?.(key, compiled)\n      }\n    }\n  })\n}\n","import {\n  isArr,\n  isFn,\n  isPlainObj,\n  isStr,\n  reduce,\n  FormPath,\n} from '@formily/shared'\nimport { IGeneralFieldState } from '@formily/core'\nimport { untracked, hasCollected } from '@formily/reactive'\nimport {\n  traverse,\n  traverseSchema,\n  isNoNeedCompileObject,\n  hasOwnProperty,\n  patchStateFormSchema,\n} from './shared'\nimport { ISchema } from './types'\n\nconst ExpRE = /^\\s*\\{\\{([\\s\\S]*)\\}\\}\\s*$/\nconst Registry = {\n  silent: false,\n  compile(expression: string, scope = {}) {\n    if (Registry.silent) {\n      try {\n        return new Function('$root', `with($root) { return (${expression}); }`)(\n          scope\n        )\n      } catch {}\n    } else {\n      return new Function('$root', `with($root) { return (${expression}); }`)(\n        scope\n      )\n    }\n  },\n}\n\nexport const silent = (value = true) => {\n  Registry.silent = !!value\n}\n\nexport const registerCompiler = (\n  compiler: (expression: string, scope: any) => any\n) => {\n  if (isFn(compiler)) {\n    Registry.compile = compiler\n  }\n}\n\nexport const shallowCompile = <Source = any, Scope = any>(\n  source: Source,\n  scope?: Scope\n) => {\n  if (isStr(source)) {\n    const matched = source.match(ExpRE)\n    if (!matched) return source\n    return Registry.compile(matched[1], scope)\n  }\n  return source\n}\n\nexport const compile = <Source = any, Scope = any>(\n  source: Source,\n  scope?: Scope\n): any => {\n  const seenObjects = []\n  const compile = (source: any) => {\n    if (isStr(source)) {\n      return shallowCompile(source, scope)\n    } else if (isArr(source)) {\n      return source.map((value: any) => compile(value))\n    } else if (isPlainObj(source)) {\n      if (isNoNeedCompileObject(source)) return source\n      const seenIndex = seenObjects.indexOf(source)\n      if (seenIndex > -1) {\n        return source\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(source)\n      const results = reduce(\n        source,\n        (buf, value, key) => {\n          buf[key] = compile(value)\n          return buf\n        },\n        {}\n      )\n      seenObjects.splice(addIndex, 1)\n      return results\n    }\n    return source\n  }\n  return compile(source)\n}\n\nexport const patchCompile = (\n  targetState: IGeneralFieldState,\n  sourceState: any,\n  scope: any\n) => {\n  traverse(sourceState, (value, pattern) => {\n    const compiled = compile(value, scope)\n    if (compiled === undefined) return\n    const path = FormPath.parse(pattern)\n    const key = path.segments[0]\n    if (hasOwnProperty.call(targetState, key)) {\n      untracked(() => FormPath.setIn(targetState, path, compiled))\n    }\n  })\n}\n\nexport const patchSchemaCompile = (\n  targetState: IGeneralFieldState,\n  sourceSchema: ISchema,\n  scope: any,\n  demand = false\n) => {\n  traverseSchema(sourceSchema, (value, path, omitCompile) => {\n    let compiled = value\n    let collected = hasCollected(() => {\n      if (!omitCompile) {\n        compiled = compile(value, scope)\n      }\n    })\n    if (compiled === undefined) return\n    if (demand) {\n      if (collected || !targetState.initialized) {\n        patchStateFormSchema(targetState, path, compiled)\n      }\n    } else {\n      patchStateFormSchema(targetState, path, compiled)\n    }\n  })\n}\n","import { untracked, autorun, observable } from '@formily/reactive'\nimport {\n  isArr,\n  isStr,\n  toArr,\n  each,\n  isFn,\n  isPlainObj,\n  reduce,\n  lazyMerge,\n} from '@formily/shared'\nimport { Schema } from './schema'\nimport {\n  ISchema,\n  ISchemaTransformerOptions,\n  IFieldStateSetterOptions,\n  SchemaReaction,\n} from './types'\nimport {\n  onFieldInit,\n  onFieldMount,\n  onFieldUnmount,\n  onFieldValueChange,\n  onFieldInputValueChange,\n  onFieldInitialValueChange,\n  onFieldValidateStart,\n  onFieldValidateEnd,\n  onFieldValidateFailed,\n  onFieldValidateSuccess,\n  IFieldFactoryProps,\n  Field,\n} from '@formily/core'\nimport { patchCompile, patchSchemaCompile, shallowCompile } from './compiler'\n\nconst FieldEffects = {\n  onFieldInit,\n  onFieldMount,\n  onFieldUnmount,\n  onFieldValueChange,\n  onFieldInputValueChange,\n  onFieldInitialValueChange,\n  onFieldValidateStart,\n  onFieldValidateEnd,\n  onFieldValidateFailed,\n  onFieldValidateSuccess,\n}\n\nconst DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange']\n\nconst getDependencyValue = (\n  field: Field,\n  pattern: string,\n  property?: string\n) => {\n  const [target, path] = String(pattern).split(/\\s*#\\s*/)\n  return field.query(target).getIn(path || property || 'value')\n}\n\nconst getDependencies = (\n  field: Field,\n  dependencies:\n    | Array<string | { name?: string; source?: string; property?: string }>\n    | object\n) => {\n  if (isArr(dependencies)) {\n    const results = []\n    dependencies.forEach((pattern) => {\n      if (isStr(pattern)) {\n        results.push(getDependencyValue(field, pattern))\n      } else if (isPlainObj(pattern)) {\n        if (pattern.name && pattern.source) {\n          results[pattern.name] = getDependencyValue(\n            field,\n            pattern.source,\n            pattern.property\n          )\n        }\n      }\n    })\n    return results\n  } else if (isPlainObj(dependencies)) {\n    return reduce(\n      dependencies,\n      (buf, pattern, key) => {\n        buf[key] = getDependencyValue(field, pattern)\n        return buf\n      },\n      {}\n    )\n  }\n  return []\n}\n\nconst setSchemaFieldState = (\n  options: IFieldStateSetterOptions,\n  demand = false\n) => {\n  const { request, target, runner, field, scope } = options || {}\n  if (!request) return\n  if (target) {\n    if (request.state) {\n      field.form.setFieldState(target, (state) =>\n        patchCompile(\n          state,\n          request.state,\n          lazyMerge(scope, {\n            $target: state,\n          })\n        )\n      )\n    }\n    if (request.schema) {\n      field.form.setFieldState(target, (state) =>\n        patchSchemaCompile(\n          state,\n          request.schema,\n          lazyMerge(scope, {\n            $target: state,\n          }),\n          demand\n        )\n      )\n    }\n    if (isStr(runner) && runner) {\n      field.form.setFieldState(target, (state) => {\n        shallowCompile(\n          `{{function(){${runner}}}}`,\n          lazyMerge(scope, {\n            $target: state,\n          })\n        )()\n      })\n    }\n  } else {\n    if (request.state) {\n      field.setState((state) => patchCompile(state, request.state, scope))\n    }\n    if (request.schema) {\n      field.setState((state) =>\n        patchSchemaCompile(state, request.schema, scope, demand)\n      )\n    }\n    if (isStr(runner) && runner) {\n      shallowCompile(`{{function(){${runner}}}}`, scope)()\n    }\n  }\n}\n\nconst getBaseScope = (\n  field: Field,\n  options: ISchemaTransformerOptions = {}\n) => {\n  const $observable = (target: any, deps?: any[]) =>\n    autorun.memo(() => observable(target), deps)\n  const $props = (props: any) => field.setComponentProps(props)\n  const $effect = autorun.effect\n  const $memo = autorun.memo\n  const $self = field\n  const $form = field.form\n  const $values = field.form.values\n  return lazyMerge(\n    {\n      get $lookup() {\n        return options?.scope?.$record ?? $values\n      },\n      get $records() {\n        return field.records\n      },\n      get $record() {\n        const record = field.record\n        if (typeof record === 'object') {\n          return lazyMerge(record, {\n            get $lookup() {\n              return options?.scope?.$record ?? $values\n            },\n            get $index() {\n              return field.index\n            },\n          })\n        }\n        return record\n      },\n      get $index() {\n        return field.index\n      },\n    },\n    options.scope,\n    {\n      $form,\n      $self,\n      $observable,\n      $effect,\n      $memo,\n      $props,\n      $values,\n    }\n  )\n}\n\nconst getBaseReactions =\n  (schema: ISchema, options: ISchemaTransformerOptions) => (field: Field) => {\n    setSchemaFieldState(\n      {\n        field,\n        request: { schema },\n        scope: getBaseScope(field, options),\n      },\n      true\n    )\n  }\n\nconst getUserReactions = (\n  schema: ISchema,\n  options: ISchemaTransformerOptions\n) => {\n  const reactions: SchemaReaction[] = toArr(schema['x-reactions'])\n  return reactions.map((unCompiled) => {\n    return (field: Field) => {\n      const baseScope = getBaseScope(field, options)\n      const reaction = shallowCompile(unCompiled, baseScope)\n      if (!reaction) return\n      if (isFn(reaction)) {\n        return reaction(field, baseScope)\n      }\n      const { when, fulfill, otherwise, target, effects } = reaction\n      const run = () => {\n        const $deps = getDependencies(field, reaction.dependencies)\n        const $dependencies = $deps\n        const scope = lazyMerge(baseScope, {\n          $target: null,\n          $deps,\n          $dependencies,\n        })\n        const compiledWhen = shallowCompile(when, scope)\n        const condition = when ? compiledWhen : true\n        const request = condition ? fulfill : otherwise\n        const runner = request?.run\n        setSchemaFieldState({\n          field,\n          target,\n          request,\n          runner,\n          scope,\n        })\n      }\n\n      if (target) {\n        reaction.effects = effects?.length ? effects : DefaultFieldEffects\n      }\n      if (reaction.effects) {\n        autorun.memo(() => {\n          untracked(() => {\n            each(reaction.effects, (type) => {\n              if (FieldEffects[type]) {\n                FieldEffects[type](field.address, run)\n              }\n            })\n          })\n        }, [])\n      } else {\n        run()\n      }\n    }\n  })\n}\n\nexport const transformFieldProps = (\n  schema: Schema,\n  options: ISchemaTransformerOptions\n): IFieldFactoryProps<any, any> => {\n  return {\n    name: schema.name,\n    reactions: [getBaseReactions(schema, options)].concat(\n      getUserReactions(schema, options)\n    ),\n  }\n}\n","import { isFn, isArr } from '@formily/shared'\nimport { SchemaPatch } from './types'\n\nconst patches: SchemaPatch[] = []\n\nconst polyfills: Record<string, SchemaPatch[]> = {}\n\nexport const reducePatches = (schema: any) => {\n  return patches.reduce(\n    (buf, patch) => {\n      return patch(buf)\n    },\n    { ...schema }\n  )\n}\n\nexport const registerPatches = (...args: SchemaPatch[]) => {\n  args.forEach((patch) => {\n    if (isFn(patch)) {\n      patches.push(patch)\n    }\n  })\n}\n\nexport const registerPolyfills = (version: string, patch: SchemaPatch) => {\n  if (version && isFn(patch)) {\n    polyfills[version] = polyfills[version] || []\n    polyfills[version].push(patch)\n  }\n}\n\nexport const enablePolyfills = (versions?: string[]) => {\n  if (isArr(versions)) {\n    versions.forEach((version) => {\n      if (isArr(polyfills[version])) {\n        polyfills[version].forEach((patch) => {\n          registerPatches(patch)\n        })\n      }\n    })\n  }\n}\n","import { registerPolyfills } from '../patches'\nimport { toArr, isArr, isStr, lowerCase, isValid } from '@formily/shared'\nimport { ISchema } from '../types'\n\nconst VOID_COMPONENTS = [\n  'card',\n  'block',\n  'grid-col',\n  'grid-row',\n  'grid',\n  'layout',\n  'step',\n  'tab',\n  'text-box',\n]\n\nconst TYPE_DEFAULT_COMPONENTS = {}\n\nconst transformCondition = (condition: string) => {\n  if (isStr(condition)) {\n    return condition.replace(/\\$value/, '$self.value')\n  }\n}\n\nconst transformXLinkage = (linkages: any[]) => {\n  if (isArr(linkages)) {\n    return linkages.reduce((buf, item) => {\n      if (!item) return buf\n      if (item.type === 'value:visible') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            state: {\n              visible: true,\n            },\n          },\n          otherwise: {\n            state: {\n              visible: false,\n            },\n          },\n        })\n      } else if (item.type === 'value:schema') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            schema: SpecificationV1Polyfill({ version: '1.0', ...item.schema }),\n          },\n          otherwise: {\n            schema: SpecificationV1Polyfill({\n              version: '1.0',\n              ...item.otherwise,\n            }),\n          },\n        })\n      } else if (item.type === 'value:state') {\n        return buf.concat({\n          target: item.target,\n          when: transformCondition(item.condition),\n          fulfill: {\n            state: item.state,\n          },\n          otherwise: {\n            state: item.otherwise,\n          },\n        })\n      }\n    }, [])\n  }\n  return []\n}\n\nconst SpecificationV1Polyfill = (schema: ISchema) => {\n  if (isValid(schema['editable'])) {\n    schema['x-editable'] = schema['x-editable'] || schema['editable']\n    delete schema['editable']\n  }\n  if (isValid(schema['visible'])) {\n    schema['x-visible'] = schema['x-visible'] || schema['visible']\n    delete schema['visible']\n  }\n  if (isValid(schema['display'])) {\n    schema['x-display'] =\n      schema['x-display'] || (schema['display'] ? 'visible' : 'hidden')\n    delete schema['display']\n  }\n  if (isValid(schema['x-props'])) {\n    schema['x-decorator-props'] =\n      schema['x-decorator-props'] || schema['x-props']\n    delete schema['display']\n  }\n  if (schema['x-linkages']) {\n    schema['x-reactions'] = toArr(schema['x-reactions']).concat(\n      transformXLinkage(schema['x-linkages'])\n    )\n    delete schema['x-linkages']\n  }\n  if (schema['x-component']) {\n    if (\n      VOID_COMPONENTS.some(\n        (component) => lowerCase(component) === lowerCase(schema['x-component'])\n      )\n    ) {\n      schema['type'] = 'void'\n    }\n  } else {\n    if (TYPE_DEFAULT_COMPONENTS[schema['type']]) {\n      schema['x-component'] = TYPE_DEFAULT_COMPONENTS[schema['type']]\n    }\n  }\n  if (\n    !schema['x-decorator'] &&\n    schema['type'] !== 'void' &&\n    schema['type'] !== 'object'\n  ) {\n    schema['x-decorator'] = schema['x-decorator'] || 'FormItem'\n  }\n  if (schema['x-rules']) {\n    schema['x-validator'] = []\n      .concat(schema['x-validator'] || [])\n      .concat(schema['x-rules'])\n  }\n  return schema\n}\n\nregisterPolyfills('1.0', SpecificationV1Polyfill)\n\nexport const registerVoidComponents = (components: string[]) => {\n  VOID_COMPONENTS.push(...components)\n}\n\nexport const registerTypeDefaultComponents = (maps: Record<string, string>) => {\n  Object.assign(TYPE_DEFAULT_COMPONENTS, maps)\n}\n","import {\n  ISchema,\n  SchemaEnum,\n  SchemaProperties,\n  SchemaReaction,\n  SchemaTypes,\n  SchemaKey,\n  ISchemaTransformerOptions,\n} from './types'\nimport { IFieldFactoryProps } from '@formily/core'\nimport { map, each, isFn, instOf, FormPath, isStr } from '@formily/shared'\nimport { compile, silent, shallowCompile, registerCompiler } from './compiler'\nimport { transformFieldProps } from './transformer'\nimport {\n  reducePatches,\n  registerPatches,\n  registerPolyfills,\n  enablePolyfills,\n} from './patches'\nimport {\n  registerVoidComponents,\n  registerTypeDefaultComponents,\n} from './polyfills'\nimport { SchemaNestedMap } from './shared'\n\nexport class Schema<\n  Decorator = any,\n  Component = any,\n  DecoratorProps = any,\n  ComponentProps = any,\n  Pattern = any,\n  Display = any,\n  Validator = any,\n  Message = any,\n  ReactionField = any\n> implements ISchema\n{\n  parent?: Schema\n  root?: Schema\n  name?: SchemaKey\n  title?: Message\n  description?: Message\n  default?: any\n  readOnly?: boolean\n  writeOnly?: boolean\n  type?: SchemaTypes\n  enum?: SchemaEnum<Message>\n  const?: any\n  multipleOf?: number\n  maximum?: number\n  exclusiveMaximum?: number\n  minimum?: number\n  exclusiveMinimum?: number\n  maxLength?: number\n  minLength?: number\n  pattern?: string | RegExp\n  maxItems?: number\n  minItems?: number\n  uniqueItems?: boolean\n  maxProperties?: number\n  minProperties?: number\n  required?: string[] | boolean | string\n  format?: string\n  /** nested json schema spec **/\n  definitions?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  properties?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  items?:\n    | Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >\n    | Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >[]\n  additionalItems?: Schema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n  patternProperties?: Record<\n    string,\n    Schema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  >\n  additionalProperties?: Schema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >;\n\n  //顺序描述\n  ['x-index']?: number;\n  //交互模式\n  ['x-pattern']?: Pattern;\n  //展示状态\n  ['x-display']?: Display;\n  //校验器\n  ['x-validator']?: Validator;\n  //装饰器\n  ['x-decorator']?: Decorator;\n  //装饰器属性\n  ['x-decorator-props']?: DecoratorProps;\n  //组件\n  ['x-component']?: Component;\n  //组件属性\n  ['x-component-props']?: ComponentProps;\n\n  ['x-reactions']?: SchemaReaction<ReactionField>[];\n\n  ['x-content']?: any;\n\n  ['x-data']?: any;\n\n  ['x-visible']?: boolean;\n\n  ['x-hidden']?: boolean;\n\n  ['x-disabled']?: boolean;\n\n  ['x-editable']?: boolean;\n\n  ['x-read-only']?: boolean;\n\n  ['x-read-pretty']?: boolean;\n\n  ['x-compile-omitted']?: string[];\n\n  [key: `x-${string | number}` | symbol]: any\n\n  _isJSONSchemaObject = true\n\n  version = '2.0'\n\n  constructor(\n    json: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >,\n    parent?: Schema\n  ) {\n    if (parent) {\n      this.parent = parent\n      this.root = parent.root\n    } else {\n      this.root = this\n    }\n    return this.fromJSON(json)\n  }\n\n  addProperty = (\n    key: SchemaKey,\n    schema: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    this.properties = this.properties || {}\n    this.properties[key] = new Schema(schema, this)\n    this.properties[key].name = key\n    return this.properties[key]\n  }\n\n  removeProperty = (key: SchemaKey) => {\n    const schema = this.properties[key]\n    delete this.properties[key]\n    return schema\n  }\n\n  setProperties = (\n    properties: SchemaProperties<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    for (const key in properties) {\n      this.addProperty(key, properties[key])\n    }\n    return this\n  }\n\n  addPatternProperty = (\n    key: SchemaKey,\n    schema: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!schema) return\n    this.patternProperties = this.patternProperties || {}\n    this.patternProperties[key] = new Schema(schema, this)\n    this.patternProperties[key].name = key\n    return this.patternProperties[key]\n  }\n\n  removePatternProperty = (key: SchemaKey) => {\n    const schema = this.patternProperties[key]\n    delete this.patternProperties[key]\n    return schema\n  }\n\n  setPatternProperties = (\n    properties: SchemaProperties<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!properties) return this\n    for (const key in properties) {\n      this.addPatternProperty(key, properties[key])\n    }\n    return this\n  }\n\n  setAdditionalProperties = (\n    properties: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!properties) return\n    this.additionalProperties = new Schema(properties)\n    return this.additionalProperties\n  }\n\n  setItems = (\n    schema:\n      | ISchema<\n          Decorator,\n          Component,\n          DecoratorProps,\n          ComponentProps,\n          Pattern,\n          Display,\n          Validator,\n          Message\n        >\n      | ISchema<\n          Decorator,\n          Component,\n          DecoratorProps,\n          ComponentProps,\n          Pattern,\n          Display,\n          Validator,\n          Message\n        >[]\n  ) => {\n    if (!schema) return\n    if (Array.isArray(schema)) {\n      this.items = schema.map((item) => new Schema(item, this))\n    } else {\n      this.items = new Schema(schema, this)\n    }\n    return this.items\n  }\n\n  setAdditionalItems = (\n    items: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!items) return\n    this.additionalItems = new Schema(items, this)\n    return this.additionalItems\n  }\n\n  findDefinitions = (ref: string) => {\n    if (!ref || !this.root || !isStr(ref)) return\n    if (ref.indexOf('#/') !== 0) return\n    return FormPath.getIn(this.root, ref.substring(2).split('/'))\n  }\n\n  mapProperties = <T>(\n    callback?: (\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => T\n  ): T[] => {\n    return Schema.getOrderProperties(this).map(({ schema, key }, index) => {\n      return callback(schema, key, index)\n    })\n  }\n\n  mapPatternProperties = <T>(\n    callback?: (\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => T\n  ): T[] => {\n    return Schema.getOrderProperties(this, 'patternProperties').map(\n      ({ schema, key }, index) => {\n        return callback(schema, key, index)\n      }\n    )\n  }\n\n  reduceProperties = <P, R>(\n    callback?: (\n      buffer: P,\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => R,\n    predicate?: P\n  ): R => {\n    let results: any = predicate\n    Schema.getOrderProperties(this, 'properties').forEach(\n      ({ schema, key }, index) => {\n        results = callback(results, schema, key, index)\n      }\n    )\n    return results\n  }\n\n  reducePatternProperties = <P, R>(\n    callback?: (\n      buffer: P,\n      schema: Schema<\n        Decorator,\n        Component,\n        DecoratorProps,\n        ComponentProps,\n        Pattern,\n        Display,\n        Validator,\n        Message\n      >,\n      key: SchemaKey,\n      index: number\n    ) => R,\n    predicate?: P\n  ): R => {\n    let results: any = predicate\n    Schema.getOrderProperties(this, 'patternProperties').forEach(\n      ({ schema, key }, index) => {\n        results = callback(results, schema, key, index)\n      }\n    )\n    return results\n  }\n\n  compile = (scope?: any) => {\n    const schema = new Schema({}, this.parent)\n    each(this, (value, key) => {\n      if (isFn(value) && !key.includes('x-')) return\n      if (key === 'parent' || key === 'root') return\n      if (!SchemaNestedMap[key]) {\n        schema[key] = value ? compile(value, scope) : value\n      } else {\n        schema[key] = value ? shallowCompile(value, scope) : value\n      }\n    })\n    return schema\n  }\n\n  fromJSON = (\n    json: ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  ) => {\n    if (!json) return this\n    if (Schema.isSchemaInstance(json)) return json\n    each(reducePatches(json), (value, key) => {\n      if (isFn(value) && !key.includes('x-')) return\n      if (key === 'properties') {\n        this.setProperties(value)\n      } else if (key === 'patternProperties') {\n        this.setPatternProperties(value)\n      } else if (key === 'additionalProperties') {\n        this.setAdditionalProperties(value)\n      } else if (key === 'items') {\n        this.setItems(value)\n      } else if (key === 'additionalItems') {\n        this.setAdditionalItems(value)\n      } else if (key === '$ref') {\n        this.fromJSON(this.findDefinitions(value))\n      } else {\n        this[key] = value\n      }\n    })\n    return this\n  }\n\n  toJSON = (\n    recursion = true\n  ): ISchema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  > => {\n    const results = {}\n    each(this, (value: any, key) => {\n      if (\n        (isFn(value) && !key.includes('x-')) ||\n        key === 'parent' ||\n        key === 'root'\n      )\n        return\n      if (key === 'properties' || key === 'patternProperties') {\n        if (!recursion) return\n        results[key] = map(value, (item) => item?.toJSON?.())\n      } else if (key === 'additionalProperties' || key === 'additionalItems') {\n        if (!recursion) return\n        results[key] = value?.toJSON?.()\n      } else if (key === 'items') {\n        if (!recursion) return\n        if (Array.isArray(value)) {\n          results[key] = value.map((item) => item?.toJSON?.())\n        } else {\n          results[key] = value?.toJSON?.()\n        }\n      } else {\n        results[key] = value\n      }\n    })\n    return results\n  }\n\n  toFieldProps = (\n    options?: ISchemaTransformerOptions\n  ): IFieldFactoryProps<any, any> => {\n    return transformFieldProps(this, options)\n  }\n\n  static getOrderProperties = (\n    schema: ISchema = {},\n    propertiesName: keyof ISchema = 'properties'\n  ) => {\n    const orderProperties = []\n    const unorderProperties = []\n    for (const key in schema[propertiesName]) {\n      const item = schema[propertiesName][key]\n      const index = item['x-index']\n      if (!isNaN(index)) {\n        orderProperties[index] = { schema: item, key }\n      } else {\n        unorderProperties.push({ schema: item, key })\n      }\n    }\n    return orderProperties.concat(unorderProperties).filter((item) => !!item)\n  }\n\n  static compile = (expression: any, scope?: any) => {\n    return compile(expression, scope)\n  }\n\n  static shallowCompile = (expression: any, scope?: any) => {\n    return shallowCompile(expression, scope)\n  }\n\n  static isSchemaInstance = (value: any): value is Schema => {\n    return instOf(value, Schema)\n  }\n\n  static registerCompiler = registerCompiler\n\n  static registerPatches = registerPatches\n\n  static registerVoidComponents = registerVoidComponents\n\n  static registerTypeDefaultComponents = registerTypeDefaultComponents\n\n  static registerPolyfills = registerPolyfills\n\n  static enablePolyfills = enablePolyfills\n\n  static silent = silent\n}\n"],"names":["REVA_ACTIONS_KEY","Symbol","for","SchemaNestedMap","parent","root","properties","patternProperties","additionalProperties","items","additionalItems","SchemaStateMap","title","description","default","enum","readOnly","writeOnly","SchemaValidatorMap","required","format","maxItems","minItems","maxLength","minLength","maximum","minimum","exclusiveMaximum","exclusiveMinimum","pattern","const","multipleOf","maxProperties","minProperties","uniqueItems","hasOwnProperty","Object","prototype","isNoNeedCompileObject","source","Schema","isSchemaInstance","Formily","Shared","isFn","Reactive","isObservable","patchStateFormSchema","targetState","compiled","untracked","segments","FormPath","parse","key","isArr","schemaMapKey","setIn","concat","slice","isEnum","toArr","map","item","label","value","ExpRE","Registry","silent","compile","expression","scope","Function","_a","registerCompiler","compiler","shallowCompile","isStr","matched","isPlainObj","addIndex","seenObjects","length","push","reduce","buf","splice","results","patchCompile","sourceState","target","visitor","traverse","path","each","patchSchemaCompile","sourceSchema","demand","schema","undefined","String","indexOf","hasCollected","collected","initialized","FieldEffects","onFieldInit","Core","onFieldMount","onFieldUnmount","onFieldValueChange","onFieldInputValueChange","onFieldInitialValueChange","onFieldValidateStart","onFieldValidateEnd","onFieldValidateFailed","onFieldValidateSuccess","DefaultFieldEffects","getDependencyValue","field","property","__read","split","query","getIn","setSchemaFieldState","options","request","runner","lazyMerge","$target","state","setState","getBaseScope","$effect","autorun","effect","$memo","memo","$form","form","$values","values","$lookup","_b","$record","$records","record","$index","$self","$observable","deps","observable","$props","props","setComponentProps","getBaseReactions","getUserReactions","unCompiled","reaction","baseScope","run","dependencies","forEach","name","results_1","$deps","$dependencies","effects","type","patches","polyfills","registerPatches","args","patch","registerPolyfills","version","enablePolyfills","versions","VOID_COMPONENTS","TYPE_DEFAULT_COMPONENTS","transformCondition","condition","SpecificationV1Polyfill","linkages","isValid","when","fulfill","visible","otherwise","some","component","lowerCase","registerVoidComponents","components","apply","__spreadArray","registerTypeDefaultComponents","maps","assign","this","addProperty","_this","addPatternProperty","Array","isArray","ref","substring","getOrderProperties","index","reduceProperties","callback","predicate","reducePatternProperties","includes","json","setProperties","setPatternProperties","setAdditionalProperties","setItems","setAdditionalItems","recursion","toJSON","call","reactions","transformFieldProps","fromJSON","propertiesName","isNaN","unorderProperties","orderProperties","filter","instOf"],"mappings":"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"}