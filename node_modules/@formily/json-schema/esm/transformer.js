var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { untracked, autorun, observable } from '@formily/reactive';
import { isArr, isStr, toArr, each, isFn, isPlainObj, reduce, lazyMerge, } from '@formily/shared';
import { onFieldInit, onFieldMount, onFieldUnmount, onFieldValueChange, onFieldInputValueChange, onFieldInitialValueChange, onFieldValidateStart, onFieldValidateEnd, onFieldValidateFailed, onFieldValidateSuccess, } from '@formily/core';
import { patchCompile, patchSchemaCompile, shallowCompile } from './compiler';
var FieldEffects = {
    onFieldInit: onFieldInit,
    onFieldMount: onFieldMount,
    onFieldUnmount: onFieldUnmount,
    onFieldValueChange: onFieldValueChange,
    onFieldInputValueChange: onFieldInputValueChange,
    onFieldInitialValueChange: onFieldInitialValueChange,
    onFieldValidateStart: onFieldValidateStart,
    onFieldValidateEnd: onFieldValidateEnd,
    onFieldValidateFailed: onFieldValidateFailed,
    onFieldValidateSuccess: onFieldValidateSuccess,
};
var DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange'];
var getDependencyValue = function (field, pattern, property) {
    var _a = __read(String(pattern).split(/\s*#\s*/), 2), target = _a[0], path = _a[1];
    return field.query(target).getIn(path || property || 'value');
};
var getDependencies = function (field, dependencies) {
    if (isArr(dependencies)) {
        var results_1 = [];
        dependencies.forEach(function (pattern) {
            if (isStr(pattern)) {
                results_1.push(getDependencyValue(field, pattern));
            }
            else if (isPlainObj(pattern)) {
                if (pattern.name && pattern.source) {
                    results_1[pattern.name] = getDependencyValue(field, pattern.source, pattern.property);
                }
            }
        });
        return results_1;
    }
    else if (isPlainObj(dependencies)) {
        return reduce(dependencies, function (buf, pattern, key) {
            buf[key] = getDependencyValue(field, pattern);
            return buf;
        }, {});
    }
    return [];
};
var setSchemaFieldState = function (options, demand) {
    if (demand === void 0) { demand = false; }
    var _a = options || {}, request = _a.request, target = _a.target, runner = _a.runner, field = _a.field, scope = _a.scope;
    if (!request)
        return;
    if (target) {
        if (request.state) {
            field.form.setFieldState(target, function (state) {
                return patchCompile(state, request.state, lazyMerge(scope, {
                    $target: state,
                }));
            });
        }
        if (request.schema) {
            field.form.setFieldState(target, function (state) {
                return patchSchemaCompile(state, request.schema, lazyMerge(scope, {
                    $target: state,
                }), demand);
            });
        }
        if (isStr(runner) && runner) {
            field.form.setFieldState(target, function (state) {
                shallowCompile("{{function(){".concat(runner, "}}}"), lazyMerge(scope, {
                    $target: state,
                }))();
            });
        }
    }
    else {
        if (request.state) {
            field.setState(function (state) { return patchCompile(state, request.state, scope); });
        }
        if (request.schema) {
            field.setState(function (state) {
                return patchSchemaCompile(state, request.schema, scope, demand);
            });
        }
        if (isStr(runner) && runner) {
            shallowCompile("{{function(){".concat(runner, "}}}"), scope)();
        }
    }
};
var getBaseScope = function (field, options) {
    if (options === void 0) { options = {}; }
    var $observable = function (target, deps) {
        return autorun.memo(function () { return observable(target); }, deps);
    };
    var $props = function (props) { return field.setComponentProps(props); };
    var $effect = autorun.effect;
    var $memo = autorun.memo;
    var $self = field;
    var $form = field.form;
    var $values = field.form.values;
    return lazyMerge({
        get $lookup() {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.scope) === null || _a === void 0 ? void 0 : _a.$record) !== null && _b !== void 0 ? _b : $values;
        },
        get $records() {
            return field.records;
        },
        get $record() {
            var record = field.record;
            if (typeof record === 'object') {
                return lazyMerge(record, {
                    get $lookup() {
                        var _a, _b;
                        return (_b = (_a = options === null || options === void 0 ? void 0 : options.scope) === null || _a === void 0 ? void 0 : _a.$record) !== null && _b !== void 0 ? _b : $values;
                    },
                    get $index() {
                        return field.index;
                    },
                });
            }
            return record;
        },
        get $index() {
            return field.index;
        },
    }, options.scope, {
        $form: $form,
        $self: $self,
        $observable: $observable,
        $effect: $effect,
        $memo: $memo,
        $props: $props,
        $values: $values,
    });
};
var getBaseReactions = function (schema, options) { return function (field) {
    setSchemaFieldState({
        field: field,
        request: { schema: schema },
        scope: getBaseScope(field, options),
    }, true);
}; };
var getUserReactions = function (schema, options) {
    var reactions = toArr(schema['x-reactions']);
    return reactions.map(function (unCompiled) {
        return function (field) {
            var baseScope = getBaseScope(field, options);
            var reaction = shallowCompile(unCompiled, baseScope);
            if (!reaction)
                return;
            if (isFn(reaction)) {
                return reaction(field, baseScope);
            }
            var when = reaction.when, fulfill = reaction.fulfill, otherwise = reaction.otherwise, target = reaction.target, effects = reaction.effects;
            var run = function () {
                var $deps = getDependencies(field, reaction.dependencies);
                var $dependencies = $deps;
                var scope = lazyMerge(baseScope, {
                    $target: null,
                    $deps: $deps,
                    $dependencies: $dependencies,
                });
                var compiledWhen = shallowCompile(when, scope);
                var condition = when ? compiledWhen : true;
                var request = condition ? fulfill : otherwise;
                var runner = request === null || request === void 0 ? void 0 : request.run;
                setSchemaFieldState({
                    field: field,
                    target: target,
                    request: request,
                    runner: runner,
                    scope: scope,
                });
            };
            if (target) {
                reaction.effects = (effects === null || effects === void 0 ? void 0 : effects.length) ? effects : DefaultFieldEffects;
            }
            if (reaction.effects) {
                autorun.memo(function () {
                    untracked(function () {
                        each(reaction.effects, function (type) {
                            if (FieldEffects[type]) {
                                FieldEffects[type](field.address, run);
                            }
                        });
                    });
                }, []);
            }
            else {
                run();
            }
        };
    });
};
export var transformFieldProps = function (schema, options) {
    return {
        name: schema.name,
        reactions: [getBaseReactions(schema, options)].concat(getUserReactions(schema, options)),
    };
};
//# sourceMappingURL=transformer.js.map