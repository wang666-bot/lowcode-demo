{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import {\n  IGeneralFieldState,\n  GeneralField,\n  FormPathPattern,\n} from '@formily/core'\nexport type SchemaEnum<Message> = Array<\n  | string\n  | number\n  | boolean\n  | { label?: Message; value?: any; [key: string]: any }\n  | { key?: any; title?: Message; [key: string]: any }\n>\n\nexport type SchemaTypes =\n  | 'string'\n  | 'object'\n  | 'array'\n  | 'number'\n  | 'boolean'\n  | 'void'\n  | 'date'\n  | 'datetime'\n  | (string & {})\n\nexport type SchemaProperties<\n  Decorator,\n  Component,\n  DecoratorProps,\n  ComponentProps,\n  Pattern,\n  Display,\n  Validator,\n  Message\n> = Record<\n  string,\n  ISchema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n>\n\nexport type SchemaPatch = (schema: ISchema) => ISchema\n\nexport type SchemaKey = string | number\n\nexport type SchemaEffectTypes =\n  | 'onFieldInit'\n  | 'onFieldMount'\n  | 'onFieldUnmount'\n  | 'onFieldValueChange'\n  | 'onFieldInputValueChange'\n  | 'onFieldInitialValueChange'\n  | 'onFieldValidateStart'\n  | 'onFieldValidateEnd'\n  | 'onFieldValidateFailed'\n  | 'onFieldValidateSuccess'\n\nexport type SchemaReaction<Field = any> =\n  | {\n      dependencies?:\n        | Array<\n            | string\n            | {\n                name?: string\n                type?: string\n                source?: string\n                property?: string\n              }\n          >\n        | Record<string, string>\n      when?: string | boolean\n      target?: string\n      effects?: (SchemaEffectTypes | (string & {}))[]\n      fulfill?: {\n        state?: Stringify<IGeneralFieldState>\n        schema?: ISchema\n        run?: string\n      }\n      otherwise?: {\n        state?: Stringify<IGeneralFieldState>\n        schema?: ISchema\n        run?: string\n      }\n      [key: string]: any\n    }\n  | ((field: Field, scope: IScopeContext) => void)\n\nexport type SchemaReactions<Field = any> =\n  | SchemaReaction<Field>\n  | SchemaReaction<Field>[]\n\nexport type SchemaItems<\n  Decorator,\n  Component,\n  DecoratorProps,\n  ComponentProps,\n  Pattern,\n  Display,\n  Validator,\n  Message\n> =\n  | ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >\n  | ISchema<\n      Decorator,\n      Component,\n      DecoratorProps,\n      ComponentProps,\n      Pattern,\n      Display,\n      Validator,\n      Message\n    >[]\n\nexport type SchemaComponents = Record<string, any>\n\nexport interface ISchemaFieldUpdateRequest {\n  state?: Stringify<IGeneralFieldState>\n  schema?: ISchema\n  run?: string\n}\n\nexport interface IScopeContext {\n  [key: string]: any\n}\n\nexport interface IFieldStateSetterOptions {\n  field: GeneralField\n  target?: FormPathPattern\n  request: ISchemaFieldUpdateRequest\n  runner?: string\n  scope?: IScopeContext\n}\n\nexport interface ISchemaTransformerOptions {\n  scope?: IScopeContext\n}\n\nexport type Stringify<P extends { [key: string]: any }> = {\n  /**\n   * Use `string & {}` instead of string to keep Literal Type for ISchema#component and ISchema#decorator\n   */\n  [key in keyof P]?: P[key] | (string & {})\n}\n\nexport type ISchema<\n  Decorator = any,\n  Component = any,\n  DecoratorProps = any,\n  ComponentProps = any,\n  Pattern = any,\n  Display = any,\n  Validator = any,\n  Message = any,\n  ReactionField = any\n> = Stringify<{\n  version?: string\n  name?: SchemaKey\n  title?: Message\n  description?: Message\n  default?: any\n  readOnly?: boolean\n  writeOnly?: boolean\n  type?: SchemaTypes\n  enum?: SchemaEnum<Message>\n  const?: any\n  multipleOf?: number\n  maximum?: number\n  exclusiveMaximum?: number\n  minimum?: number\n  exclusiveMinimum?: number\n  maxLength?: number\n  minLength?: number\n  pattern?: string | RegExp\n  maxItems?: number\n  minItems?: number\n  uniqueItems?: boolean\n  maxProperties?: number\n  minProperties?: number\n  required?: string[] | boolean | string\n  format?: string\n  $ref?: string\n  $namespace?: string\n  /** nested json schema spec **/\n  definitions?: SchemaProperties<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n  properties?: SchemaProperties<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n  items?: SchemaItems<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n  additionalItems?: ISchema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n  patternProperties?: SchemaProperties<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n  additionalProperties?: ISchema<\n    Decorator,\n    Component,\n    DecoratorProps,\n    ComponentProps,\n    Pattern,\n    Display,\n    Validator,\n    Message\n  >\n\n  ['x-value']?: any\n\n  //顺序描述\n  ['x-index']?: number\n  //交互模式\n  ['x-pattern']?: Pattern\n  //展示状态\n  ['x-display']?: Display\n  //校验器\n  ['x-validator']?: Validator\n  //装饰器\n  ['x-decorator']?: Decorator | (string & {}) | ((...args: any[]) => any)\n  //装饰器属性\n  ['x-decorator-props']?: DecoratorProps\n  //组件\n  ['x-component']?: Component | (string & {}) | ((...args: any[]) => any)\n  //组件属性\n  ['x-component-props']?: ComponentProps\n  //组件响应器\n  ['x-reactions']?: SchemaReactions<ReactionField>\n  //内容\n  ['x-content']?: any\n\n  ['x-data']?: any\n\n  ['x-visible']?: boolean\n\n  ['x-hidden']?: boolean\n\n  ['x-disabled']?: boolean\n\n  ['x-editable']?: boolean\n\n  ['x-read-only']?: boolean\n\n  ['x-read-pretty']?: boolean\n\n  ['x-compile-omitted']?: string[]\n\n  [key: `x-${string | number}` | symbol]: any\n}>\n"]}