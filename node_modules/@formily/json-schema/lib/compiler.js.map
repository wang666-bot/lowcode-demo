{"version":3,"file":"compiler.js","sourceRoot":"","sources":["../src/compiler.ts"],"names":[],"mappings":";;;AAAA,0CAOwB;AAExB,8CAA2D;AAC3D,mCAMiB;AAGjB,IAAM,KAAK,GAAG,2BAA2B,CAAA;AACzC,IAAM,QAAQ,GAAG;IACf,MAAM,EAAE,KAAK;IACb,OAAO,EAAP,UAAQ,UAAkB,EAAE,KAAU;QAAV,sBAAA,EAAA,UAAU;QACpC,IAAI,QAAQ,CAAC,MAAM,EAAE;YACnB,IAAI;gBACF,OAAO,IAAI,QAAQ,CAAC,OAAO,EAAE,gCAAyB,UAAU,SAAM,CAAC,CACrE,KAAK,CACN,CAAA;aACF;YAAC,WAAM,GAAE;SACX;aAAM;YACL,OAAO,IAAI,QAAQ,CAAC,OAAO,EAAE,gCAAyB,UAAU,SAAM,CAAC,CACrE,KAAK,CACN,CAAA;SACF;IACH,CAAC;CACF,CAAA;AAEM,IAAM,MAAM,GAAG,UAAC,KAAY;IAAZ,sBAAA,EAAA,YAAY;IACjC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAA;AAC3B,CAAC,CAAA;AAFY,QAAA,MAAM,UAElB;AAEM,IAAM,gBAAgB,GAAG,UAC9B,QAAiD;IAEjD,IAAI,IAAA,aAAI,EAAC,QAAQ,CAAC,EAAE;QAClB,QAAQ,CAAC,OAAO,GAAG,QAAQ,CAAA;KAC5B;AACH,CAAC,CAAA;AANY,QAAA,gBAAgB,oBAM5B;AAEM,IAAM,cAAc,GAAG,UAC5B,MAAc,EACd,KAAa;IAEb,IAAI,IAAA,cAAK,EAAC,MAAM,CAAC,EAAE;QACjB,IAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;QACnC,IAAI,CAAC,OAAO;YAAE,OAAO,MAAM,CAAA;QAC3B,OAAO,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAA;KAC3C;IACD,OAAO,MAAM,CAAA;AACf,CAAC,CAAA;AAVY,QAAA,cAAc,kBAU1B;AAEM,IAAM,OAAO,GAAG,UACrB,MAAc,EACd,KAAa;IAEb,IAAM,WAAW,GAAG,EAAE,CAAA;IACtB,IAAM,OAAO,GAAG,UAAC,MAAW;QAC1B,IAAI,IAAA,cAAK,EAAC,MAAM,CAAC,EAAE;YACjB,OAAO,IAAA,sBAAc,EAAC,MAAM,EAAE,KAAK,CAAC,CAAA;SACrC;aAAM,IAAI,IAAA,cAAK,EAAC,MAAM,CAAC,EAAE;YACxB,OAAO,MAAM,CAAC,GAAG,CAAC,UAAC,KAAU,IAAK,OAAA,OAAO,CAAC,KAAK,CAAC,EAAd,CAAc,CAAC,CAAA;SAClD;aAAM,IAAI,IAAA,mBAAU,EAAC,MAAM,CAAC,EAAE;YAC7B,IAAI,IAAA,8BAAqB,EAAC,MAAM,CAAC;gBAAE,OAAO,MAAM,CAAA;YAChD,IAAM,SAAS,GAAG,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA;YAC7C,IAAI,SAAS,GAAG,CAAC,CAAC,EAAE;gBAClB,OAAO,MAAM,CAAA;aACd;YACD,IAAM,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAA;YACnC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;YACxB,IAAM,OAAO,GAAG,IAAA,eAAM,EACpB,MAAM,EACN,UAAC,GAAG,EAAE,KAAK,EAAE,GAAG;gBACd,GAAG,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,CAAA;gBACzB,OAAO,GAAG,CAAA;YACZ,CAAC,EACD,EAAE,CACH,CAAA;YACD,WAAW,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAA;YAC/B,OAAO,OAAO,CAAA;SACf;QACD,OAAO,MAAM,CAAA;IACf,CAAC,CAAA;IACD,OAAO,OAAO,CAAC,MAAM,CAAC,CAAA;AACxB,CAAC,CAAA;AAhCY,QAAA,OAAO,WAgCnB;AAEM,IAAM,YAAY,GAAG,UAC1B,WAA+B,EAC/B,WAAgB,EAChB,KAAU;IAEV,IAAA,iBAAQ,EAAC,WAAW,EAAE,UAAC,KAAK,EAAE,OAAO;QACnC,IAAM,QAAQ,GAAG,IAAA,eAAO,EAAC,KAAK,EAAE,KAAK,CAAC,CAAA;QACtC,IAAI,QAAQ,KAAK,SAAS;YAAE,OAAM;QAClC,IAAM,IAAI,GAAG,iBAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;QACpC,IAAM,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;QAC5B,IAAI,uBAAc,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG,CAAC,EAAE;YACzC,IAAA,oBAAS,EAAC,cAAM,OAAA,iBAAQ,CAAC,KAAK,CAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,EAA3C,CAA2C,CAAC,CAAA;SAC7D;IACH,CAAC,CAAC,CAAA;AACJ,CAAC,CAAA;AAdY,QAAA,YAAY,gBAcxB;AAEM,IAAM,kBAAkB,GAAG,UAChC,WAA+B,EAC/B,YAAqB,EACrB,KAAU,EACV,MAAc;IAAd,uBAAA,EAAA,cAAc;IAEd,IAAA,uBAAc,EAAC,YAAY,EAAE,UAAC,KAAK,EAAE,IAAI,EAAE,WAAW;QACpD,IAAI,QAAQ,GAAG,KAAK,CAAA;QACpB,IAAI,SAAS,GAAG,IAAA,uBAAY,EAAC;YAC3B,IAAI,CAAC,WAAW,EAAE;gBAChB,QAAQ,GAAG,IAAA,eAAO,EAAC,KAAK,EAAE,KAAK,CAAC,CAAA;aACjC;QACH,CAAC,CAAC,CAAA;QACF,IAAI,QAAQ,KAAK,SAAS;YAAE,OAAM;QAClC,IAAI,MAAM,EAAE;YACV,IAAI,SAAS,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE;gBACzC,IAAA,6BAAoB,EAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAA;aAClD;SACF;aAAM;YACL,IAAA,6BAAoB,EAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAA;SAClD;IACH,CAAC,CAAC,CAAA;AACJ,CAAC,CAAA;AAtBY,QAAA,kBAAkB,sBAsB9B","sourcesContent":["import {\n  isArr,\n  isFn,\n  isPlainObj,\n  isStr,\n  reduce,\n  FormPath,\n} from '@formily/shared'\nimport { IGeneralFieldState } from '@formily/core'\nimport { untracked, hasCollected } from '@formily/reactive'\nimport {\n  traverse,\n  traverseSchema,\n  isNoNeedCompileObject,\n  hasOwnProperty,\n  patchStateFormSchema,\n} from './shared'\nimport { ISchema } from './types'\n\nconst ExpRE = /^\\s*\\{\\{([\\s\\S]*)\\}\\}\\s*$/\nconst Registry = {\n  silent: false,\n  compile(expression: string, scope = {}) {\n    if (Registry.silent) {\n      try {\n        return new Function('$root', `with($root) { return (${expression}); }`)(\n          scope\n        )\n      } catch {}\n    } else {\n      return new Function('$root', `with($root) { return (${expression}); }`)(\n        scope\n      )\n    }\n  },\n}\n\nexport const silent = (value = true) => {\n  Registry.silent = !!value\n}\n\nexport const registerCompiler = (\n  compiler: (expression: string, scope: any) => any\n) => {\n  if (isFn(compiler)) {\n    Registry.compile = compiler\n  }\n}\n\nexport const shallowCompile = <Source = any, Scope = any>(\n  source: Source,\n  scope?: Scope\n) => {\n  if (isStr(source)) {\n    const matched = source.match(ExpRE)\n    if (!matched) return source\n    return Registry.compile(matched[1], scope)\n  }\n  return source\n}\n\nexport const compile = <Source = any, Scope = any>(\n  source: Source,\n  scope?: Scope\n): any => {\n  const seenObjects = []\n  const compile = (source: any) => {\n    if (isStr(source)) {\n      return shallowCompile(source, scope)\n    } else if (isArr(source)) {\n      return source.map((value: any) => compile(value))\n    } else if (isPlainObj(source)) {\n      if (isNoNeedCompileObject(source)) return source\n      const seenIndex = seenObjects.indexOf(source)\n      if (seenIndex > -1) {\n        return source\n      }\n      const addIndex = seenObjects.length\n      seenObjects.push(source)\n      const results = reduce(\n        source,\n        (buf, value, key) => {\n          buf[key] = compile(value)\n          return buf\n        },\n        {}\n      )\n      seenObjects.splice(addIndex, 1)\n      return results\n    }\n    return source\n  }\n  return compile(source)\n}\n\nexport const patchCompile = (\n  targetState: IGeneralFieldState,\n  sourceState: any,\n  scope: any\n) => {\n  traverse(sourceState, (value, pattern) => {\n    const compiled = compile(value, scope)\n    if (compiled === undefined) return\n    const path = FormPath.parse(pattern)\n    const key = path.segments[0]\n    if (hasOwnProperty.call(targetState, key)) {\n      untracked(() => FormPath.setIn(targetState, path, compiled))\n    }\n  })\n}\n\nexport const patchSchemaCompile = (\n  targetState: IGeneralFieldState,\n  sourceSchema: ISchema,\n  scope: any,\n  demand = false\n) => {\n  traverseSchema(sourceSchema, (value, path, omitCompile) => {\n    let compiled = value\n    let collected = hasCollected(() => {\n      if (!omitCompile) {\n        compiled = compile(value, scope)\n      }\n    })\n    if (compiled === undefined) return\n    if (demand) {\n      if (collected || !targetState.initialized) {\n        patchStateFormSchema(targetState, path, compiled)\n      }\n    } else {\n      patchStateFormSchema(targetState, path, compiled)\n    }\n  })\n}\n"]}