{"version":3,"file":"useForceUpdate.js","sourceRoot":"","sources":["../../src/hooks/useForceUpdate.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAA;AACrD,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAA;AACnD,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAA;AAE7C,IAAM,WAAW,GAAU,EAAE,CAAA;AAC7B,IAAM,YAAY,GAAG,EAAE,KAAK,EAAE,CAAC,EAAE,CAAA;AACjC,IAAM,YAAY,GAAG,IAAI,GAAG,EAAc,CAAA;AAE1C,MAAM,UAAU,cAAc;IACtB,IAAA,KAAA,OAAe,QAAQ,CAAC,EAAE,CAAC,IAAA,EAAxB,QAAQ,QAAgB,CAAA;IACjC,IAAM,gBAAgB,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA;IACtC,IAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA;IACnC,eAAe,CAAC;QACd,gBAAgB,CAAC,OAAO,GAAG,IAAI,CAAA;QAC/B,IAAI,aAAa,CAAC,OAAO,EAAE;YACzB,QAAQ,CAAC,EAAE,CAAC,CAAA;YACZ,aAAa,CAAC,OAAO,GAAG,KAAK,CAAA;SAC9B;QACD,OAAO;YACL,gBAAgB,CAAC,OAAO,GAAG,KAAK,CAAA;QAClC,CAAC,CAAA;IACH,CAAC,EAAE,WAAW,CAAC,CAAA;IAEf,IAAM,MAAM,GAAG,WAAW,CAAC;QACzB,QAAQ,CAAC,EAAE,CAAC,CAAA;IACd,CAAC,EAAE,WAAW,CAAC,CAAA;IAEf,IAAM,SAAS,GAAG,WAAW,CAAC;QAC5B,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE;YAC7B,+CAA+C;YAC/C,mDAAmD;YACnD,aAAa,CAAC,OAAO,GAAG,IAAI,CAAA;YAC5B,OAAM;SACP;QACD,IAAI,YAAY,CAAC,KAAK,KAAK,CAAC,EAAE;YAC5B,MAAM,EAAE,CAAA;SACT;aAAM;YACL,YAAY,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;SACzB;IACH,CAAC,EAAE,WAAW,CAAC,CAAA;IAEf,YAAY,CAAC,KAAK,EAAE,CAAA;IAEpB,YAAY,CAAC;QACX,IAAI,YAAY,CAAC,KAAK,GAAG,CAAC,EAAE;YAC1B,YAAY,CAAC,KAAK,EAAE,CAAA;SACrB;QACD,IAAI,YAAY,CAAC,KAAK,KAAK,CAAC,EAAE;YAC5B,YAAY,CAAC,OAAO,CAAC,UAAC,MAAM;gBAC1B,YAAY,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;gBAC3B,MAAM,EAAE,CAAA;YACV,CAAC,CAAC,CAAA;SACH;IACH,CAAC,CAAC,CAAA;IAEF,OAAO,SAAS,CAAA;AAClB,CAAC","sourcesContent":["import { useCallback, useRef, useState } from 'react'\nimport { useLayoutEffect } from './useLayoutEffect'\nimport { useDidUpdate } from './useDidUpdate'\n\nconst EMPTY_ARRAY: any[] = []\nconst RENDER_COUNT = { value: 0 }\nconst RENDER_QUEUE = new Set<() => void>()\n\nexport function useForceUpdate() {\n  const [, setState] = useState([])\n  const firstRenderedRef = useRef(false)\n  const needUpdateRef = useRef(false)\n  useLayoutEffect(() => {\n    firstRenderedRef.current = true\n    if (needUpdateRef.current) {\n      setState([])\n      needUpdateRef.current = false\n    }\n    return () => {\n      firstRenderedRef.current = false\n    }\n  }, EMPTY_ARRAY)\n\n  const update = useCallback(() => {\n    setState([])\n  }, EMPTY_ARRAY)\n\n  const scheduler = useCallback(() => {\n    if (!firstRenderedRef.current) {\n      // 针对StrictMode无法快速回收内存，只能考虑拦截第一次渲染函数的setState，\n      // 因为第一次渲染函数的setState会触发第二次渲染函数执行，从而清理掉第二次渲染函数内部的依赖\n      needUpdateRef.current = true\n      return\n    }\n    if (RENDER_COUNT.value === 0) {\n      update()\n    } else {\n      RENDER_QUEUE.add(update)\n    }\n  }, EMPTY_ARRAY)\n\n  RENDER_COUNT.value++\n\n  useDidUpdate(() => {\n    if (RENDER_COUNT.value > 0) {\n      RENDER_COUNT.value--\n    }\n    if (RENDER_COUNT.value === 0) {\n      RENDER_QUEUE.forEach((update) => {\n        RENDER_QUEUE.delete(update)\n        update()\n      })\n    }\n  })\n\n  return scheduler\n}\n"]}