{"version":3,"file":"computed.js","sourceRoot":"","sources":["../../src/annotations/computed.ts"],"names":[],"mappings":"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","sourcesContent":["import { ObModelSymbol, ReactionStack } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport { isFn } from '../checkers'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n  bindComputedReactions,\n  hasRunningReaction,\n  isUntracking,\n  batchStart,\n  batchEnd,\n  releaseBindingReactions,\n} from '../reaction'\n\ninterface IValue<T = any> {\n  value?: T\n}\nexport interface IComputed {\n  <T>(compute: () => T): IValue<T>\n  <T>(compute: { get?: () => T; set?: (value: T) => void }): IValue<T>\n}\n\nconst getDescriptor = Object.getOwnPropertyDescriptor\n\nconst getProto = Object.getPrototypeOf\n\nconst ClassDescriptorSymbol = Symbol('ClassDescriptorSymbol')\n\nfunction getPropertyDescriptor(obj: any, key: PropertyKey) {\n  if (!obj) return\n  return getDescriptor(obj, key) || getPropertyDescriptor(getProto(obj), key)\n}\n\nfunction getPropertyDescriptorCache(obj: any, key: PropertyKey) {\n  const constructor = obj.constructor\n  if (constructor === Object || constructor === Array)\n    return getPropertyDescriptor(obj, key)\n  const cache = constructor[ClassDescriptorSymbol] || {}\n  const descriptor = cache[key]\n  if (descriptor) return descriptor\n  const newDesc = getPropertyDescriptor(obj, key)\n  constructor[ClassDescriptorSymbol] = cache\n  cache[key] = newDesc\n  return newDesc\n}\n\nfunction getPrototypeDescriptor(\n  target: any,\n  key: PropertyKey,\n  value: any\n): PropertyDescriptor {\n  if (!target) {\n    if (value) {\n      if (isFn(value)) {\n        return { get: value }\n      } else {\n        return value\n      }\n    }\n    return {}\n  }\n  const descriptor = getPropertyDescriptorCache(target, key)\n  if (descriptor) {\n    return descriptor\n  }\n  return {}\n}\n\nexport const computed: IComputed = createAnnotation(\n  ({ target, key, value }) => {\n    const store: IValue = {}\n\n    const proxy = {}\n\n    const context = target ? target : store\n    const property = target ? key : 'value'\n    const descriptor = getPrototypeDescriptor(target, property, value)\n\n    function compute() {\n      store.value = descriptor.get?.call(context)\n    }\n    function reaction() {\n      if (ReactionStack.indexOf(reaction) === -1) {\n        releaseBindingReactions(reaction)\n        try {\n          ReactionStack.push(reaction)\n          compute()\n        } finally {\n          ReactionStack.pop()\n        }\n      }\n    }\n    reaction._name = 'ComputedReaction'\n    reaction._scheduler = () => {\n      reaction._dirty = true\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        value: store.value,\n        type: 'set',\n      })\n    }\n    reaction._isComputed = true\n    reaction._dirty = true\n    reaction._context = context\n    reaction._property = property\n\n    function get() {\n      if (hasRunningReaction()) {\n        bindComputedReactions(reaction)\n      }\n      if (!isUntracking()) {\n        //如果允许untracked过程中收集依赖，那么永远不会存在绑定，因为_dirty已经设置为false\n        if (reaction._dirty) {\n          reaction()\n          reaction._dirty = false\n        }\n      } else {\n        compute()\n      }\n      bindTargetKeyWithCurrentReaction({\n        target: context,\n        key: property,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      try {\n        batchStart()\n        descriptor.set?.call(context, value)\n      } finally {\n        batchEnd()\n      }\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        get,\n        set,\n        enumerable: true,\n      })\n      return target\n    } else {\n      Object.defineProperty(proxy, 'value', {\n        set,\n        get,\n      })\n      buildDataTree(target, key, store)\n      proxy[ObModelSymbol] = store\n    }\n    return proxy\n  }\n)\n"]}