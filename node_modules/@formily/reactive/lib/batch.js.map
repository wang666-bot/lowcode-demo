{"version":3,"file":"batch.js","sourceRoot":"","sources":["../src/batch.ts"],"names":[],"mappings":";;;AAAA,uCAKmB;AACnB,6CAA0D;AAC1D,yCAAsD;AAEtD,uCAAiC;AAEpB,QAAA,KAAK,GAAW,IAAA,oCAAwB,EAAC,qBAAU,EAAE,mBAAQ,CAAC,CAAA;AAC3E,aAAK,CAAC,KAAK,GAAG,IAAA,oCAAwB,EAAC,0BAAe,EAAE,wBAAa,CAAC,CAAA;AACtE,aAAK,CAAC,QAAQ,GAAG,UAAC,QAAqB;IACrC,IAAI,CAAC,IAAA,eAAI,EAAC,QAAQ,CAAC;QAAE,OAAM;IAC3B,IAAI,wBAAU,CAAC,KAAK,KAAK,CAAC,EAAE;QAC1B,QAAQ,EAAE,CAAA;KACX;SAAM;QACL,4BAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;KAC7B;AACH,CAAC,CAAA","sourcesContent":["import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n} from './reaction'\nimport { BatchEndpoints, BatchCount } from './environment'\nimport { createBoundaryAnnotation } from './internals'\nimport { IBatch } from './types'\nimport { isFn } from './checkers'\n\nexport const batch: IBatch = createBoundaryAnnotation(batchStart, batchEnd)\nbatch.scope = createBoundaryAnnotation(batchScopeStart, batchScopeEnd)\nbatch.endpoint = (callback?: () => void) => {\n  if (!isFn(callback)) return\n  if (BatchCount.value === 0) {\n    callback()\n  } else {\n    BatchEndpoints.add(callback)\n  }\n}\n"]}