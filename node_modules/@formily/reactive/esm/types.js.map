{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"AAEA,cAAc,QAAQ,CAAA","sourcesContent":["import { ArraySet } from './array'\n\nexport * from './tree'\n\nexport type PropertyKey = string | number | symbol\n\nexport type OperationType =\n  | 'add'\n  | 'delete'\n  | 'clear'\n  | 'set'\n  | 'get'\n  | 'iterate'\n  | 'has'\nexport interface IOperation {\n  target?: any\n  oldTarget?: any\n  key?: PropertyKey\n  value?: any\n  oldValue?: any\n  type?: OperationType\n  receiver?: any\n}\n\nexport interface IChange {\n  key?: PropertyKey\n  path?: ObservablePath\n  value?: any\n  oldValue?: any\n  type?: OperationType\n}\n\nexport interface IEffectQueueItem {\n  dispose?: void | Dispose\n  deps?: any[]\n}\n\nexport interface IMemoQueueItem {\n  value?: any\n  deps?: any[]\n}\n\nexport interface IVisitor<Value = any, Target = any> {\n  target?: Target\n  key?: PropertyKey\n  value?: Value\n}\n\nexport type Annotation = (...args: any[]) => any\n\nexport type Annotations<T = any> = {\n  [key in keyof T]?: Annotation\n}\n\nexport type ObservableListener = (operation: IOperation) => void\n\nexport type ObservablePath = Array<string | number>\n\nexport type Dispose = () => void\n\nexport type Effect = () => void | Dispose\n\nexport type Reaction = ((...args: any[]) => any) & {\n  _boundary?: number\n  _name?: string\n  _isComputed?: boolean\n  _dirty?: boolean\n  _context?: any\n  _disposed?: boolean\n  _property?: PropertyKey\n  _computesSet?: ArraySet<Reaction>\n  _reactionsSet?: ArraySet<ReactionsMap>\n  _scheduler?: (reaction: Reaction) => void\n  _memos?: {\n    queue: IMemoQueueItem[]\n    cursor: number\n  }\n  _effects?: {\n    queue: IEffectQueueItem[]\n    cursor: number\n  }\n}\n\nexport type ReactionsMap = Map<PropertyKey, ArraySet<Reaction>>\n\nexport interface IReactionOptions<T> {\n  name?: string\n  equals?: (oldValue: T, newValue: T) => boolean\n  fireImmediately?: boolean\n}\n\nexport type BindFunction<F = (...args: any[]) => any> = (\n  callback?: F,\n  context?: any\n) => F\n\nexport type BoundaryFunction = <F extends (...args: any) => any>(\n  fn?: F\n) => ReturnType<F>\n\nexport interface IBoundable {\n  bound?: <T extends (...args: any[]) => any>(callback: T, context?: any) => T //高阶绑定\n}\nexport interface IAction extends IBoundable {\n  <T>(callback?: () => T): T //原地action\n  scope?: (<T>(callback?: () => T) => T) & IBoundable //原地局部action\n}\n\nexport interface IBatch extends IAction {\n  endpoint?: (callback?: () => void) => void\n}\n"]}