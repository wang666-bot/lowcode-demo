{"version":3,"file":"formily.reactive.umd.production.js","sources":["../src/checkers.ts","../src/array.ts","../src/environment.ts","../src/reaction.ts","../src/tree.ts","../src/externals.ts","../src/handlers.ts","../src/internals.ts","../src/batch.ts","../src/action.ts","../src/untracked.ts","../src/annotations/observable.ts","../src/annotations/box.ts","../src/annotations/ref.ts","../src/annotations/shallow.ts","../src/annotations/computed.ts","../src/observable.ts","../src/model.ts","../src/autorun.ts","../src/tracker.ts","../src/observe.ts"],"sourcesContent":["const toString = Object.prototype.toString\nexport const isMap = (val: any): val is Map<any, any> =>\n  val && val instanceof Map\nexport const isSet = (val: any): val is Set<any> => val && val instanceof Set\nexport const isWeakMap = (val: any): val is WeakMap<any, any> =>\n  val && val instanceof WeakMap\nexport const isWeakSet = (val: any): val is WeakSet<any> =>\n  val && val instanceof WeakSet\nexport const isFn = (val: any): val is Function => typeof val === 'function'\nexport const isArr = Array.isArray\nexport const isPlainObj = (val: any): val is object =>\n  toString.call(val) === '[object Object]'\nexport const isValid = (val: any) => val !== null && val !== undefined\nexport const isCollectionType = (target: any) => {\n  return (\n    isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target)\n  )\n}\nexport const isNormalType = (target: any) => {\n  return isPlainObj(target) || isArr(target)\n}\n","export const toArray = (value: any) => {\n  return Array.isArray(value)\n    ? value\n    : value !== undefined && value !== null\n    ? [value]\n    : []\n}\n\nexport class ArraySet<T> {\n  value: T[]\n  forEachIndex = 0\n  constructor(value: T[] = []) {\n    this.value = value\n  }\n\n  add(item: T) {\n    if (!this.has(item)) {\n      this.value.push(item)\n    }\n  }\n\n  has(item: T) {\n    return this.value.indexOf(item) > -1\n  }\n\n  delete(item: T) {\n    const len = this.value.length\n    if (len === 0) return\n    if (len === 1 && this.value[0] === item) {\n      this.value = []\n      return\n    }\n    const findIndex = this.value.indexOf(item)\n    if (findIndex > -1) {\n      this.value.splice(findIndex, 1)\n      if (findIndex <= this.forEachIndex) {\n        this.forEachIndex -= 1\n      }\n    }\n  }\n\n  forEach(callback: (value: T) => void) {\n    if (this.value.length === 0) return\n    this.forEachIndex = 0\n    for (; this.forEachIndex < this.value.length; this.forEachIndex++) {\n      callback(this.value[this.forEachIndex])\n    }\n  }\n\n  batchDelete(callback: (value: T) => void) {\n    if (this.value.length === 0) return\n    this.forEachIndex = 0\n    for (; this.forEachIndex < this.value.length; this.forEachIndex++) {\n      const value = this.value[this.forEachIndex]\n      this.value.splice(this.forEachIndex, 1)\n      this.forEachIndex--\n      callback(value)\n    }\n  }\n\n  clear() {\n    this.value.length = 0\n  }\n}\n","import { ObservableListener, Reaction, ReactionsMap } from './types'\nimport { ArraySet } from './array'\nimport { DataNode } from './tree'\n\nexport const ProxyRaw = new WeakMap()\nexport const RawProxy = new WeakMap()\nexport const RawShallowProxy = new WeakMap()\nexport const RawNode = new WeakMap<object, DataNode>()\nexport const RawReactionsMap = new WeakMap<object, ReactionsMap>()\n\nexport const ReactionStack: Reaction[] = []\nexport const BatchCount = { value: 0 }\nexport const UntrackCount = { value: 0 }\nexport const BatchScope = { value: false }\nexport const DependencyCollected = { value: false }\nexport const PendingReactions = new ArraySet<Reaction>()\nexport const PendingScopeReactions = new ArraySet<Reaction>()\nexport const BatchEndpoints = new ArraySet<() => void>()\nexport const ObserverListeners = new ArraySet<ObservableListener>()\nexport const MakeObModelSymbol = Symbol('MakeObModelSymbol')\nexport const ObModelSymbol = Symbol('ObModelSymbol')\nexport const ObModelNodeSymbol = Symbol('ObModelNodeSymbol')\n","import { isFn } from './checkers'\nimport { ArraySet } from './array'\nimport { IOperation, ReactionsMap, Reaction, PropertyKey } from './types'\nimport {\n  ReactionStack,\n  PendingScopeReactions,\n  BatchEndpoints,\n  DependencyCollected,\n  RawReactionsMap,\n  PendingReactions,\n  BatchCount,\n  UntrackCount,\n  BatchScope,\n  ObserverListeners,\n} from './environment'\n\nconst ITERATION_KEY = Symbol('iteration key')\n\nconst addRawReactionsMap = (\n  target: any,\n  key: PropertyKey,\n  reaction: Reaction\n) => {\n  const reactionsMap = RawReactionsMap.get(target)\n  if (reactionsMap) {\n    const reactions = reactionsMap.get(key)\n    if (reactions) {\n      reactions.add(reaction)\n    } else {\n      reactionsMap.set(key, new ArraySet([reaction]))\n    }\n    return reactionsMap\n  } else {\n    const reactionsMap: ReactionsMap = new Map([\n      [key, new ArraySet([reaction])],\n    ])\n    RawReactionsMap.set(target, reactionsMap)\n    return reactionsMap\n  }\n}\n\nconst addReactionsMapToReaction = (\n  reaction: Reaction,\n  reactionsMap: ReactionsMap\n) => {\n  const bindSet = reaction._reactionsSet\n  if (bindSet) {\n    bindSet.add(reactionsMap)\n  } else {\n    reaction._reactionsSet = new ArraySet([reactionsMap])\n  }\n  return bindSet\n}\n\nconst getReactionsFromTargetKey = (target: any, key: PropertyKey) => {\n  const reactionsMap = RawReactionsMap.get(target)\n  const reactions = []\n  if (reactionsMap) {\n    const map = reactionsMap.get(key)\n    if (map) {\n      map.forEach((reaction) => {\n        if (reactions.indexOf(reaction) === -1) {\n          reactions.push(reaction)\n        }\n      })\n    }\n  }\n  return reactions\n}\n\nconst runReactions = (target: any, key: PropertyKey) => {\n  const reactions = getReactionsFromTargetKey(target, key)\n  const prevUntrackCount = UntrackCount.value\n  UntrackCount.value = 0\n  for (let i = 0, len = reactions.length; i < len; i++) {\n    const reaction = reactions[i]\n    if (reaction._isComputed) {\n      reaction._scheduler(reaction)\n    } else if (isScopeBatching()) {\n      PendingScopeReactions.add(reaction)\n    } else if (isBatching()) {\n      PendingReactions.add(reaction)\n    } else {\n      // never reach\n      if (isFn(reaction._scheduler)) {\n        reaction._scheduler(reaction)\n      } else {\n        reaction()\n      }\n    }\n  }\n  UntrackCount.value = prevUntrackCount\n}\n\nconst notifyObservers = (operation: IOperation) => {\n  ObserverListeners.forEach((fn) => fn(operation))\n}\n\nexport const bindTargetKeyWithCurrentReaction = (operation: IOperation) => {\n  let { key, type, target } = operation\n  if (type === 'iterate') {\n    key = ITERATION_KEY\n  }\n  const reactionLen = ReactionStack.length\n  if (reactionLen === 0) return\n  const current = ReactionStack[reactionLen - 1]\n  if (isUntracking()) return\n  if (current) {\n    DependencyCollected.value = true\n    addReactionsMapToReaction(current, addRawReactionsMap(target, key, current))\n  }\n}\n\nexport const bindComputedReactions = (reaction: Reaction) => {\n  if (isFn(reaction)) {\n    const current = ReactionStack[ReactionStack.length - 1]\n    if (current) {\n      const computes = current._computesSet\n      if (computes) {\n        computes.add(reaction)\n      } else {\n        current._computesSet = new ArraySet([reaction])\n      }\n    }\n  }\n}\n\nexport const runReactionsFromTargetKey = (operation: IOperation) => {\n  let { key, type, target, oldTarget } = operation\n  batchStart()\n  notifyObservers(operation)\n  if (type === 'clear') {\n    oldTarget.forEach((_: any, key: PropertyKey) => {\n      runReactions(target, key)\n    })\n  } else {\n    runReactions(target, key)\n  }\n  if (type === 'add' || type === 'delete' || type === 'clear') {\n    const newKey = Array.isArray(target) ? 'length' : ITERATION_KEY\n    runReactions(target, newKey)\n  }\n  batchEnd()\n}\n\nexport const hasRunningReaction = () => {\n  return ReactionStack.length > 0\n}\n\nexport const releaseBindingReactions = (reaction: Reaction) => {\n  reaction._reactionsSet?.forEach((reactionsMap) => {\n    reactionsMap.forEach((reactions) => {\n      reactions.delete(reaction)\n    })\n  })\n  PendingReactions.delete(reaction)\n  PendingScopeReactions.delete(reaction)\n  delete reaction._reactionsSet\n}\n\nexport const suspendComputedReactions = (current: Reaction) => {\n  current._computesSet?.forEach((reaction) => {\n    const reactions = getReactionsFromTargetKey(\n      reaction._context,\n      reaction._property\n    )\n    if (reactions.length === 0) {\n      disposeBindingReactions(reaction)\n      reaction._dirty = true\n    }\n  })\n}\n\nexport const disposeBindingReactions = (reaction: Reaction) => {\n  reaction._disposed = true\n  releaseBindingReactions(reaction)\n  suspendComputedReactions(reaction)\n}\n\nexport const batchStart = () => {\n  BatchCount.value++\n}\n\nexport const batchEnd = () => {\n  BatchCount.value--\n  if (BatchCount.value === 0) {\n    const prevUntrackCount = UntrackCount.value\n    UntrackCount.value = 0\n    executePendingReactions()\n    executeBatchEndpoints()\n    UntrackCount.value = prevUntrackCount\n  }\n}\n\nexport const batchScopeStart = () => {\n  BatchScope.value = true\n}\n\nexport const batchScopeEnd = () => {\n  const prevUntrackCount = UntrackCount.value\n  BatchScope.value = false\n  UntrackCount.value = 0\n  PendingScopeReactions.batchDelete((reaction) => {\n    if (isFn(reaction._scheduler)) {\n      reaction._scheduler(reaction)\n    } else {\n      reaction()\n    }\n  })\n  UntrackCount.value = prevUntrackCount\n}\n\nexport const untrackStart = () => {\n  UntrackCount.value++\n}\n\nexport const untrackEnd = () => {\n  UntrackCount.value--\n}\n\nexport const isBatching = () => BatchCount.value > 0\n\nexport const isScopeBatching = () => BatchScope.value\n\nexport const isUntracking = () => UntrackCount.value > 0\n\nexport const executePendingReactions = () => {\n  PendingReactions.batchDelete((reaction) => {\n    if (isFn(reaction._scheduler)) {\n      reaction._scheduler(reaction)\n    } else {\n      reaction()\n    }\n  })\n}\n\nexport const executeBatchEndpoints = () => {\n  BatchEndpoints.batchDelete((callback) => {\n    callback()\n  })\n}\n\nexport const hasDepsChange = (newDeps: any[], oldDeps: any[]) => {\n  if (newDeps === oldDeps) return false\n  if (newDeps.length !== oldDeps.length) return true\n  if (newDeps.some((value, index) => value !== oldDeps[index])) return true\n  return false\n}\n\nexport const disposeEffects = (reaction: Reaction) => {\n  if (reaction._effects) {\n    try {\n      batchStart()\n      reaction._effects.queue.forEach((item) => {\n        if (!item || !item.dispose) return\n        item.dispose()\n      })\n    } finally {\n      batchEnd()\n    }\n  }\n}\n","import { ObModelSymbol, ObModelNodeSymbol, RawNode } from './environment'\nimport { raw as getRaw } from './externals'\nimport { PropertyKey, IOperation } from './types'\nexport class DataChange {\n  node: DataNode\n  key: PropertyKey\n  object: object\n  type: string\n  value: any\n  oldValue: any\n  constructor(operation: IOperation, node: DataNode) {\n    this.node = node\n    this.key = operation.key\n    this.type = operation.type\n    this.object = operation.target\n    this.value = operation.value\n    this.oldValue = operation.oldValue\n  }\n\n  get path() {\n    return this.node.path.concat(this.key)\n  }\n}\nexport class DataNode {\n  target: any\n\n  key: PropertyKey\n\n  value: any\n\n  constructor(target: any, key: PropertyKey, value: any) {\n    this.target = target\n    this.key = key\n    this.value = value\n  }\n\n  get path() {\n    if (!this.parent) return this.key ? [this.key] : []\n    return this.parent.path.concat(this.key)\n  }\n\n  get targetRaw() {\n    return getRaw(this.target)\n  }\n\n  get parent() {\n    if (!this.target) return\n    return getDataNode(this.targetRaw)\n  }\n\n  isEqual(node: DataNode) {\n    if (this.key) {\n      return node.targetRaw === this.targetRaw && node.key === this.key\n    }\n    return node.value === this.value\n  }\n\n  contains(node: DataNode) {\n    if (node === this) return true\n    let parent = node.parent\n    while (!!parent) {\n      if (this.isEqual(parent)) return true\n      parent = parent.parent\n    }\n    return false\n  }\n}\n\nexport const getDataNode = (raw: any) => {\n  if (raw?.[ObModelNodeSymbol]) {\n    return raw[ObModelNodeSymbol]\n  }\n  return RawNode.get(raw)\n}\n\nexport const setDataNode = (raw: any, node: DataNode) => {\n  if (raw?.[ObModelSymbol]) {\n    raw[ObModelNodeSymbol] = node\n    return\n  }\n  RawNode.set(raw, node)\n}\n\nexport const buildDataTree = (target: any, key: PropertyKey, value: any) => {\n  const raw = getRaw(value)\n  const currentNode = getDataNode(raw)\n  if (currentNode) return currentNode\n  setDataNode(raw, new DataNode(target, key, value))\n}\n","import {\n  isValid,\n  isFn,\n  isMap,\n  isWeakMap,\n  isSet,\n  isWeakSet,\n  isPlainObj,\n  isArr,\n} from './checkers'\nimport {\n  ProxyRaw,\n  MakeObModelSymbol,\n  DependencyCollected,\n  ObModelSymbol,\n} from './environment'\nimport { getDataNode } from './tree'\nimport { Annotation } from './types'\n\nconst RAW_TYPE = Symbol('RAW_TYPE')\nconst OBSERVABLE_TYPE = Symbol('OBSERVABLE_TYPE')\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nexport const isObservable = (target: any) => {\n  return ProxyRaw.has(target) || !!target?.[ObModelSymbol]\n}\n\nexport const isAnnotation = (target: any): target is Annotation => {\n  return target && !!target[MakeObModelSymbol]\n}\n\nexport const isSupportObservable = (target: any) => {\n  if (!isValid(target)) return false\n  if (isArr(target)) return true\n  if (isPlainObj(target)) {\n    if (target[RAW_TYPE]) {\n      return false\n    }\n    if (target[OBSERVABLE_TYPE]) {\n      return true\n    }\n    if ('$$typeof' in target && '_owner' in target) {\n      return false\n    }\n    if (target['_isAMomentObject']) {\n      return false\n    }\n    if (target['_isJSONSchemaObject']) {\n      return false\n    }\n    if (isFn(target['toJS'])) {\n      return false\n    }\n    if (isFn(target['toJSON'])) {\n      return false\n    }\n    return true\n  }\n  if (isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target))\n    return true\n  return false\n}\n\nexport const markRaw = <T>(target: T): T => {\n  if (!target) return\n  if (isFn(target)) {\n    target.prototype[RAW_TYPE] = true\n  } else {\n    target[RAW_TYPE] = true\n  }\n  return target\n}\n\nexport const markObservable = <T>(target: T): T => {\n  if (!target) return\n  if (isFn(target)) {\n    target.prototype[OBSERVABLE_TYPE] = true\n  } else {\n    target[OBSERVABLE_TYPE] = true\n  }\n  return target\n}\n\nexport const raw = <T>(target: T): T => {\n  if (target?.[ObModelSymbol]) return target[ObModelSymbol]\n  return ProxyRaw.get(target as any) || target\n}\n\nexport const toJS = <T>(values: T): T => {\n  const visited = new WeakSet<any>()\n  const _toJS: typeof toJS = (values: any) => {\n    if (visited.has(values)) {\n      return values\n    }\n    if (values && values[RAW_TYPE]) return values\n    if (isArr(values)) {\n      if (isObservable(values)) {\n        visited.add(values)\n        const res: any = []\n        values.forEach((item: any) => {\n          res.push(_toJS(item))\n        })\n        visited.delete(values)\n        return res\n      }\n    } else if (isPlainObj(values)) {\n      if (isObservable(values)) {\n        visited.add(values)\n        const res: any = {}\n        for (const key in values) {\n          if (hasOwnProperty.call(values, key)) {\n            res[key] = _toJS(values[key])\n          }\n        }\n        visited.delete(values)\n        return res\n      }\n    }\n    return values\n  }\n\n  return _toJS(values)\n}\n\nexport const contains = (target: any, property: any) => {\n  const targetRaw = raw(target)\n  const propertyRaw = raw(property)\n  if (targetRaw === propertyRaw) return true\n  const targetNode = getDataNode(targetRaw)\n  const propertyNode = getDataNode(propertyRaw)\n  if (!targetNode) return false\n  if (!propertyNode) return false\n  return targetNode.contains(propertyNode)\n}\n\nexport const hasCollected = (callback?: () => void) => {\n  DependencyCollected.value = false\n  callback?.()\n  return DependencyCollected.value\n}\n","import {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from './reaction'\nimport { ProxyRaw, RawProxy } from './environment'\nimport { isObservable, isSupportObservable } from './externals'\nimport { createObservable } from './internals'\n\nconst wellKnownSymbols = new Set(\n  Object.getOwnPropertyNames(Symbol).reduce((buf: Symbol[], key) => {\n    if (key === 'arguments' || key === 'caller') return buf\n    const value = Symbol[key]\n    if (typeof value === 'symbol') return buf.concat(value)\n    return buf\n  }, [])\n)\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction findObservable(target: any, key: PropertyKey, value: any) {\n  const observableObj = RawProxy.get(value)\n  if (observableObj) {\n    return observableObj\n  }\n  if (!isObservable(value) && isSupportObservable(value)) {\n    return createObservable(target, key, value)\n  }\n  return value\n}\n\nfunction patchIterator(\n  target: any,\n  key: PropertyKey,\n  iterator: IterableIterator<any>,\n  isEntries: boolean\n) {\n  const originalNext = iterator.next\n  iterator.next = () => {\n    let { done, value } = originalNext.call(iterator)\n    if (!done) {\n      if (isEntries) {\n        value[1] = findObservable(target, key, value[1])\n      } else {\n        value = findObservable(target, key, value)\n      }\n    }\n    return { done, value }\n  }\n  return iterator\n}\n\nconst instrumentations = {\n  has(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'has' })\n    return proto.has.apply(target, arguments)\n  },\n  get(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'get' })\n    return findObservable(target, key, proto.get.apply(target, arguments))\n  },\n  add(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    // forward the operation before queueing reactions\n    const result = proto.add.apply(target, arguments)\n    if (!hadKey) {\n      runReactionsFromTargetKey({ target, key, value: key, type: 'add' })\n    }\n    return result\n  },\n  set(key: PropertyKey, value: any) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    const oldValue = proto.get.call(target, key)\n    // forward the operation before queueing reactions\n    const result = proto.set.apply(target, arguments)\n    if (!hadKey) {\n      runReactionsFromTargetKey({ target, key, value, type: 'add' })\n    } else if (value !== oldValue) {\n      runReactionsFromTargetKey({ target, key, value, oldValue, type: 'set' })\n    }\n    return result\n  },\n  delete(key: PropertyKey) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadKey = proto.has.call(target, key)\n    const oldValue = proto.get ? proto.get.call(target, key) : undefined\n    // forward the operation before queueing reactions\n    const result = proto.delete.apply(target, arguments)\n    if (hadKey) {\n      runReactionsFromTargetKey({ target, key, oldValue, type: 'delete' })\n    }\n    return result\n  },\n  clear() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    const hadItems = target.size !== 0\n    const oldTarget = target instanceof Map ? new Map(target) : new Set(target)\n    // forward the operation before queueing reactions\n    const result = proto.clear.apply(target, arguments)\n    if (hadItems) {\n      runReactionsFromTargetKey({ target, oldTarget, type: 'clear' })\n    }\n    return result\n  },\n  forEach(cb: any, ...args: any[]) {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    // swap out the raw values with their observable pairs\n    // before passing them to the callback\n    const wrappedCb = (value: any, key: PropertyKey, ...args: any) =>\n      cb(findObservable(target, key, value), key, ...args)\n    return proto.forEach.call(target, wrappedCb, ...args)\n  },\n  keys() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return proto.keys.apply(target, arguments)\n  },\n  values() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto.values.apply(target, arguments)\n    return patchIterator(target, '', iterator, false)\n  },\n  entries() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this) as any\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto.entries.apply(target, arguments)\n    return patchIterator(target, '', iterator, true)\n  },\n  [Symbol.iterator]() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    const iterator = proto[Symbol.iterator].apply(target, arguments)\n    return patchIterator(target, '', iterator, target instanceof Map)\n  },\n  get size() {\n    const target = ProxyRaw.get(this)\n    const proto = Reflect.getPrototypeOf(this)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return Reflect.get(proto, 'size', target)\n  },\n}\n\nexport const collectionHandlers = {\n  get(target: any, key: PropertyKey, receiver: any) {\n    // instrument methods and property accessors to be reactive\n    target = hasOwnProperty.call(instrumentations, key)\n      ? instrumentations\n      : target\n    return Reflect.get(target, key, receiver)\n  },\n}\n\nexport const baseHandlers: ProxyHandler<any> = {\n  get(target, key, receiver) {\n    if (!key) return\n    const result = target[key] // use Reflect.get is too slow\n    if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {\n      return result\n    }\n    bindTargetKeyWithCurrentReaction({ target, key, receiver, type: 'get' })\n    const observableResult = RawProxy.get(result)\n    if (observableResult) {\n      return observableResult\n    }\n    if (!isObservable(result) && isSupportObservable(result)) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(target, key)\n      if (\n        !descriptor ||\n        !(descriptor.writable === false && descriptor.configurable === false)\n      ) {\n        return createObservable(target, key, result)\n      }\n    }\n    return result\n  },\n  has(target, key) {\n    const result = Reflect.has(target, key)\n    bindTargetKeyWithCurrentReaction({ target, key, type: 'has' })\n    return result\n  },\n  ownKeys(target) {\n    const keys = Reflect.ownKeys(target)\n    bindTargetKeyWithCurrentReaction({ target, type: 'iterate' })\n    return keys\n  },\n  set(target, key, value, receiver) {\n    // vue2中有对数组原型重写，因此需去除此处proxy\n    if (key === '__proto__') {\n      target[key] = value\n      return true\n    }\n    const hadKey = hasOwnProperty.call(target, key)\n    const newValue = createObservable(target, key, value)\n    const oldValue = target[key]\n    target[key] = newValue // use Reflect.set is too slow\n    if (!hadKey) {\n      runReactionsFromTargetKey({\n        target,\n        key,\n        value: newValue,\n        oldValue,\n        receiver,\n        type: 'add',\n      })\n    } else if (value !== oldValue) {\n      runReactionsFromTargetKey({\n        target,\n        key,\n        value: newValue,\n        oldValue,\n        receiver,\n        type: 'set',\n      })\n    }\n    return true\n  },\n  deleteProperty(target, key) {\n    const oldValue = target[key]\n    delete target[key]\n    runReactionsFromTargetKey({\n      target,\n      key,\n      oldValue,\n      type: 'delete',\n    })\n    return true\n  },\n}\n","import { isFn, isCollectionType, isNormalType } from './checkers'\nimport {\n  RawProxy,\n  ProxyRaw,\n  MakeObModelSymbol,\n  RawShallowProxy,\n} from './environment'\nimport { baseHandlers, collectionHandlers } from './handlers'\nimport { buildDataTree, getDataNode } from './tree'\nimport { isSupportObservable } from './externals'\nimport { PropertyKey, IVisitor, BoundaryFunction } from './types'\n\nconst createNormalProxy = (target: any, shallow?: boolean) => {\n  const proxy = new Proxy(target, baseHandlers)\n  ProxyRaw.set(proxy, target)\n  if (shallow) {\n    RawShallowProxy.set(target, proxy)\n  } else {\n    RawProxy.set(target, proxy)\n  }\n  return proxy\n}\n\nconst createCollectionProxy = (target: any, shallow?: boolean) => {\n  const proxy = new Proxy(target, collectionHandlers)\n  ProxyRaw.set(proxy, target)\n  if (shallow) {\n    RawShallowProxy.set(target, proxy)\n  } else {\n    RawProxy.set(target, proxy)\n  }\n  return proxy\n}\n\nconst createShallowProxy = (target: any) => {\n  if (isNormalType(target)) return createNormalProxy(target, true)\n  if (isCollectionType(target)) return createCollectionProxy(target, true)\n  // never reach\n  return target\n}\n\nexport const createObservable = (\n  target: any,\n  key?: PropertyKey,\n  value?: any,\n  shallow?: boolean\n) => {\n  if (typeof value !== 'object') return value\n  const raw = ProxyRaw.get(value)\n  if (!!raw) {\n    const node = getDataNode(raw)\n    if (!node.target) node.target = target\n    node.key = key\n    return value\n  }\n\n  if (!isSupportObservable(value)) return value\n\n  if (target) {\n    const parentRaw = ProxyRaw.get(target) || target\n    const isShallowParent = RawShallowProxy.get(parentRaw)\n    if (isShallowParent) return value\n  }\n\n  buildDataTree(target, key, value)\n  if (shallow) return createShallowProxy(value)\n  if (isNormalType(value)) return createNormalProxy(value)\n  if (isCollectionType(value)) return createCollectionProxy(value)\n  // never reach\n  return value\n}\n\nexport const createAnnotation = <T extends (visitor: IVisitor) => any>(\n  maker: T\n) => {\n  const annotation = (target: any): ReturnType<T> => {\n    return maker({ value: target })\n  }\n  if (isFn(maker)) {\n    annotation[MakeObModelSymbol] = maker\n  }\n  return annotation\n}\n\nexport const getObservableMaker = (target: any) => {\n  if (target[MakeObModelSymbol]) {\n    if (!target[MakeObModelSymbol][MakeObModelSymbol]) {\n      return target[MakeObModelSymbol]\n    }\n    return getObservableMaker(target[MakeObModelSymbol])\n  }\n}\n\nexport const createBoundaryFunction = (\n  start: (...args: any) => void,\n  end: (...args: any) => void\n) => {\n  function boundary<F extends (...args: any) => any>(fn?: F): ReturnType<F> {\n    let results: ReturnType<F>\n    try {\n      start()\n      if (isFn(fn)) {\n        results = fn()\n      }\n    } finally {\n      end()\n    }\n    return results\n  }\n\n  boundary.bound = createBindFunction(boundary)\n  return boundary\n}\n\nexport const createBindFunction = <Boundary extends BoundaryFunction>(\n  boundary: Boundary\n) => {\n  function bind<F extends (...args: any[]) => any>(\n    callback?: F,\n    context?: any\n  ): F {\n    return ((...args: any[]) =>\n      boundary(() => callback.apply(context, args))) as any\n  }\n  return bind\n}\n\nexport const createBoundaryAnnotation = (\n  start: (...args: any) => void,\n  end: (...args: any) => void\n) => {\n  const boundary = createBoundaryFunction(start, end)\n  const annotation = createAnnotation(({ target, key }) => {\n    target[key] = boundary.bound(target[key], target)\n    return target\n  })\n  boundary[MakeObModelSymbol] = annotation\n  boundary.bound[MakeObModelSymbol] = annotation\n  return boundary\n}\n","import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n} from './reaction'\nimport { BatchEndpoints, BatchCount } from './environment'\nimport { createBoundaryAnnotation } from './internals'\nimport { IBatch } from './types'\nimport { isFn } from './checkers'\n\nexport const batch: IBatch = createBoundaryAnnotation(batchStart, batchEnd)\nbatch.scope = createBoundaryAnnotation(batchScopeStart, batchScopeEnd)\nbatch.endpoint = (callback?: () => void) => {\n  if (!isFn(callback)) return\n  if (BatchCount.value === 0) {\n    callback()\n  } else {\n    BatchEndpoints.add(callback)\n  }\n}\n","import {\n  batchStart,\n  batchEnd,\n  batchScopeStart,\n  batchScopeEnd,\n  untrackStart,\n  untrackEnd,\n} from './reaction'\nimport { createBoundaryAnnotation } from './internals'\nimport { IAction } from './types'\n\nexport const action: IAction = createBoundaryAnnotation(\n  () => {\n    batchStart()\n    untrackStart()\n  },\n  () => {\n    untrackEnd()\n    batchEnd()\n  }\n)\n\naction.scope = createBoundaryAnnotation(\n  () => {\n    batchScopeStart()\n    untrackStart()\n  },\n  () => {\n    untrackEnd()\n    batchScopeEnd()\n  }\n)\n","import { createBoundaryFunction } from './internals'\nimport { untrackStart, untrackEnd } from './reaction'\n\nexport const untracked = createBoundaryFunction(untrackStart, untrackEnd)\n","import { createAnnotation, createObservable } from '../internals'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IObservable {\n  <T>(target: T): T\n}\n\nexport const observable: IObservable = createAnnotation(\n  ({ target, key, value }) => {\n    const store = {\n      value: createObservable(target, key, target ? target[key] : value),\n    }\n\n    function get() {\n      bindTargetKeyWithCurrentReaction({\n        target: target,\n        key: key,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      const oldValue = store.value\n      value = createObservable(target, key, value)\n      store.value = value\n      if (oldValue === value) return\n      runReactionsFromTargetKey({\n        target: target,\n        key: key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        set,\n        get,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    }\n    return store.value\n  }\n)\n","import { ProxyRaw, RawProxy } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IBox {\n  <T>(target: T): { get(): T; set(value: T): void }\n}\n\nexport const box: IBox = createAnnotation(({ target, key, value }) => {\n  const store = {\n    value: target ? target[key] : value,\n  }\n\n  const proxy = {\n    set,\n    get,\n  }\n\n  ProxyRaw.set(proxy, store)\n  RawProxy.set(store, proxy)\n\n  buildDataTree(target, key, store)\n\n  function get() {\n    bindTargetKeyWithCurrentReaction({\n      target: store,\n      key,\n      type: 'get',\n    })\n    return store.value\n  }\n\n  function set(value: any) {\n    const oldValue = store.value\n    store.value = value\n    if (oldValue !== value) {\n      runReactionsFromTargetKey({\n        target: store,\n        key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n  }\n\n  if (target) {\n    Object.defineProperty(target, key, {\n      value: proxy,\n      enumerable: true,\n      configurable: false,\n      writable: false,\n    })\n    return target\n  }\n  return proxy\n})\n","import { ObModelSymbol } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\n\nexport interface IRef {\n  <T>(target: T): { value: T }\n}\n\nexport const ref: IRef = createAnnotation(({ target, key, value }) => {\n  const store = {\n    value: target ? target[key] : value,\n  }\n\n  const proxy = {}\n\n  const context = target ? target : store\n  const property = target ? key : 'value'\n\n  function get() {\n    bindTargetKeyWithCurrentReaction({\n      target: context,\n      key: property,\n      type: 'get',\n    })\n    return store.value\n  }\n\n  function set(value: any) {\n    const oldValue = store.value\n    store.value = value\n    if (oldValue !== value) {\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n  }\n  if (target) {\n    Object.defineProperty(target, key, {\n      get,\n      set,\n      enumerable: true,\n    })\n    return target\n  } else {\n    Object.defineProperty(proxy, 'value', {\n      set,\n      get,\n    })\n    buildDataTree(target, key, store)\n    proxy[ObModelSymbol] = store\n  }\n  return proxy\n})\n","import { createAnnotation, createObservable } from '../internals'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n} from '../reaction'\nimport { IObservable } from './observable'\n\nexport const shallow: IObservable = createAnnotation(\n  ({ target, key, value }) => {\n    const store = {\n      value: createObservable(target, key, target ? target[key] : value, true),\n    }\n\n    function get() {\n      bindTargetKeyWithCurrentReaction({\n        target: target,\n        key: key,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      const oldValue = store.value\n      value = createObservable(target, key, value, true)\n      store.value = value\n      if (oldValue === value) return\n      runReactionsFromTargetKey({\n        target: target,\n        key: key,\n        type: 'set',\n        oldValue,\n        value,\n      })\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        set,\n        get,\n        enumerable: true,\n        configurable: false,\n      })\n      return target\n    }\n    return store.value\n  }\n)\n","import { ObModelSymbol, ReactionStack } from '../environment'\nimport { createAnnotation } from '../internals'\nimport { buildDataTree } from '../tree'\nimport { isFn } from '../checkers'\nimport {\n  bindTargetKeyWithCurrentReaction,\n  runReactionsFromTargetKey,\n  bindComputedReactions,\n  hasRunningReaction,\n  isUntracking,\n  batchStart,\n  batchEnd,\n  releaseBindingReactions,\n} from '../reaction'\n\ninterface IValue<T = any> {\n  value?: T\n}\nexport interface IComputed {\n  <T>(compute: () => T): IValue<T>\n  <T>(compute: { get?: () => T; set?: (value: T) => void }): IValue<T>\n}\n\nconst getDescriptor = Object.getOwnPropertyDescriptor\n\nconst getProto = Object.getPrototypeOf\n\nconst ClassDescriptorSymbol = Symbol('ClassDescriptorSymbol')\n\nfunction getPropertyDescriptor(obj: any, key: PropertyKey) {\n  if (!obj) return\n  return getDescriptor(obj, key) || getPropertyDescriptor(getProto(obj), key)\n}\n\nfunction getPropertyDescriptorCache(obj: any, key: PropertyKey) {\n  const constructor = obj.constructor\n  if (constructor === Object || constructor === Array)\n    return getPropertyDescriptor(obj, key)\n  const cache = constructor[ClassDescriptorSymbol] || {}\n  const descriptor = cache[key]\n  if (descriptor) return descriptor\n  const newDesc = getPropertyDescriptor(obj, key)\n  constructor[ClassDescriptorSymbol] = cache\n  cache[key] = newDesc\n  return newDesc\n}\n\nfunction getPrototypeDescriptor(\n  target: any,\n  key: PropertyKey,\n  value: any\n): PropertyDescriptor {\n  if (!target) {\n    if (value) {\n      if (isFn(value)) {\n        return { get: value }\n      } else {\n        return value\n      }\n    }\n    return {}\n  }\n  const descriptor = getPropertyDescriptorCache(target, key)\n  if (descriptor) {\n    return descriptor\n  }\n  return {}\n}\n\nexport const computed: IComputed = createAnnotation(\n  ({ target, key, value }) => {\n    const store: IValue = {}\n\n    const proxy = {}\n\n    const context = target ? target : store\n    const property = target ? key : 'value'\n    const descriptor = getPrototypeDescriptor(target, property, value)\n\n    function compute() {\n      store.value = descriptor.get?.call(context)\n    }\n    function reaction() {\n      if (ReactionStack.indexOf(reaction) === -1) {\n        releaseBindingReactions(reaction)\n        try {\n          ReactionStack.push(reaction)\n          compute()\n        } finally {\n          ReactionStack.pop()\n        }\n      }\n    }\n    reaction._name = 'ComputedReaction'\n    reaction._scheduler = () => {\n      reaction._dirty = true\n      runReactionsFromTargetKey({\n        target: context,\n        key: property,\n        value: store.value,\n        type: 'set',\n      })\n    }\n    reaction._isComputed = true\n    reaction._dirty = true\n    reaction._context = context\n    reaction._property = property\n\n    function get() {\n      if (hasRunningReaction()) {\n        bindComputedReactions(reaction)\n      }\n      if (!isUntracking()) {\n        //如果允许untracked过程中收集依赖，那么永远不会存在绑定，因为_dirty已经设置为false\n        if (reaction._dirty) {\n          reaction()\n          reaction._dirty = false\n        }\n      } else {\n        compute()\n      }\n      bindTargetKeyWithCurrentReaction({\n        target: context,\n        key: property,\n        type: 'get',\n      })\n      return store.value\n    }\n\n    function set(value: any) {\n      try {\n        batchStart()\n        descriptor.set?.call(context, value)\n      } finally {\n        batchEnd()\n      }\n    }\n    if (target) {\n      Object.defineProperty(target, key, {\n        get,\n        set,\n        enumerable: true,\n      })\n      return target\n    } else {\n      Object.defineProperty(proxy, 'value', {\n        set,\n        get,\n      })\n      buildDataTree(target, key, store)\n      proxy[ObModelSymbol] = store\n    }\n    return proxy\n  }\n)\n","import * as annotations from './annotations'\nimport { MakeObModelSymbol } from './environment'\nimport { createObservable } from './internals'\n\nexport function observable<T extends object>(target: T): T {\n  return createObservable(null, null, target)\n}\n\nobservable.box = annotations.box\nobservable.ref = annotations.ref\nobservable.deep = annotations.observable\nobservable.shallow = annotations.shallow\nobservable.computed = annotations.computed\nobservable[MakeObModelSymbol] = annotations.observable\n","import { isFn } from './checkers'\nimport { buildDataTree } from './tree'\nimport { observable } from './observable'\nimport { getObservableMaker } from './internals'\nimport { isObservable, isAnnotation, isSupportObservable } from './externals'\nimport { Annotations } from './types'\nimport { action } from './action'\nimport { ObModelSymbol } from './environment'\n\nexport function define<Target extends object = any>(\n  target: Target,\n  annotations?: Annotations<Target>\n): Target {\n  if (isObservable(target)) return target\n  if (!isSupportObservable(target)) return target\n  target[ObModelSymbol] = target\n  buildDataTree(undefined, undefined, target)\n  for (const key in annotations) {\n    const annotation = annotations[key]\n    if (isAnnotation(annotation)) {\n      getObservableMaker(annotation)({\n        target,\n        key,\n      })\n    }\n  }\n  return target\n}\n\nexport function model<Target extends object = any>(target: Target): Target {\n  const annotations = Object.keys(target || {}).reduce((buf, key) => {\n    const descriptor = Object.getOwnPropertyDescriptor(target, key)\n    if (descriptor && descriptor.get) {\n      buf[key] = observable.computed\n    } else if (isFn(target[key])) {\n      buf[key] = action\n    } else {\n      buf[key] = observable\n    }\n    return buf\n  }, {})\n  return define(target, annotations)\n}\n","import {\n  batchEnd,\n  batchStart,\n  disposeBindingReactions,\n  releaseBindingReactions,\n  disposeEffects,\n  hasDepsChange,\n} from './reaction'\nimport { isFn } from './checkers'\nimport { ReactionStack } from './environment'\nimport { Reaction, IReactionOptions, Dispose } from './types'\nimport { toArray } from './array'\n\ninterface IValue {\n  currentValue?: any\n  oldValue?: any\n}\n\nexport const autorun = (tracker: Reaction, name = 'AutoRun') => {\n  const reaction: Reaction = () => {\n    if (!isFn(tracker)) return\n    if (reaction._boundary > 0) return\n    if (ReactionStack.indexOf(reaction) === -1) {\n      releaseBindingReactions(reaction)\n      try {\n        batchStart()\n        ReactionStack.push(reaction)\n        tracker()\n      } finally {\n        ReactionStack.pop()\n        reaction._boundary++\n        batchEnd()\n        reaction._boundary = 0\n        reaction._memos.cursor = 0\n        reaction._effects.cursor = 0\n      }\n    }\n  }\n  const cleanRefs = () => {\n    reaction._memos = {\n      queue: [],\n      cursor: 0,\n    }\n    reaction._effects = {\n      queue: [],\n      cursor: 0,\n    }\n  }\n  reaction._boundary = 0\n  reaction._name = name\n  cleanRefs()\n  reaction()\n  return () => {\n    disposeBindingReactions(reaction)\n    disposeEffects(reaction)\n    cleanRefs()\n  }\n}\n\nautorun.memo = <T>(callback: () => T, dependencies?: any[]): T => {\n  if (!isFn(callback)) return\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (!current || !current._memos)\n    throw new Error('autorun.memo must used in autorun function body.')\n  const deps = toArray(dependencies || [])\n  const id = current._memos.cursor++\n  const old = current._memos.queue[id]\n  if (!old || hasDepsChange(deps, old.deps)) {\n    const value = callback()\n    current._memos.queue[id] = {\n      value,\n      deps,\n    }\n    return value\n  }\n  return old.value\n}\n\nautorun.effect = (callback: () => void | Dispose, dependencies?: any[]) => {\n  if (!isFn(callback)) return\n  const current = ReactionStack[ReactionStack.length - 1]\n  if (!current || !current._effects)\n    throw new Error('autorun.effect must used in autorun function body.')\n  const effects = current._effects\n  const deps = toArray(dependencies || [{}])\n  const id = effects.cursor++\n  const old = effects.queue[id]\n  if (!old || hasDepsChange(deps, old.deps)) {\n    Promise.resolve(0).then(() => {\n      if (current._disposed) return\n      const dispose = callback()\n      if (isFn(dispose)) {\n        effects.queue[id].dispose = dispose\n      }\n    })\n    effects.queue[id] = {\n      deps,\n    }\n  }\n}\n\nexport const reaction = <T>(\n  tracker: () => T,\n  subscriber?: (value: T, oldValue: T) => void,\n  options?: IReactionOptions<T>\n) => {\n  const realOptions = {\n    name: 'Reaction',\n    ...options,\n  }\n  const value: IValue = {}\n  const dirtyCheck = () => {\n    if (isFn(realOptions.equals))\n      return !realOptions.equals(value.oldValue, value.currentValue)\n    return value.oldValue !== value.currentValue\n  }\n\n  const fireAction = () => {\n    try {\n      //如果untrack的话，会导致用户如果在scheduler里同步调用setState影响下次React渲染的依赖收集\n      batchStart()\n      if (isFn(subscriber)) subscriber(value.currentValue, value.oldValue)\n    } finally {\n      batchEnd()\n    }\n  }\n\n  const reaction: Reaction = () => {\n    if (ReactionStack.indexOf(reaction) === -1) {\n      releaseBindingReactions(reaction)\n      try {\n        ReactionStack.push(reaction)\n        value.currentValue = tracker()\n      } finally {\n        ReactionStack.pop()\n      }\n    }\n  }\n  reaction._scheduler = (looping) => {\n    looping()\n    if (dirtyCheck()) fireAction()\n    value.oldValue = value.currentValue\n  }\n  reaction._name = realOptions.name\n  reaction()\n  value.oldValue = value.currentValue\n  if (realOptions.fireImmediately) {\n    fireAction()\n  }\n  return () => {\n    disposeBindingReactions(reaction)\n  }\n}\n","import { ReactionStack } from './environment'\nimport { isFn } from './checkers'\nimport { Reaction } from './types'\nimport {\n  batchEnd,\n  batchStart,\n  disposeBindingReactions,\n  releaseBindingReactions,\n} from './reaction'\n\nexport class Tracker {\n  private results: any\n  constructor(\n    scheduler?: (reaction: Reaction) => void,\n    name = 'TrackerReaction'\n  ) {\n    this.track._scheduler = (callback) => {\n      if (this.track._boundary === 0) this.dispose()\n      if (isFn(callback)) scheduler(callback)\n    }\n    this.track._name = name\n    this.track._boundary = 0\n  }\n\n  track: Reaction = (tracker: Reaction) => {\n    if (!isFn(tracker)) return this.results\n    if (this.track._boundary > 0) return\n    if (ReactionStack.indexOf(this.track) === -1) {\n      releaseBindingReactions(this.track)\n      try {\n        batchStart()\n        ReactionStack.push(this.track)\n        this.results = tracker()\n      } finally {\n        ReactionStack.pop()\n        this.track._boundary++\n        batchEnd()\n        this.track._boundary = 0\n      }\n    }\n    return this.results\n  }\n\n  dispose = () => {\n    disposeBindingReactions(this.track)\n  }\n}\n","import { IOperation } from './types'\nimport { ObserverListeners } from './environment'\nimport { raw as getRaw } from './externals'\nimport { isFn } from './checkers'\nimport { DataChange, getDataNode } from './tree'\n\nexport const observe = (\n  target: object,\n  observer?: (change: DataChange) => void,\n  deep = true\n) => {\n  const addListener = (target: any) => {\n    const raw = getRaw(target)\n    const node = getDataNode(raw)\n\n    const listener = (operation: IOperation) => {\n      const targetRaw = getRaw(operation.target)\n      const targetNode = getDataNode(targetRaw)\n      if (deep) {\n        if (node.contains(targetNode)) {\n          observer(new DataChange(operation, targetNode))\n          return\n        }\n      }\n      if (\n        node === targetNode ||\n        (node.targetRaw === targetRaw && node.key === operation.key)\n      ) {\n        observer(new DataChange(operation, targetNode))\n      }\n    }\n\n    if (node && isFn(observer)) {\n      ObserverListeners.add(listener)\n    }\n    return () => {\n      ObserverListeners.delete(listener)\n    }\n  }\n  if (target && typeof target !== 'object')\n    throw Error(`Can not observe ${typeof target} type.`)\n  return addListener(target)\n}\n"],"names":["toString","Object","prototype","isMap","val","Map","isSet","Set","isWeakMap","WeakMap","isWeakSet","WeakSet","isFn","isArr","Array","isArray","isPlainObj","call","isCollectionType","target","isNormalType","toArray","value","ArraySet","this","forEachIndex","add","item","has","push","indexOf","delete","len","length","findIndex","splice","forEach","callback","batchDelete","clear","ProxyRaw","RawProxy","RawShallowProxy","RawNode","RawReactionsMap","ReactionStack","BatchCount","UntrackCount","BatchScope","DependencyCollected","PendingReactions","PendingScopeReactions","BatchEndpoints","ObserverListeners","MakeObModelSymbol","Symbol","ObModelSymbol","ObModelNodeSymbol","ITERATION_KEY","getReactionsFromTargetKey","key","reactionsMap","get","reactions","map","reaction","runReactions","prevUntrackCount","i","_isComputed","_scheduler","isScopeBatching","isBatching","bindTargetKeyWithCurrentReaction","operation","type","reactionLen","current","isUntracking","bindSet","_reactionsSet","addReactionsMapToReaction","set","reactionsMap_1","addRawReactionsMap","runReactionsFromTargetKey","oldTarget","batchStart","fn","notifyObservers","_","newKey","batchEnd","releaseBindingReactions","_a","disposeBindingReactions","_disposed","_computesSet","_context","_property","_dirty","suspendComputedReactions","executePendingReactions","executeBatchEndpoints","batchScopeStart","batchScopeEnd","untrackStart","untrackEnd","hasDepsChange","newDeps","oldDeps","some","index","DataChange","node","object","oldValue","defineProperty","path","concat","DataNode","parent","getRaw","getDataNode","targetRaw","isEqual","contains","raw","setDataNode","buildDataTree","currentNode","RAW_TYPE","OBSERVABLE_TYPE","hasOwnProperty","isObservable","isAnnotation","isSupportObservable","wellKnownSymbols","getOwnPropertyNames","reduce","buf","findObservable","observableObj","createObservable","patchIterator","iterator","isEntries","originalNext","next","done","instrumentations","proto","Reflect","getPrototypeOf","apply","arguments","hadKey","result","undefined","hadItems","size","cb","args","_i","wrappedCb","__spreadArray","__read","keys","values","entries","collectionHandlers","receiver","baseHandlers","observableResult","descriptor","getOwnPropertyDescriptor","writable","configurable","ownKeys","newValue","deleteProperty","createNormalProxy","shallow","proxy","Proxy","createCollectionProxy","parentRaw","createShallowProxy","createAnnotation","maker","annotation","getObservableMaker","createBoundaryFunction","start","end","boundary","results","bound","createBindFunction","context","createBoundaryAnnotation","batch","scope","endpoint","action","untracked","observable","store","enumerable","box","ref","property","getDescriptor","getProto","ClassDescriptorSymbol","getPropertyDescriptor","obj","getPrototypeDescriptor","constructor","cache","newDesc","getPropertyDescriptorCache","computed","compute","pop","computes","bindComputedReactions","_name","define","annotations","annotations.box","annotations.ref","deep","annotations.observable","annotations.shallow","annotations.computed","autorun","tracker","name","_boundary","_memos","cursor","_effects","cleanRefs","queue","dispose","disposeEffects","memo","dependencies","Error","deps","id","old","effect","effects","Promise","resolve","then","Tracker","scheduler","_this","track","propertyRaw","targetNode","propertyNode","observer","listener","addListener","subscriber","options","realOptions","fireAction","currentValue","looping","equals","fireImmediately","visited","_toJS","res_1","res"],"mappings":"2dAAA,IAAMA,EAAWC,OAAOC,UAAUF,SACrBG,EAAQ,SAACC,GACpB,OAAAA,GAAOA,aAAeC,KACXC,EAAQ,SAACF,GAA8B,OAAAA,GAAOA,aAAeG,KAC7DC,EAAY,SAACJ,GACxB,OAAAA,GAAOA,aAAeK,SACXC,EAAY,SAACN,GACxB,OAAAA,GAAOA,aAAeO,SACXC,EAAO,SAACR,GAA8B,MAAe,mBAARA,GAC7CS,EAAQC,MAAMC,QACdC,EAAa,SAACZ,GACzB,MAAuB,oBAAvBJ,EAASiB,KAAKb,IAEHc,EAAmB,SAACC,GAC/B,OACEhB,EAAMgB,IAAWX,EAAUW,IAAWb,EAAMa,IAAWT,EAAUS,IAGxDC,EAAe,SAACD,GAC3B,OAAOH,EAAWG,IAAWN,EAAMM,ICnBxBE,EAAU,SAACC,GACtB,OAAOR,MAAMC,QAAQO,GACjBA,EACAA,MAAAA,EACA,CAACA,GACD,IAGNC,EAAA,WAGE,SAAAA,EAAYD,QAAA,IAAAA,IAAAA,EAAe,IAD3BE,KAAYC,aAAG,EAEbD,KAAKF,MAAQA,EAmDjB,OAhDEC,EAAGrB,UAAAwB,IAAH,SAAIC,GACGH,KAAKI,IAAID,IACZH,KAAKF,MAAMO,KAAKF,IAIpBJ,EAAGrB,UAAA0B,IAAH,SAAID,GACF,OAAOH,KAAKF,MAAMQ,QAAQH,IAAS,GAGrCJ,EAAMrB,UAAA6B,OAAN,SAAOJ,GACL,IAAMK,EAAMR,KAAKF,MAAMW,OACvB,GAAY,IAARD,EACJ,GAAY,IAARA,GAAaR,KAAKF,MAAM,KAAOK,EAAnC,CAIA,IAAMO,EAAYV,KAAKF,MAAMQ,QAAQH,GACjCO,GAAa,IACfV,KAAKF,MAAMa,OAAOD,EAAW,GACzBA,GAAaV,KAAKC,eACpBD,KAAKC,cAAgB,SAPvBD,KAAKF,MAAQ,IAYjBC,EAAOrB,UAAAkC,QAAP,SAAQC,GACN,GAA0B,IAAtBb,KAAKF,MAAMW,OAEf,IADAT,KAAKC,aAAe,EACbD,KAAKC,aAAeD,KAAKF,MAAMW,OAAQT,KAAKC,eACjDY,EAASb,KAAKF,MAAME,KAAKC,gBAI7BF,EAAWrB,UAAAoC,YAAX,SAAYD,GACV,GAA0B,IAAtBb,KAAKF,MAAMW,OAEf,IADAT,KAAKC,aAAe,EACbD,KAAKC,aAAeD,KAAKF,MAAMW,OAAQT,KAAKC,eAAgB,CACjE,IAAMH,EAAQE,KAAKF,MAAME,KAAKC,cAC9BD,KAAKF,MAAMa,OAAOX,KAAKC,aAAc,GACrCD,KAAKC,eACLY,EAASf,KAIbC,EAAArB,UAAAqC,MAAA,WACEf,KAAKF,MAAMW,OAAS,GAEvBV,KC3DYiB,EAAW,IAAI/B,QACfgC,EAAW,IAAIhC,QACfiC,EAAkB,IAAIjC,QACtBkC,EAAU,IAAIlC,QACdmC,EAAkB,IAAInC,QAEtBoC,EAA4B,GAC5BC,EAAa,CAAExB,MAAO,GACtByB,EAAe,CAAEzB,MAAO,GACxB0B,EAAa,CAAE1B,OAAO,GACtB2B,EAAsB,CAAE3B,OAAO,GAC/B4B,EAAmB,IAAI3B,EACvB4B,EAAwB,IAAI5B,EAC5B6B,EAAiB,IAAI7B,EACrB8B,EAAoB,IAAI9B,EACxB+B,EAAoBC,OAAO,qBAC3BC,EAAgBD,OAAO,iBACvBE,EAAoBF,OAAO,qBCLlCG,EAAgBH,OAAO,iBAsCvBI,EAA4B,SAACxC,EAAayC,GAC9C,IAAMC,EAAejB,EAAgBkB,IAAI3C,GACnC4C,EAAY,GAClB,GAAIF,EAAc,CAChB,IAAMG,EAAMH,EAAaC,IAAIF,GACzBI,GACFA,EAAI5B,SAAQ,SAAC6B,IAC0B,IAAjCF,EAAUjC,QAAQmC,IACpBF,EAAUlC,KAAKoC,MAKvB,OAAOF,GAGHG,EAAe,SAAC/C,EAAayC,GACjC,IAAMG,EAAYJ,EAA0BxC,EAAQyC,GAC9CO,EAAmBpB,EAAazB,MACtCyB,EAAazB,MAAQ,EACrB,IAAK,IAAI8C,EAAI,EAAGpC,EAAM+B,EAAU9B,OAAQmC,EAAIpC,EAAKoC,IAAK,CACpD,IAAMH,EAAWF,EAAUK,GACvBH,EAASI,YACXJ,EAASK,WAAWL,GACXM,IACTpB,EAAsBzB,IAAIuC,GACjBO,IACTtB,EAAiBxB,IAAIuC,GAGjBrD,EAAKqD,EAASK,YAChBL,EAASK,WAAWL,GAEpBA,IAINlB,EAAazB,MAAQ6C,GAOVM,EAAmC,SAACC,GACzC,IAAAd,EAAsBc,EAASd,IAA1Be,EAAiBD,EAASC,KAApBxD,EAAWuD,SACf,YAATC,IACFf,EAAMF,GAER,IAAMkB,EAAc/B,EAAcZ,OAClC,GAAoB,IAAhB2C,EAAJ,CACA,IAAMC,EAAUhC,EAAc+B,EAAc,GACxCE,KACAD,IACF5B,EAAoB3B,OAAQ,EAnEE,SAChC2C,EACAJ,GAEA,IAAMkB,EAAUd,EAASe,cACrBD,EACFA,EAAQrD,IAAImC,GAEZI,EAASe,cAAgB,IAAIzD,EAAS,CAACsC,IA4DvCoB,CAA0BJ,EA3FH,SACzB1D,EACAyC,EACAK,GAEA,IAAMJ,EAAejB,EAAgBkB,IAAI3C,GACzC,GAAI0C,EAAc,CAChB,IAAME,EAAYF,EAAaC,IAAIF,GAMnC,OALIG,EACFA,EAAUrC,IAAIuC,GAEdJ,EAAaqB,IAAItB,EAAK,IAAIrC,EAAS,CAAC0C,KAE/BJ,EAEP,IAAMsB,EAA6B,IAAI9E,IAAI,CACzC,CAACuD,EAAK,IAAIrC,EAAS,CAAC0C,OAGtB,OADArB,EAAgBsC,IAAI/D,EAAQgE,GACrBA,EAwE4BC,CAAmBjE,EAAQyC,EAAKiB,OAkB1DQ,EAA4B,SAACX,GAClC,IAAAd,EAAiCc,MAA5BC,EAA4BD,EAASC,KAA/BxD,EAAsBuD,EAAhBvD,OAAEmE,EAAcZ,YAUvC,GATAa,IAnCsB,SAACb,GACvBrB,EAAkBjB,SAAQ,SAACoD,GAAO,OAAAA,EAAGd,MAmCrCe,CAAgBf,GACH,UAATC,EACFW,EAAUlD,SAAQ,SAACsD,EAAQ9B,GACzBM,EAAa/C,EAAQyC,MAGvBM,EAAa/C,EAAQyC,GAEV,QAATe,GAA2B,WAATA,GAA8B,UAATA,EAAkB,CAC3D,IAAMgB,EAAS7E,MAAMC,QAAQI,GAAU,SAAWuC,EAClDQ,EAAa/C,EAAQwE,GAEvBC,KAOWC,EAA0B,SAAC5B,iBACtC6B,EAAA7B,EAASe,8BAAe5C,SAAQ,SAACyB,GAC/BA,EAAazB,SAAQ,SAAC2B,GACpBA,EAAUhC,OAAOkC,SAGrBf,EAAiBnB,OAAOkC,GACxBd,EAAsBpB,OAAOkC,UACtBA,EAASe,eAgBLe,EAA0B,SAAC9B,GACtCA,EAAS+B,WAAY,EACrBH,EAAwB5B,GAfc,SAACY,iBACvCiB,EAAAjB,EAAQoB,6BAAc7D,SAAQ,SAAC6B,GAKJ,IAJPN,EAChBM,EAASiC,SACTjC,EAASkC,WAEGlE,SACZ8D,EAAwB9B,GACxBA,EAASmC,QAAS,MAQtBC,CAAyBpC,IAGdsB,EAAa,WACxBzC,EAAWxB,SAGAsE,EAAW,WAEtB,GADA9C,EAAWxB,QACc,IAArBwB,EAAWxB,MAAa,CAC1B,IAAM6C,EAAmBpB,EAAazB,MACtCyB,EAAazB,MAAQ,EACrBgF,IACAC,IACAxD,EAAazB,MAAQ6C,IAIZqC,EAAkB,WAC7BxD,EAAW1B,OAAQ,GAGRmF,EAAgB,WAC3B,IAAMtC,EAAmBpB,EAAazB,MACtC0B,EAAW1B,OAAQ,EACnByB,EAAazB,MAAQ,EACrB6B,EAAsBb,aAAY,SAAC2B,GAC7BrD,EAAKqD,EAASK,YAChBL,EAASK,WAAWL,GAEpBA,OAGJlB,EAAazB,MAAQ6C,GAGVuC,EAAe,WAC1B3D,EAAazB,SAGFqF,EAAa,WACxB5D,EAAazB,SAGFkD,EAAa,WAAM,OAAA1B,EAAWxB,MAAQ,GAEtCiD,EAAkB,WAAM,OAAAvB,EAAW1B,OAEnCwD,EAAe,WAAM,OAAA/B,EAAazB,MAAQ,GAE1CgF,EAA0B,WACrCpD,EAAiBZ,aAAY,SAAC2B,GACxBrD,EAAKqD,EAASK,YAChBL,EAASK,WAAWL,GAEpBA,QAKOsC,EAAwB,WACnCnD,EAAed,aAAY,SAACD,GAC1BA,QAISuE,EAAgB,SAACC,EAAgBC,GAC5C,OAAID,IAAYC,IACZD,EAAQ5E,SAAW6E,EAAQ7E,UAC3B4E,EAAQE,MAAK,SAACzF,EAAO0F,GAAU,OAAA1F,IAAUwF,EAAQE,suBClPvD,MAAAC,EAAA,WAOE,SAAYA,EAAAvC,EAAuBwC,GACjC1F,KAAK0F,KAAOA,EACZ1F,KAAKoC,IAAMc,EAAUd,IACrBpC,KAAKmD,KAAOD,EAAUC,KACtBnD,KAAK2F,OAASzC,EAAUvD,OACxBK,KAAKF,MAAQoD,EAAUpD,MACvBE,KAAK4F,SAAW1C,EAAU0C,SAM9B,OAHEnH,OAAAoH,eAAIJ,EAAI/G,UAAA,OAAA,CAAR4D,IAAA,WACE,OAAOtC,KAAK0F,KAAKI,KAAKC,OAAO/F,KAAKoC,sCAErCqD,KACDO,GAAA,WAOE,SAAAA,EAAYrG,EAAayC,EAAkBtC,GACzCE,KAAKL,OAASA,EACdK,KAAKoC,IAAMA,EACXpC,KAAKF,MAAQA,EAiCjB,OA9BErB,OAAAoH,eAAIG,EAAItH,UAAA,OAAA,CAAR4D,IAAA,WACE,OAAKtC,KAAKiG,OACHjG,KAAKiG,OAAOH,KAAKC,OAAO/F,KAAKoC,KADXpC,KAAKoC,IAAM,CAACpC,KAAKoC,KAAO,oCAInD3D,OAAAoH,eAAIG,EAAStH,UAAA,YAAA,CAAb4D,IAAA,WACE,OAAO4D,GAAOlG,KAAKL,yCAGrBlB,OAAAoH,eAAIG,EAAMtH,UAAA,SAAA,CAAV4D,IAAA,WACE,GAAKtC,KAAKL,OACV,OAAOwG,GAAYnG,KAAKoG,4CAG1BJ,EAAOtH,UAAA2H,QAAP,SAAQX,GACN,OAAI1F,KAAKoC,IACAsD,EAAKU,YAAcpG,KAAKoG,WAAaV,EAAKtD,MAAQpC,KAAKoC,IAEzDsD,EAAK5F,QAAUE,KAAKF,OAG7BkG,EAAQtH,UAAA4H,SAAR,SAASZ,GACP,GAAIA,IAAS1F,KAAM,OAAO,EAE1B,IADA,IAAIiG,EAASP,EAAKO,OACTA,GAAQ,CACf,GAAIjG,KAAKqG,QAAQJ,GAAS,OAAO,EACjCA,EAASA,EAAOA,OAElB,OAAO,GAEVD,KAEYG,GAAc,SAACI,GAC1B,OAAIA,MAAAA,OAAG,EAAHA,EAAMtE,IACDsE,EAAItE,GAENd,EAAQmB,IAAIiE,IAGRC,GAAc,SAACD,EAAUb,IAChCa,MAAAA,OAAG,EAAHA,EAAMvE,IACRuE,EAAItE,GAAqByD,EAG3BvE,EAAQuC,IAAI6C,EAAKb,IAGNe,GAAgB,SAAC9G,EAAayC,EAAkBtC,GAC3D,IAAMyG,EAAML,GAAOpG,GACb4G,EAAcP,GAAYI,GAChC,GAAIG,EAAa,OAAOA,EACxBF,GAAYD,EAAK,IAAIP,GAASrG,EAAQyC,EAAKtC,KCpEvC6G,GAAW5E,OAAO,YAClB6E,GAAkB7E,OAAO,mBACzB8E,GAAiBpI,OAAOC,UAAUmI,eAE3BC,GAAe,SAACnH,GAC3B,OAAOqB,EAASZ,IAAIT,OAAaA,MAAAA,OAAA,EAAAA,EAASqC,KAG/B+E,GAAe,SAACpH,GAC3B,OAAOA,KAAYA,EAAOmC,IAGfkF,GAAsB,SAACrH,GAClC,OLpBmCf,MKoBtBe,MACTN,EAAMM,KACNH,EAAWG,IACTA,EAAOgH,QAGPhH,EAAOiH,QAGP,aAAcjH,MAAU,WAAYA,OAGpCA,EAAyB,oBAGzBA,EAA4B,uBAG5BP,EAAKO,EAAa,QAGlBP,EAAKO,EAAe,eAKtBhB,EAAMgB,IAAWX,EAAUW,IAAWb,EAAMa,IAAWT,EAAUS,OAyB1D4G,GAAM,SAAI5G,GACrB,OAAIA,MAAAA,SAAAA,EAASqC,IAAuBrC,EAAOqC,GACpChB,EAASsB,IAAI3C,IAAkBA,GC7ElCsH,GAAmB,IAAIlI,IAC3BN,OAAOyI,oBAAoBnF,QAAQoF,QAAO,SAACC,EAAehF,GACxD,GAAY,cAARA,GAA+B,WAARA,EAAkB,OAAOgF,EACpD,IAAMtH,EAAQiC,OAAOK,GACrB,MAAqB,iBAAVtC,EAA2BsH,EAAIrB,OAAOjG,GAC1CsH,IACN,KAGCP,GAAiBpI,OAAOC,UAAUmI,eAExC,SAASQ,GAAe1H,EAAayC,EAAkBtC,GACrD,IAAMwH,EAAgBrG,EAASqB,IAAIxC,GACnC,OAAIwH,KAGCR,GAAahH,IAAUkH,GAAoBlH,GACvCyH,GAAiB5H,EAAQyC,EAAKtC,GAEhCA,GAGT,SAAS0H,GACP7H,EACAyC,EACAqF,EACAC,GAEA,IAAMC,EAAeF,EAASG,KAY9B,OAXAH,EAASG,KAAO,WACV,IAAAtD,EAAkBqD,EAAalI,KAAKgI,GAAlCI,EAAIvD,EAAAuD,KAAE/H,UAQZ,OAPK+H,IACCH,EACF5H,EAAM,GAAKuH,GAAe1H,EAAQyC,EAAKtC,EAAM,IAE7CA,EAAQuH,GAAe1H,EAAQyC,EAAKtC,IAGjC,CAAE+H,KAAIA,EAAE/H,MAAKA,IAEf2H,EAGT,IAAMK,IAAgBxD,EAAA,CACpBlE,IAAA,SAAIgC,GACF,IAAMzC,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MAErC,OADAiD,EAAiC,CAAEtD,OAAMA,EAAEyC,IAAGA,EAAEe,KAAM,QAC/C4E,EAAM3H,IAAI8H,MAAMvI,EAAQwI,YAEjC7F,IAAA,SAAIF,GACF,IAAMzC,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MAErC,OADAiD,EAAiC,CAAEtD,OAAMA,EAAEyC,IAAGA,EAAEe,KAAM,QAC/CkE,GAAe1H,EAAQyC,EAAK2F,EAAMzF,IAAI4F,MAAMvI,EAAQwI,aAE7DjI,IAAA,SAAIkC,GACF,IAAMzC,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MAC/BoI,EAASL,EAAM3H,IAAIX,KAAKE,EAAQyC,GAEhCiG,EAASN,EAAM7H,IAAIgI,MAAMvI,EAAQwI,WAIvC,OAHKC,GACHvE,EAA0B,CAAElE,OAAMA,EAAEyC,IAAGA,EAAEtC,MAAOsC,EAAKe,KAAM,QAEtDkF,GAET3E,IAAA,SAAItB,EAAkBtC,GACpB,IAAMH,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MAC/BoI,EAASL,EAAM3H,IAAIX,KAAKE,EAAQyC,GAChCwD,EAAWmC,EAAMzF,IAAI7C,KAAKE,EAAQyC,GAElCiG,EAASN,EAAMrE,IAAIwE,MAAMvI,EAAQwI,WAMvC,OALKC,EAEMtI,IAAU8F,GACnB/B,EAA0B,CAAElE,SAAQyC,MAAKtC,QAAO8F,WAAUzC,KAAM,QAFhEU,EAA0B,CAAElE,OAAMA,EAAEyC,IAAGA,EAAEtC,MAAKA,EAAEqD,KAAM,QAIjDkF,GAET9H,OAAA,SAAO6B,GACL,IAAMzC,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MAC/BoI,EAASL,EAAM3H,IAAIX,KAAKE,EAAQyC,GAChCwD,EAAWmC,EAAMzF,IAAMyF,EAAMzF,IAAI7C,KAAKE,EAAQyC,QAAOkG,EAErDD,EAASN,EAAMxH,OAAO2H,MAAMvI,EAAQwI,WAI1C,OAHIC,GACFvE,EAA0B,CAAElE,OAAMA,EAAEyC,IAAGA,EAAEwD,SAAQA,EAAEzC,KAAM,WAEpDkF,GAETtH,MAAA,WACE,IAAMpB,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MAC/BuI,EAA2B,IAAhB5I,EAAO6I,KAClB1E,EAAYnE,aAAkBd,IAAM,IAAIA,IAAIc,GAAU,IAAIZ,IAAIY,GAE9D0I,EAASN,EAAMhH,MAAMmH,MAAMvI,EAAQwI,WAIzC,OAHII,GACF1E,EAA0B,CAAElE,OAAMA,EAAEmE,UAASA,EAAEX,KAAM,UAEhDkF,GAETzH,QAAA,SAAQ6H,aAAuBC,EAAA,GAAAC,EAAA,EAAdA,EAAcR,UAAA1H,OAAdkI,IAAAD,EAAcC,EAAA,GAAAR,UAAAQ,GAC7B,IAAMhJ,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MACrCiD,EAAiC,CAAEtD,OAAMA,EAAEwD,KAAM,YAGjD,IAAMyF,EAAY,SAAC9I,EAAYsC,OAAkB,IAAYsG,EAAA,GAAAC,EAAA,EAAZA,EAAYR,UAAA1H,OAAZkI,IAAAD,EAAYC,EAAA,GAAAR,UAAAQ,GAC3D,OAAAF,EAAEP,WAAA,EAAAW,EAAA,CAACxB,GAAe1H,EAAQyC,EAAKtC,GAAQsC,KAAQsG,IAAI,KACrD,OAAOpE,EAAAyD,EAAMnH,SAAQnB,KAAIyI,MAAA5D,EAAAuE,EAAA,CAAClJ,EAAQiJ,GAASE,EAAKJ,IAAK,KAEvDK,KAAA,WACE,IAAMpJ,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MAErC,OADAiD,EAAiC,CAAEtD,OAAMA,EAAEwD,KAAM,YAC1C4E,EAAMgB,KAAKb,MAAMvI,EAAQwI,YAElCa,OAAA,WACE,IAAMrJ,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MACrCiD,EAAiC,CAAEtD,OAAMA,EAAEwD,KAAM,YACjD,IAAMsE,EAAWM,EAAMiB,OAAOd,MAAMvI,EAAQwI,WAC5C,OAAOX,GAAc7H,EAAQ,GAAI8H,GAAU,IAE7CwB,QAAA,WACE,IAAMtJ,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MACrCiD,EAAiC,CAAEtD,OAAMA,EAAEwD,KAAM,YACjD,IAAMsE,EAAWM,EAAMkB,QAAQf,MAAMvI,EAAQwI,WAC7C,OAAOX,GAAc7H,EAAQ,GAAI8H,GAAU,KAE7CnD,EAACvC,OAAO0F,UAAR,WACE,IAAM9H,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MACrCiD,EAAiC,CAAEtD,OAAMA,EAAEwD,KAAM,YACjD,IAAMsE,EAAWM,EAAMhG,OAAO0F,UAAUS,MAAMvI,EAAQwI,WACtD,OAAOX,GAAc7H,EAAQ,GAAI8H,EAAU9H,aAAkBd,4BAE3DyF,EAAI,OAAA,CAARhC,IAAA,WACE,IAAM3C,EAASqB,EAASsB,IAAItC,MACtB+H,EAAQC,QAAQC,eAAejI,MAErC,OADAiD,EAAiC,CAAEtD,OAAMA,EAAEwD,KAAM,YAC1C6E,QAAQ1F,IAAIyF,EAAO,OAAQpI,uCAIzBuJ,GAAqB,CAChC5G,IAAA,SAAI3C,EAAayC,EAAkB+G,GAKjC,OAHAxJ,EAASkH,GAAepH,KAAKqI,GAAkB1F,GAC3C0F,GACAnI,EACGqI,QAAQ1F,IAAI3C,EAAQyC,EAAK+G,KAIvBC,GAAkC,CAC7C9G,IAAI,SAAA3C,EAAQyC,EAAK+G,GACf,GAAK/G,EAAL,CACA,IAAMiG,EAAS1I,EAAOyC,GACtB,GAAmB,iBAARA,GAAoB6E,GAAiB7G,IAAIgC,GAClD,OAAOiG,EAETpF,EAAiC,CAAEtD,OAAMA,EAAEyC,IAAGA,EAAE+G,SAAQA,EAAEhG,KAAM,QAChE,IAAMkG,EAAmBpI,EAASqB,IAAI+F,GACtC,GAAIgB,EACF,OAAOA,EAET,IAAKvC,GAAauB,IAAWrB,GAAoBqB,GAAS,CACxD,IAAMiB,EAAatB,QAAQuB,yBAAyB5J,EAAQyC,GAC5D,IACGkH,IACyB,IAAxBA,EAAWE,WAAkD,IAA5BF,EAAWG,aAE9C,OAAOlC,GAAiB5H,EAAQyC,EAAKiG,GAGzC,OAAOA,IAETjI,IAAG,SAACT,EAAQyC,GACV,IAAMiG,EAASL,QAAQ5H,IAAIT,EAAQyC,GAEnC,OADAa,EAAiC,CAAEtD,OAAMA,EAAEyC,IAAGA,EAAEe,KAAM,QAC/CkF,GAETqB,iBAAQ/J,GACN,IAAMoJ,EAAOf,QAAQ0B,QAAQ/J,GAE7B,OADAsD,EAAiC,CAAEtD,OAAMA,EAAEwD,KAAM,YAC1C4F,GAETrF,aAAI/D,EAAQyC,EAAKtC,EAAOqJ,GAEtB,GAAY,cAAR/G,EAEF,OADAzC,EAAOyC,GAAOtC,GACP,EAET,IAAMsI,EAASvB,GAAepH,KAAKE,EAAQyC,GACrCuH,EAAWpC,GAAiB5H,EAAQyC,EAAKtC,GACzC8F,EAAWjG,EAAOyC,GAqBxB,OApBAzC,EAAOyC,GAAOuH,EACTvB,EASMtI,IAAU8F,GACnB/B,EAA0B,CACxBlE,OAAMA,EACNyC,IAAGA,EACHtC,MAAO6J,EACP/D,SAAQA,EACRuD,SAAQA,EACRhG,KAAM,QAfRU,EAA0B,CACxBlE,OAAMA,EACNyC,IAAGA,EACHtC,MAAO6J,EACP/D,SAAQA,EACRuD,SAAQA,EACRhG,KAAM,SAYH,GAETyG,eAAc,SAACjK,EAAQyC,GACrB,IAAMwD,EAAWjG,EAAOyC,GAQxB,cAPOzC,EAAOyC,GACdyB,EAA0B,CACxBlE,OAAMA,EACNyC,IAAGA,EACHwD,SAAQA,EACRzC,KAAM,YAED,ICrOL0G,GAAoB,SAAClK,EAAamK,GACtC,IAAMC,EAAQ,IAAIC,MAAMrK,EAAQyJ,IAOhC,OANApI,EAAS0C,IAAIqG,EAAOpK,GAChBmK,EACF5I,EAAgBwC,IAAI/D,EAAQoK,GAE5B9I,EAASyC,IAAI/D,EAAQoK,GAEhBA,GAGHE,GAAwB,SAACtK,EAAamK,GAC1C,IAAMC,EAAQ,IAAIC,MAAMrK,EAAQuJ,IAOhC,OANAlI,EAAS0C,IAAIqG,EAAOpK,GAChBmK,EACF5I,EAAgBwC,IAAI/D,EAAQoK,GAE5B9I,EAASyC,IAAI/D,EAAQoK,GAEhBA,GAUIxC,GAAmB,SAC9B5H,EACAyC,EACAtC,EACAgK,GAEA,GAAqB,iBAAVhK,EAAoB,OAAOA,EACtC,IAAMyG,EAAMvF,EAASsB,IAAIxC,GACzB,GAAMyG,EAAK,CACT,IAAMb,EAAOS,GAAYI,GAGzB,OAFKb,EAAK/F,SAAQ+F,EAAK/F,OAASA,GAChC+F,EAAKtD,IAAMA,EACJtC,EAGT,IAAKkH,GAAoBlH,GAAQ,OAAOA,EAExC,GAAIH,EAAQ,CACV,IAAMuK,EAAYlJ,EAASsB,IAAI3C,IAAWA,EAE1C,GADwBuB,EAAgBoB,IAAI4H,GACvB,OAAOpK,EAI9B,OADA2G,GAAc9G,EAAQyC,EAAKtC,GACvBgK,EA/BqB,SAACnK,GAC1B,OAAIC,EAAaD,GAAgBkK,GAAkBlK,GAAQ,GACvDD,EAAiBC,GAAgBsK,GAAsBtK,GAAQ,GAE5DA,EA2BawK,CAAmBrK,GACnCF,EAAaE,GAAe+J,GAAkB/J,GAC9CJ,EAAiBI,GAAemK,GAAsBnK,GAEnDA,GAGIsK,GAAmB,SAC9BC,GAEA,IAAMC,EAAa,SAAC3K,GAClB,OAAO0K,EAAM,CAAEvK,MAAOH,KAKxB,OAHIP,EAAKiL,KACPC,EAAWxI,GAAqBuI,GAE3BC,GAGIC,GAAqB,SAAC5K,GACjC,GAAIA,EAAOmC,GACT,OAAKnC,EAAOmC,GAAmBA,GAGxByI,GAAmB5K,EAAOmC,IAFxBnC,EAAOmC,IAMP0I,GAAyB,SACpCC,EACAC,GAEA,SAASC,EAA0C3G,GACjD,IAAI4G,EACJ,IACEH,IACIrL,EAAK4E,KACP4G,EAAU5G,KAEJ,QACR0G,IAEF,OAAOE,EAIT,OADAD,EAASE,MAAQC,GAAmBH,GAC7BA,GAGIG,GAAqB,SAChCH,GASA,OAPA,SACE9J,EACAkK,GAEA,sBAAS,IAAcrC,EAAA,GAAAC,EAAA,EAAdA,EAAcR,UAAA1H,OAAdkI,IAAAD,EAAcC,GAAAR,UAAAQ,GACrB,OAAAgC,GAAS,WAAM,OAAA9J,EAASqH,MAAM6C,EAASrC,SAKhCsC,GAA2B,SACtCP,EACAC,GAEA,IAAMC,EAAWH,GAAuBC,EAAOC,GACzCJ,EAAaF,IAAiB,SAAC9F,OAAE3E,EAAM2E,EAAA3E,OAAEyC,EAAGkC,EAAAlC,IAEhD,OADAzC,EAAOyC,GAAOuI,EAASE,MAAMlL,EAAOyC,GAAMzC,GACnCA,KAIT,OAFAgL,EAAS7I,GAAqBwI,EAC9BK,EAASE,MAAM/I,GAAqBwI,EAC7BK,GC/HIM,GAAgBD,GAAyBjH,EAAYK,GAClE6G,GAAMC,MAAQF,GAAyBhG,EAAiBC,GACxDgG,GAAME,SAAW,SAACtK,GACXzB,EAAKyB,KACe,IAArBS,EAAWxB,MACbe,IAEAe,EAAe1B,IAAIW,KCPhB,IAAMuK,GAAkBJ,IAC7B,WACEjH,IACAmB,OAEF,WACEC,IACAf,OAIJgH,GAAOF,MAAQF,IACb,WACEhG,IACAE,OAEF,WACEC,IACAF,OC1BS,IAAAoG,GAAYb,GAAuBtF,EAAcC,GCOjDmG,GAA0BlB,IACrC,SAAC9F,GAAE,IAAA3E,WAAQyC,EAAGkC,EAAAlC,IAAEtC,EAAKwE,EAAAxE,MACbyL,EAAQ,CACZzL,MAAOyH,GAAiB5H,EAAQyC,EAAKzC,EAASA,EAAOyC,GAAOtC,IAyB9D,OAAIH,GACFlB,OAAOoH,eAAelG,EAAQyC,EAAK,CACjCsB,IAfJ,SAAa5D,GACX,IAAM8F,EAAW2F,EAAMzL,MACvBA,EAAQyH,GAAiB5H,EAAQyC,EAAKtC,GACtCyL,EAAMzL,MAAQA,EACV8F,IAAa9F,GACjB+D,EAA0B,CACxBlE,OAAQA,EACRyC,IAAKA,EACLe,KAAM,MACNyC,SAAQA,EACR9F,MAAKA,KAMLwC,IAzBJ,WAME,OALAW,EAAiC,CAC/BtD,OAAQA,EACRyC,IAAKA,EACLe,KAAM,QAEDoI,EAAMzL,OAoBX0L,YAAY,EACZ/B,cAAc,IAET9J,GAEF4L,EAAMzL,SCnCJ2L,GAAYrB,IAAiB,SAAC9F,GAAE,IAAA3E,WAAQyC,EAAGkC,EAAAlC,IAAEtC,EAAKwE,EAAAxE,MACvDyL,EAAQ,CACZzL,MAAOH,EAASA,EAAOyC,GAAOtC,GAG1BiK,EAAQ,CACZrG,IAkBF,SAAa5D,GACX,IAAM8F,EAAW2F,EAAMzL,MACvByL,EAAMzL,MAAQA,EACV8F,IAAa9F,GACf+D,EAA0B,CACxBlE,OAAQ4L,EACRnJ,IAAGA,EACHe,KAAM,MACNyC,SAAQA,EACR9F,MAAKA,KA1BTwC,IAQF,WAME,OALAW,EAAiC,CAC/BtD,OAAQ4L,EACRnJ,IAAGA,EACHe,KAAM,QAEDoI,EAAMzL,QAiBf,OA5BAkB,EAAS0C,IAAIqG,EAAOwB,GACpBtK,EAASyC,IAAI6H,EAAOxB,GAEpBtD,GAAc9G,EAAQyC,EAAKmJ,GAyBvB5L,GACFlB,OAAOoH,eAAelG,EAAQyC,EAAK,CACjCtC,MAAOiK,EACPyB,YAAY,EACZ/B,cAAc,EACdD,UAAU,IAEL7J,GAEFoK,KC/CI2B,GAAYtB,IAAiB,SAAC9F,GAAE,IAAA3E,WAAQyC,EAAGkC,EAAAlC,IAAEtC,EAAKwE,EAAAxE,MACvDyL,EAAQ,CACZzL,MAAOH,EAASA,EAAOyC,GAAOtC,GAG1BiK,EAAQ,GAERgB,EAAUpL,GAAkB4L,EAC5BI,EAAWhM,EAASyC,EAAM,QAEhC,SAASE,IAMP,OALAW,EAAiC,CAC/BtD,OAAQoL,EACR3I,IAAKuJ,EACLxI,KAAM,QAEDoI,EAAMzL,MAGf,SAAS4D,EAAI5D,GACX,IAAM8F,EAAW2F,EAAMzL,MACvByL,EAAMzL,MAAQA,EACV8F,IAAa9F,GACf+D,EAA0B,CACxBlE,OAAQoL,EACR3I,IAAKuJ,EACLxI,KAAM,MACNyC,SAAQA,EACR9F,MAAKA,IAIX,OAAIH,GACFlB,OAAOoH,eAAelG,EAAQyC,EAAK,CACjCE,IAAGA,EACHoB,IAAGA,EACH8H,YAAY,IAEP7L,IAEPlB,OAAOoH,eAAekE,EAAO,QAAS,CACpCrG,IAAGA,EACHpB,IAAGA,IAELmE,GAAc9G,EAAQyC,EAAKmJ,GAC3BxB,EAAM/H,GAAiBuJ,EAElBxB,MCpDID,GAAuBM,IAClC,SAAC9F,GAAE,IAAA3E,WAAQyC,EAAGkC,EAAAlC,IAAEtC,EAAKwE,EAAAxE,MACbyL,EAAQ,CACZzL,MAAOyH,GAAiB5H,EAAQyC,EAAKzC,EAASA,EAAOyC,GAAOtC,GAAO,IAyBrE,OAAIH,GACFlB,OAAOoH,eAAelG,EAAQyC,EAAK,CACjCsB,IAfJ,SAAa5D,GACX,IAAM8F,EAAW2F,EAAMzL,MACvBA,EAAQyH,GAAiB5H,EAAQyC,EAAKtC,GAAO,GAC7CyL,EAAMzL,MAAQA,EACV8F,IAAa9F,GACjB+D,EAA0B,CACxBlE,OAAQA,EACRyC,IAAKA,EACLe,KAAM,MACNyC,SAAQA,EACR9F,MAAKA,KAMLwC,IAzBJ,WAME,OALAW,EAAiC,CAC/BtD,OAAQA,EACRyC,IAAKA,EACLe,KAAM,QAEDoI,EAAMzL,OAoBX0L,YAAY,EACZ/B,cAAc,IAET9J,GAEF4L,EAAMzL,SCrBX8L,GAAgBnN,OAAO8K,yBAEvBsC,GAAWpN,OAAOwJ,eAElB6D,GAAwB/J,OAAO,yBAErC,SAASgK,GAAsBC,EAAU5J,GACvC,GAAK4J,EACL,OAAOJ,GAAcI,EAAK5J,IAAQ2J,GAAsBF,GAASG,GAAM5J,GAgBzE,SAAS6J,GACPtM,EACAyC,EACAtC,GAEA,IAAKH,EACH,OAAIG,EACEV,EAAKU,GACA,CAAEwC,IAAKxC,GAEPA,EAGJ,GAET,IAAMwJ,EA5BR,SAAoC0C,EAAU5J,GAC5C,IAAM8J,EAAcF,EAAIE,YACxB,GAAIA,IAAgBzN,QAAUyN,IAAgB5M,MAC5C,OAAOyM,GAAsBC,EAAK5J,GACpC,IAAM+J,EAAQD,EAAYJ,KAA0B,GAC9CxC,EAAa6C,EAAM/J,GACzB,GAAIkH,EAAY,OAAOA,EACvB,IAAM8C,EAAUL,GAAsBC,EAAK5J,GAG3C,OAFA8J,EAAYJ,IAAyBK,EACrCA,EAAM/J,GAAOgK,EACNA,EAkBYC,CAA2B1M,EAAQyC,GACtD,OAAIkH,GAGG,GAGF,IAAMgD,GAAsBlC,IACjC,SAAC9F,GAAE,IAAA3E,WAAQyC,EAAGkC,EAAAlC,IAAEtC,EAAKwE,EAAAxE,MACbyL,EAAgB,GAEhBxB,EAAQ,GAERgB,EAAUpL,GAAkB4L,EAC5BI,EAAWhM,EAASyC,EAAM,QAC1BkH,EAAa2C,GAAuBtM,EAAQgM,EAAU7L,GAE5D,SAASyM,UACPhB,EAAMzL,MAAsB,QAAdwE,EAAAgF,EAAWhH,WAAG,IAAAgC,OAAA,EAAAA,EAAE7E,KAAKsL,GAErC,SAAStI,IACP,IAAyC,IAArCpB,EAAcf,QAAQmC,GAAkB,CAC1C4B,EAAwB5B,GACxB,IACEpB,EAAchB,KAAKoC,GACnB8J,IACQ,QACRlL,EAAcmL,QAmBpB,SAASlK,IAkBP,OZoBGjB,EAAcZ,OAAS,GAjCK,SAACgC,GACpC,GAAIrD,EAAKqD,GAAW,CAClB,IAAMY,EAAUhC,EAAcA,EAAcZ,OAAS,GACrD,GAAI4C,EAAS,CACX,IAAMoJ,EAAWpJ,EAAQoB,aACrBgI,EACFA,EAASvM,IAAIuC,GAEbY,EAAQoB,aAAe,IAAI1E,EAAS,CAAC0C,MYXrCiK,CAAsBjK,GAEnBa,IAOHiJ,IALI9J,EAASmC,SACXnC,IACAA,EAASmC,QAAS,GAKtB3B,EAAiC,CAC/BtD,OAAQoL,EACR3I,IAAKuJ,EACLxI,KAAM,QAEDoI,EAAMzL,MAGf,SAAS4D,EAAI5D,SACX,IACEiE,IACgB,QAAhBO,EAAAgF,EAAW5F,WAAK,IAAAY,GAAAA,EAAA7E,KAAKsL,EAASjL,GACtB,QACRsE,KAGJ,OA5CA3B,EAASkK,MAAQ,mBACjBlK,EAASK,WAAa,WACpBL,EAASmC,QAAS,EAClBf,EAA0B,CACxBlE,OAAQoL,EACR3I,IAAKuJ,EACL7L,MAAOyL,EAAMzL,MACbqD,KAAM,SAGVV,EAASI,aAAc,EACvBJ,EAASmC,QAAS,EAClBnC,EAASiC,SAAWqG,EACpBtI,EAASkC,UAAYgH,EA+BjBhM,GACFlB,OAAOoH,eAAelG,EAAQyC,EAAK,CACjCE,IAAGA,EACHoB,IAAGA,EACH8H,YAAY,IAEP7L,IAEPlB,OAAOoH,eAAekE,EAAO,QAAS,CACpCrG,IAAGA,EACHpB,IAAGA,IAELmE,GAAc9G,EAAQyC,EAAKmJ,GAC3BxB,EAAM/H,GAAiBuJ,EAElBxB,MCpJL,SAAUuB,GAA6B3L,GAC3C,OAAO4H,GAAiB,KAAM,KAAM5H,GCItB,SAAAiN,GACdjN,EACAkN,GAEA,GAAI/F,GAAanH,GAAS,OAAOA,EACjC,IAAKqH,GAAoBrH,GAAS,OAAOA,EAGzC,IAAK,IAAMyC,KAFXzC,EAAOqC,GAAiBrC,EACxB8G,QAAc6B,OAAWA,EAAW3I,GAClBkN,EAAa,CAC7B,IAAMvC,EAAauC,EAAYzK,GAC3B2E,GAAauD,IACfC,GAAmBD,EAAnBC,CAA+B,CAC7B5K,OAAMA,EACNyC,IAAGA,IAIT,OAAOzC,EDlBT2L,GAAWG,IAAMqB,GACjBxB,GAAWI,IAAMqB,GACjBzB,GAAW0B,KAAOC,GAClB3B,GAAWxB,QAAUoD,GACrB5B,GAAWgB,SAAWa,GACtB7B,GAAWxJ,GAAqBmL,GEKnB,IAAAG,GAAU,SAACC,EAAmBC,QAAA,IAAAA,IAAAA,EAAgB,WACzD,IAAM7K,EAAqB,WACzB,GAAKrD,EAAKiO,MACN5K,EAAS8K,UAAY,KACgB,IAArClM,EAAcf,QAAQmC,GAAkB,CAC1C4B,EAAwB5B,GACxB,IACEsB,IACA1C,EAAchB,KAAKoC,GACnB4K,IACQ,QACRhM,EAAcmL,MACd/J,EAAS8K,YACTnJ,IACA3B,EAAS8K,UAAY,EACrB9K,EAAS+K,OAAOC,OAAS,EACzBhL,EAASiL,SAASD,OAAS,KAI3BE,EAAY,WAChBlL,EAAS+K,OAAS,CAChBI,MAAO,GACPH,OAAQ,GAEVhL,EAASiL,SAAW,CAClBE,MAAO,GACPH,OAAQ,IAOZ,OAJAhL,EAAS8K,UAAY,EACrB9K,EAASkK,MAAQW,EACjBK,IACAlL,IACO,WACL8B,EAAwB9B,GfoME,SAACA,GAC7B,GAAIA,EAASiL,SACX,IACE3J,IACAtB,EAASiL,SAASE,MAAMhN,SAAQ,SAACT,GAC1BA,GAASA,EAAK0N,SACnB1N,EAAK0N,aAEC,QACRzJ,Ke5MF0J,CAAerL,GACfkL,MAIJP,GAAQW,KAAO,SAAIlN,EAAmBmN,GACpC,GAAK5O,EAAKyB,GAAV,CACA,IAAMwC,EAAUhC,EAAcA,EAAcZ,OAAS,GACrD,IAAK4C,IAAYA,EAAQmK,OACvB,MAAM,IAAIS,MAAM,oDAClB,IAAMC,EAAOrO,EAAQmO,GAAgB,IAC/BG,EAAK9K,EAAQmK,OAAOC,SACpBW,EAAM/K,EAAQmK,OAAOI,MAAMO,GACjC,IAAKC,GAAOhJ,EAAc8I,EAAME,EAAIF,MAAO,CACzC,IAAMpO,EAAQe,IAKd,OAJAwC,EAAQmK,OAAOI,MAAMO,GAAM,CACzBrO,MAAKA,EACLoO,KAAIA,GAECpO,EAET,OAAOsO,EAAItO,QAGbsN,GAAQiB,OAAS,SAACxN,EAAgCmN,GAChD,GAAK5O,EAAKyB,GAAV,CACA,IAAMwC,EAAUhC,EAAcA,EAAcZ,OAAS,GACrD,IAAK4C,IAAYA,EAAQqK,SACvB,MAAM,IAAIO,MAAM,sDAClB,IAAMK,EAAUjL,EAAQqK,SAClBQ,EAAOrO,EAAQmO,GAAgB,CAAC,KAChCG,EAAKG,EAAQb,SACbW,EAAME,EAAQV,MAAMO,GACrBC,IAAOhJ,EAAc8I,EAAME,EAAIF,QAClCK,QAAQC,QAAQ,GAAGC,MAAK,WACtB,IAAIpL,EAAQmB,UAAZ,CACA,IAAMqJ,EAAUhN,IACZzB,EAAKyO,KACPS,EAAQV,MAAMO,GAAIN,QAAUA,OAGhCS,EAAQV,MAAMO,GAAM,CAClBD,KAAIA,MAKG,IC3FbQ,GAEE,SACEC,EACArB,QAAA,IAAAA,IAAAA,EAAwB,mBAF1B,IAUCsB,EAAA5O,KAEDA,KAAK6O,MAAa,SAACxB,GACjB,IAAKjO,EAAKiO,GAAU,OAAOuB,EAAKhE,QAChC,KAAIgE,EAAKC,MAAMtB,UAAY,GAA3B,CACA,IAA2C,IAAvClM,EAAcf,QAAQsO,EAAKC,OAAe,CAC5CxK,EAAwBuK,EAAKC,OAC7B,IACE9K,IACA1C,EAAchB,KAAKuO,EAAKC,OACxBD,EAAKhE,QAAUyC,IACP,QACRhM,EAAcmL,MACdoC,EAAKC,MAAMtB,YACXnJ,IACAwK,EAAKC,MAAMtB,UAAY,GAG3B,OAAOqB,EAAKhE,UAGd5K,KAAA6N,QAAU,WACRtJ,EAAwBqK,EAAKC,QA5B7B7O,KAAK6O,MAAM/L,WAAa,SAACjC,GACM,IAAzB+N,EAAKC,MAAMtB,WAAiBqB,EAAKf,UACjCzO,EAAKyB,IAAW8N,EAAU9N,IAEhCb,KAAK6O,MAAMlC,MAAQW,EACnBtN,KAAK6O,MAAMtB,UAAY,+GduGH,SAAC5N,EAAagM,GACpC,IAAMvF,EAAYG,GAAI5G,GAChBmP,EAAcvI,GAAIoF,GACxB,GAAIvF,IAAc0I,EAAa,OAAO,EACtC,IAAMC,EAAa5I,GAAYC,GACzB4I,EAAe7I,GAAY2I,GACjC,QAAKC,MACAC,GACED,EAAWzI,SAAS0I,iDAGD,SAACnO,GAG3B,OAFAY,EAAoB3B,OAAQ,EAC5Be,MAAAA,GAAAA,IACOY,EAAoB3B,qFAjEC,SAAIH,GAChC,GAAKA,EAML,OALIP,EAAKO,GACPA,EAAOjB,UAAUkI,KAAmB,EAEpCjH,EAAOiH,KAAmB,EAErBjH,aAjBc,SAAIA,GACzB,GAAKA,EAML,OALIP,EAAKO,GACPA,EAAOjB,UAAUiI,KAAY,EAE7BhH,EAAOgH,KAAY,EAEdhH,WYzCH,SAA6CA,GACjD,IAAMkN,EAAcpO,OAAOsK,KAAKpJ,GAAU,IAAIwH,QAAO,SAACC,EAAKhF,GACzD,IAAMkH,EAAa7K,OAAO8K,yBAAyB5J,EAAQyC,GAQ3D,OAPIkH,GAAcA,EAAWhH,IAC3B8E,EAAIhF,GAAOkJ,GAAWgB,SACblN,EAAKO,EAAOyC,IACrBgF,EAAIhF,GAAOgJ,GAEXhE,EAAIhF,GAAOkJ,GAENlE,IACN,IACH,OAAOwF,GAAOjN,EAAQkN,8BGnCD,SACrBlN,EACAsP,EACAjC,QAAA,IAAAA,IAAAA,GAAW,GA8BX,GAAIrN,GAA4B,iBAAXA,EACnB,MAAMsO,MAAM,mBAAAlI,cAA0BpG,EAAM,WAC9C,OA9BoB,SAACA,GACnB,IAAM4G,EAAML,GAAOvG,GACb+F,EAAOS,GAAYI,GAEnB2I,EAAW,SAAChM,GAChB,IAAMkD,EAAYF,GAAOhD,EAAUvD,QAC7BoP,EAAa5I,GAAYC,IAC3B4G,GACEtH,EAAKY,SAASyI,IAMlBrJ,IAASqJ,GACRrJ,EAAKU,YAAcA,GAAaV,EAAKtD,MAAQc,EAAUd,MANtD6M,EAAS,IAAIxJ,EAAWvC,EAAW6L,KAezC,OAHIrJ,GAAQtG,EAAK6P,IACfpN,EAAkB3B,IAAIgP,GAEjB,WACLrN,EAAkBtB,OAAO2O,IAKtBC,CAAYxP,wBF4DG,SACtB0N,EACA+B,EACAC,GAEA,IAAMC,KACJhC,KAAM,YACH+B,GAECvP,EAAgB,GAOhByP,EAAa,WACjB,IAEExL,IACI3E,EAAKgQ,IAAaA,EAAWtP,EAAM0P,aAAc1P,EAAM8F,UACnD,QACRxB,MAIE3B,EAAqB,WACzB,IAAyC,IAArCpB,EAAcf,QAAQmC,GAAkB,CAC1C4B,EAAwB5B,GACxB,IACEpB,EAAchB,KAAKoC,GACnB3C,EAAM0P,aAAenC,IACb,QACRhM,EAAcmL,SAepB,OAXA/J,EAASK,WAAa,SAAC2M,GACrBA,KA3BIrQ,EAAKkQ,EAAYI,QACXJ,EAAYI,OAAO5P,EAAM8F,SAAU9F,EAAM0P,cAC5C1P,EAAM8F,WAAa9F,EAAM0P,eA0BdD,IAClBzP,EAAM8F,SAAW9F,EAAM0P,cAEzB/M,EAASkK,MAAQ2C,EAAYhC,KAC7B7K,IACA3C,EAAM8F,SAAW9F,EAAM0P,aACnBF,EAAYK,iBACdJ,IAEK,WACLhL,EAAwB9B,6Bb9DR,SAAIuG,GACtB,IAAM4G,EAAU,IAAIzQ,QACd0Q,EAAqB,SAAC7G,GAC1B,GAAI4G,EAAQxP,IAAI4I,GACd,OAAOA,EAET,GAAIA,GAAUA,EAAOrC,IAAW,OAAOqC,EACvC,GAAI3J,EAAM2J,IACR,GAAIlC,GAAakC,GAAS,CACxB4G,EAAQ1P,IAAI8I,GACZ,IAAM8G,EAAW,GAKjB,OAJA9G,EAAOpI,SAAQ,SAACT,GACd2P,EAAIzP,KAAKwP,EAAM1P,OAEjByP,EAAQrP,OAAOyI,GACR8G,QAEJ,GAAItQ,EAAWwJ,IAChBlC,GAAakC,GAAS,CACxB4G,EAAQ1P,IAAI8I,GACZ,IAAM+G,EAAW,GACjB,IAAK,IAAM3N,KAAO4G,EACZnC,GAAepH,KAAKuJ,EAAQ5G,KAC9B2N,EAAI3N,GAAOyN,EAAM7G,EAAO5G,KAI5B,OADAwN,EAAQrP,OAAOyI,GACR+G,EAGX,OAAO/G,GAGT,OAAO6G,EAAM7G"}