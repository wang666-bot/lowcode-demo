import { ClassType, KeyType } from '../utils/types';
import { ClassInfo } from './ClassInfo';
type ExtendAndInterface = KeyType;
export interface TypeWithInfo {
    type: ClassType;
    info: ClassInfo;
}
export declare class DuplicateRegistrationError extends Error {
    constructor(type: ClassType);
}
export declare class ClassLoader {
    protected classInfoMap: Map<ClassType, ClassInfo>;
    protected implementCacheMap: Map<ExtendAndInterface, TypeWithInfo[]>;
    callback: {
        onRegisterClass?: (type: ClassType, info: ClassInfo) => void;
        onUnregisterClass?: (type: ClassType, info: ClassInfo) => void;
    };
    constructor(classInfoMap?: Map<ClassType, ClassInfo>, implementCacheMap?: Map<ExtendAndInterface, TypeWithInfo[]>, callback?: {
        onRegisterClass?: (type: ClassType, info: ClassInfo) => void;
        onUnregisterClass?: (type: ClassType, info: ClassInfo) => void;
    });
    /** has class */
    hasClass(type: ClassType): boolean;
    /** register class */
    registerClass(type: ClassType, info?: ClassInfo): this;
    /** unregister class */
    unregisterClass(type: ClassType): boolean;
    /** get class info */
    getClassInfo(type: ClassType): ClassInfo;
    /** filter classes by info */
    filterClasses(pattern: (info: TypeWithInfo) => boolean): TypeWithInfo[];
    /** classes of extends/implements type */
    getImplementClasses(type: ExtendAndInterface): TypeWithInfo[];
    clearAll(): this;
    /** return new instance from this */
    clone(): ClassLoader;
    /**
     * init maps from instance
     * @param oldLoader source loader
     */
    initWith(oldLoader: ClassLoader): void;
    protected cloneImplCacheMap(map: Map<KeyType, TypeWithInfo[]>): Map<KeyType, TypeWithInfo[]>;
    protected getImplCacheByType(type: ExtendAndInterface): TypeWithInfo[];
}
export declare const classLoader: ClassLoader;
export {};
