import { ClassInfo } from './ClassInfo';
import { KeyType, ClassType } from '../utils/types';
import { IocContext } from '../IocContext';
export declare const metaSymbol: unique symbol;
export interface InjectMetadataType {
    type: 'inject' | 'lazyInject' | 'imports';
    key: string | symbol;
    globalType: string | symbol;
    typeCls: KeyType;
    singleton?: boolean;
    /** with lazyInject */
    always?: boolean;
    optional?: boolean;
}
export interface PostConstructMetadataType {
    key: string | symbol;
}
export interface PreDestroyMetadataType {
    key: string | symbol;
}
export interface FunctionContext<T extends Object = {}, K = {}> {
    readonly ioc: IocContext;
    readonly inst: K;
    readonly functionName: string;
    data: Partial<T>;
    args: any[];
    ret: any;
    err: Error;
    skipRunning?: boolean;
}
export interface AspectPoint<T = {}, K = {}> {
    before?: (context: FunctionContext<T, K>) => void;
    after?: (context: FunctionContext<T, K>) => void;
    error?: (context: FunctionContext<T, K>) => void;
}
export declare class MetadataType {
    injectable: boolean;
    classInfo: ClassInfo;
    injects: InjectMetadataType[];
    postConstruct: PostConstructMetadataType[];
    preDestroy: PreDestroyMetadataType[];
    aspects: {
        key: string | symbol;
        point: AspectPoint;
    }[];
}
/**
 * get metadata of class
 * @param type type of class
 */
export declare function getMetadata(type: ClassType): MetadataType;
/**
 * get the field of class metadata
 * @param type type of class
 * @param key field
 */
export declare function getMetadataField<T extends keyof MetadataType>(type: ClassType, key: T): MetadataType[T];
