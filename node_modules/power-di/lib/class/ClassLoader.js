"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.classLoader = exports.ClassLoader = exports.DuplicateRegistrationError = void 0;
var metadata_1 = require("./metadata");
var utils_1 = require("../utils");
var DuplicateRegistrationError = /** @class */ (function (_super) {
    __extends(DuplicateRegistrationError, _super);
    function DuplicateRegistrationError(type) {
        return _super.call(this, "Type ".concat(type.name, " is already registration.")) || this;
    }
    return DuplicateRegistrationError;
}(Error));
exports.DuplicateRegistrationError = DuplicateRegistrationError;
var ClassLoader = /** @class */ (function () {
    function ClassLoader(classInfoMap, implementCacheMap, callback) {
        if (classInfoMap === void 0) { classInfoMap = new Map(); }
        if (implementCacheMap === void 0) { implementCacheMap = new Map(); }
        if (callback === void 0) { callback = {}; }
        this.classInfoMap = classInfoMap;
        this.implementCacheMap = implementCacheMap;
        this.callback = callback;
    }
    /** has class */
    ClassLoader.prototype.hasClass = function (type) {
        return this.classInfoMap.has(type);
    };
    /** register class */
    ClassLoader.prototype.registerClass = function (type, info) {
        var _this = this;
        var _a, _b, _c;
        if (this.classInfoMap.has(type)) {
            throw new DuplicateRegistrationError(type);
        }
        var metadata = (0, metadata_1.getMetadata)(type);
        metadata.injectable = true;
        var clsInfo = info || metadata.classInfo;
        if (!clsInfo.name) {
            clsInfo.name = type.name;
        }
        if (!((_a = clsInfo.extends) === null || _a === void 0 ? void 0 : _a.length)) {
            var superClasses = (0, utils_1.getSuperClassInfo)(type);
            clsInfo.extends = superClasses.map(function (c) { return c.class; });
        }
        this.classInfoMap.set(type, clsInfo);
        if (!clsInfo.implements) {
            clsInfo.implements = [];
        }
        // add cache
        __spreadArray(__spreadArray([], clsInfo.extends, true), clsInfo.implements, true).forEach(function (ext) {
            var impls = _this.getImplCacheByType(ext);
            if (impls.every(function (impl) { return impl.type !== type; })) {
                impls.push({
                    type: type,
                    info: clsInfo,
                });
            }
        });
        (_c = (_b = this.callback).onRegisterClass) === null || _c === void 0 ? void 0 : _c.call(_b, type, clsInfo);
        return this;
    };
    /** unregister class */
    ClassLoader.prototype.unregisterClass = function (type) {
        var _this = this;
        var _a, _b;
        var info = this.classInfoMap.get(type);
        if (info) {
            // remove from cache
            __spreadArray(__spreadArray([], info.extends, true), info.implements, true).forEach(function (ext) {
                var cache = _this.getImplCacheByType(ext);
                var index = cache.findIndex(function (c) { return c.type === type; });
                /* istanbul ignore else */
                if (index >= 0) {
                    cache.splice(index, 1);
                }
            });
            var ret = this.classInfoMap.delete(type);
            (_b = (_a = this.callback).onUnregisterClass) === null || _b === void 0 ? void 0 : _b.call(_a, type, info);
            return ret;
        }
        return false;
    };
    /** get class info */
    ClassLoader.prototype.getClassInfo = function (type) {
        return this.classInfoMap.get(type);
    };
    /** filter classes by info */
    ClassLoader.prototype.filterClasses = function (pattern) {
        var classes = [];
        this.classInfoMap.forEach(function (info, type) {
            var typeWithInfo = { type: type, info: info };
            if (pattern(typeWithInfo)) {
                classes.push(typeWithInfo);
            }
        });
        return classes;
    };
    /** classes of extends/implements type */
    ClassLoader.prototype.getImplementClasses = function (type) {
        return this.getImplCacheByType(type);
    };
    ClassLoader.prototype.clearAll = function () {
        this.classInfoMap.clear();
        this.implementCacheMap.clear();
        return this;
    };
    /** return new instance from this */
    ClassLoader.prototype.clone = function () {
        var Constructor = this.constructor;
        var newInst = new Constructor();
        newInst.initWith(this);
        return newInst;
    };
    /**
     * init maps from instance
     * @param oldLoader source loader
     */
    ClassLoader.prototype.initWith = function (oldLoader) {
        this.classInfoMap = new Map(oldLoader.classInfoMap);
        this.implementCacheMap = this.cloneImplCacheMap(oldLoader.implementCacheMap);
        this.callback = oldLoader.callback;
    };
    ClassLoader.prototype.cloneImplCacheMap = function (map) {
        return new Map(Array.from(map.entries()).map(function (_a) {
            var k = _a[0], v = _a[1];
            return [k, __spreadArray([], v, true)];
        }));
    };
    ClassLoader.prototype.getImplCacheByType = function (type) {
        var key = (0, utils_1.getGlobalType)(type);
        if (!this.implementCacheMap.has(key)) {
            this.implementCacheMap.set(key, []);
            return this.getImplCacheByType(type);
        }
        return this.implementCacheMap.get(key);
    };
    return ClassLoader;
}());
exports.ClassLoader = ClassLoader;
exports.classLoader = new ClassLoader();
//# sourceMappingURL=ClassLoader.js.map