import _extends from "@babel/runtime/helpers/extends";
import { IPublicEnumTransitionType } from '@alilc/lowcode-types';
import { checkPropTypes } from '@alilc/lowcode-utils';
export var Command = /*#__PURE__*/function () {
  function Command() {
    this.commands = new Map();
    this.commandErrors = [];
  }
  var _proto = Command.prototype;
  _proto.registerCommand = function registerCommand(command, options) {
    if (!(options !== null && options !== void 0 && options.commandScope)) {
      throw new Error('plugin meta.commandScope is required.');
    }
    var name = options.commandScope + ":" + command.name;
    if (this.commands.has(name)) {
      throw new Error("Command '" + command.name + "' is already registered.");
    }
    this.commands.set(name, _extends({}, command, {
      name: name
    }));
  };
  _proto.unregisterCommand = function unregisterCommand(name) {
    if (!this.commands.has(name)) {
      throw new Error("Command '" + name + "' is not registered.");
    }
    this.commands["delete"](name);
  };
  _proto.executeCommand = function executeCommand(name, args) {
    var _command$parameters;
    var command = this.commands.get(name);
    if (!command) {
      throw new Error("Command '" + name + "' is not registered.");
    }
    (_command$parameters = command.parameters) === null || _command$parameters === void 0 ? void 0 : _command$parameters.forEach(function (d) {
      if (!checkPropTypes(args[d.name], d.name, d.propType, 'command')) {
        throw new Error("Command '" + name + "' arguments " + d.name + " is invalid.");
      }
    });
    try {
      command.handler(args);
    } catch (error) {
      if (this.commandErrors && this.commandErrors.length) {
        this.commandErrors.forEach(function (callback) {
          return callback(name, error);
        });
      } else {
        throw error;
      }
    }
  };
  _proto.batchExecuteCommand = function batchExecuteCommand(commands, pluginContext) {
    var _this = this;
    if (!commands || !commands.length) {
      return;
    }
    pluginContext.common.utils.executeTransaction(function () {
      commands.forEach(function (command) {
        return _this.executeCommand(command.name, command.args);
      });
    }, IPublicEnumTransitionType.REPAINT);
  };
  _proto.listCommands = function listCommands() {
    return Array.from(this.commands.values()).map(function (d) {
      var result = {
        name: d.name
      };
      if (d.description) {
        result.description = d.description;
      }
      if (d.parameters) {
        result.parameters = d.parameters;
      }
      return result;
    });
  };
  _proto.onCommandError = function onCommandError(callback) {
    this.commandErrors.push(callback);
  };
  return Command;
}();