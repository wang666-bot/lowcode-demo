"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.PaneController = void 0;
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _ricShim = _interopRequireWildcard(require("ric-shim"));
var _lowcodeUtils = require("@alilc/lowcode-utils");
var _lowcodeTypes = require("@alilc/lowcode-types");
var _indentTrack = require("../helper/indent-track");
var _dwellTimer = _interopRequireDefault(require("../helper/dwell-timer"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
/* eslint-disable max-len */
var PaneController = exports.PaneController = /*#__PURE__*/function () {
  function PaneController(at, treeMaster) {
    var _this = this;
    this.pluginContext = void 0;
    this.treeMaster = void 0;
    this.id = (0, _lowcodeUtils.uniqueId)('outline');
    this.indentTrack = new _indentTrack.IndentTrack();
    this._sensorAvailable = false;
    this.dwell = new _dwellTimer["default"](function (target, event) {
      var _this$pluginContext = _this.pluginContext,
        canvas = _this$pluginContext.canvas,
        project = _this$pluginContext.project;
      var document = project.getCurrentDocument();
      var index;
      var focus;
      var valid = true;
      if (target.hasSlots()) {
        index = null;
        focus = {
          type: 'slots'
        };
      } else {
        index = 0;
        valid = !!(document !== null && document !== void 0 && document.checkNesting(target, event.dragObject));
      }
      canvas.createLocation({
        target: target,
        source: _this.id,
        event: event,
        detail: {
          type: _lowcodeTypes.IPublicTypeLocationDetailType.Children,
          index: index,
          focus: focus,
          valid: valid
        }
      });
    });
    /**
     * @see ITreeBoard
     */
    this.at = void 0;
    this.tryScrollAgain = null;
    this.sensing = false;
    this._scrollTarget = void 0;
    this.scroller = void 0;
    this._shell = null;
    this.pluginContext = treeMaster.pluginContext;
    this.treeMaster = treeMaster;
    this.at = at;
    var inited = false;
    var setup = function setup() {
      var _this$treeMaster, _canvas$dragon;
      if (inited) {
        return false;
      }
      inited = true;
      (_this$treeMaster = _this.treeMaster) === null || _this$treeMaster === void 0 ? void 0 : _this$treeMaster.addBoard(_this);
      var canvas = _this.pluginContext.canvas;
      (_canvas$dragon = canvas.dragon) === null || _canvas$dragon === void 0 ? void 0 : _canvas$dragon.addSensor(_this);
      _this.scroller = canvas.createScroller(_this);
    };
    setup();
  }

  /** -------------------- IPublicModelSensor begin -------------------- */

  /**
   * @see IPublicModelSensor
   */
  var _proto = PaneController.prototype;
  _proto.fixEvent = function fixEvent(e) {
    var _e$originalEvent$view;
    if (e.fixed) {
      return e;
    }
    var notMyEvent = ((_e$originalEvent$view = e.originalEvent.view) === null || _e$originalEvent$view === void 0 ? void 0 : _e$originalEvent$view.document) !== document;
    if (!e.target || notMyEvent) {
      e.target = document.elementFromPoint(e.canvasX, e.canvasY);
    }

    // documentModel : 目标文档
    e.documentModel = this.pluginContext.project.getCurrentDocument();

    // 事件已订正
    e.fixed = true;
    return e;
  }

  /**
   * @see IPublicModelSensor
   */;
  _proto.locate = function locate(e) {
    var _this$scroller, _this$treeMaster2, _e$dragObject, _e$dragObject2;
    this.sensing = true;
    (_this$scroller = this.scroller) === null || _this$scroller === void 0 ? void 0 : _this$scroller.scrolling(e);
    var globalY = e.globalY,
      dragObject = e.dragObject;
    var nodes = dragObject === null || dragObject === void 0 ? void 0 : dragObject.nodes;
    var tree = (_this$treeMaster2 = this.treeMaster) === null || _this$treeMaster2 === void 0 ? void 0 : _this$treeMaster2.currentTree;
    if (!tree || !tree.root || !this._shell) {
      return null;
    }
    var operationalNodes = nodes === null || nodes === void 0 ? void 0 : nodes.filter(function (node) {
      var _node$componentMeta, _node$componentMeta$a;
      var onMoveHook = (_node$componentMeta = node.componentMeta) === null || _node$componentMeta === void 0 ? void 0 : (_node$componentMeta$a = _node$componentMeta.advanced.callbacks) === null || _node$componentMeta$a === void 0 ? void 0 : _node$componentMeta$a.onMoveHook;
      var canMove = onMoveHook && typeof onMoveHook === 'function' ? onMoveHook(node) : true;
      return canMove;
    });

    // 如果拖拽的是 Node 才需要后面的判断，拖拽 data 不需要
    if ((0, _lowcodeUtils.isDragNodeObject)(dragObject) && (!operationalNodes || operationalNodes.length === 0)) {
      return;
    }
    var _this$pluginContext2 = this.pluginContext,
      project = _this$pluginContext2.project,
      canvas = _this$pluginContext2.canvas;
    var document = project.getCurrentDocument();
    var pos = getPosFromEvent(e, this._shell);
    var irect = this.getInsertionRect();
    var originLoc = document === null || document === void 0 ? void 0 : document.dropLocation;
    var componentMeta = (_e$dragObject = e.dragObject) !== null && _e$dragObject !== void 0 && _e$dragObject.nodes ? e.dragObject.nodes[0].componentMeta : null;
    if (((_e$dragObject2 = e.dragObject) === null || _e$dragObject2 === void 0 ? void 0 : _e$dragObject2.type) === 'node' && componentMeta && componentMeta.isModal && document !== null && document !== void 0 && document.focusNode) {
      return canvas.createLocation({
        target: document === null || document === void 0 ? void 0 : document.focusNode,
        detail: {
          type: _lowcodeTypes.IPublicTypeLocationDetailType.Children,
          index: 0,
          valid: true
        },
        source: this.id,
        event: e
      });
    }
    if (originLoc && (pos && pos === 'unchanged' || irect && globalY >= irect.top && globalY <= irect.bottom) && dragObject) {
      var _loc = originLoc.clone(e);
      var indented = this.indentTrack.getIndentParent(originLoc, _loc);
      if (indented) {
        var parent = indented[0],
          index = indented[1];
        if (checkRecursion(parent, dragObject)) {
          if (tree.getTreeNode(parent).expanded) {
            this.dwell.reset();
            return canvas.createLocation({
              target: parent,
              source: this.id,
              event: e,
              detail: {
                type: _lowcodeTypes.IPublicTypeLocationDetailType.Children,
                index: index,
                valid: document === null || document === void 0 ? void 0 : document.checkNesting(parent, e.dragObject)
              }
            });
          }
          originLoc.detail.focus = {
            type: 'node',
            node: parent
          };
          // focus try expand go on
          this.dwell.focus(parent, e);
        } else {
          this.dwell.reset();
        }
        // FIXME: recreate new location
      } else if (originLoc.detail.near) {
        originLoc.detail.near = undefined;
        this.dwell.reset();
      }
      return;
    }
    this.indentTrack.reset();
    if (pos && pos !== 'unchanged') {
      var treeNode = tree.getTreeNodeById(pos.nodeId);
      if (treeNode) {
        var focusSlots = pos.focusSlots;
        var _treeNode = treeNode,
          node = _treeNode.node;
        if ((0, _lowcodeUtils.isDragNodeObject)(dragObject)) {
          var newNodes = operationalNodes;
          var i = newNodes === null || newNodes === void 0 ? void 0 : newNodes.length;
          var p = node;
          while (i-- > 0) {
            if (newNodes[i].contains(p)) {
              p = newNodes[i].parent;
            }
          }
          if (p !== node) {
            node = p || (document === null || document === void 0 ? void 0 : document.focusNode);
            treeNode = tree.getTreeNode(node);
            focusSlots = false;
          }
        }
        if (focusSlots) {
          this.dwell.reset();
          return canvas.createLocation({
            target: node,
            source: this.id,
            event: e,
            detail: {
              type: _lowcodeTypes.IPublicTypeLocationDetailType.Children,
              index: null,
              valid: false,
              focus: {
                type: 'slots'
              }
            }
          });
        }
        if (!treeNode.isRoot()) {
          var _loc2 = this.getNear(treeNode, e);
          this.dwell.tryFocus(_loc2);
          return _loc2;
        }
      }
    }
    var loc = this.drillLocate(tree.root, e);
    this.dwell.tryFocus(loc);
    return loc;
  }

  /**
   * @see IPublicModelSensor
   */;
  _proto.isEnter = function isEnter(e) {
    if (!this._shell) {
      return false;
    }
    var rect = this._shell.getBoundingClientRect();
    return e.globalY >= rect.top && e.globalY <= rect.bottom && e.globalX >= rect.left && e.globalX <= rect.right;
  }

  /**
   * @see IPublicModelSensor
   */;
  _proto.deactiveSensor = function deactiveSensor() {
    var _this$scroller2;
    this.sensing = false;
    (_this$scroller2 = this.scroller) === null || _this$scroller2 === void 0 ? void 0 : _this$scroller2.cancel();
    this.dwell.reset();
    this.indentTrack.reset();
  }

  /** -------------------- IPublicModelSensor end -------------------- */

  /** -------------------- ITreeBoard begin -------------------- */

  /**
   * @see ITreeBoard
   */;
  _proto.scrollToNode = function scrollToNode(treeNode, detail, tryTimes) {
    var _this2 = this;
    if (tryTimes === void 0) {
      tryTimes = 0;
    }
    if (tryTimes < 1 && this.tryScrollAgain) {
      (0, _ricShim.cancelIdleCallback)(this.tryScrollAgain);
      this.tryScrollAgain = null;
    }
    if (!this.bounds || !this.scroller || !this.scrollTarget) {
      // is a active sensor
      return;
    }
    var rect;
    if (detail && (0, _lowcodeUtils.isLocationChildrenDetail)(detail)) {
      rect = this.getInsertionRect();
    } else {
      rect = this.getTreeNodeRect(treeNode);
    }
    if (!rect) {
      if (tryTimes < 3) {
        this.tryScrollAgain = (0, _ricShim["default"])(function () {
          return _this2.scrollToNode(treeNode, detail, tryTimes + 1);
        });
      }
      return;
    }
    var _this$scrollTarget = this.scrollTarget,
      scrollHeight = _this$scrollTarget.scrollHeight,
      scrollTop = _this$scrollTarget.top;
    var _this$bounds = this.bounds,
      height = _this$bounds.height,
      top = _this$bounds.top,
      bottom = _this$bounds.bottom;
    if (rect.top < top || rect.bottom > bottom) {
      var opt = {};
      opt.top = Math.min(rect.top + rect.height / 2 + scrollTop - top - height / 2, scrollHeight - height);
      if (rect.height >= height) {
        opt.top = Math.min(scrollTop + rect.top - top, opt.top);
      }
      this.scroller.scrollTo(opt);
    }
    // make tail scroll be sure
    if (tryTimes < 4) {
      this.tryScrollAgain = (0, _ricShim["default"])(function () {
        return _this2.scrollToNode(treeNode, detail, 4);
      });
    }
  }

  /** -------------------- ITreeBoard end -------------------- */;
  _proto.getNear = function getNear(treeNode, e, originalIndex, originalRect) {
    var _this$pluginContext3 = this.pluginContext,
      canvas = _this$pluginContext3.canvas,
      project = _this$pluginContext3.project;
    var document = project.getCurrentDocument();
    var globalY = e.globalY,
      dragObject = e.dragObject;
    if (!dragObject) {
      return null;
    }
    // TODO: check dragObject is anyData
    var node = treeNode.node,
      expanded = treeNode.expanded;
    var rect = originalRect;
    if (!rect) {
      rect = this.getTreeNodeRect(treeNode);
      if (!rect) {
        return null;
      }
    }
    var index = originalIndex;
    if (index == null) {
      index = node.index;
    }
    if (node.isSlotNode) {
      // 是个插槽根节点
      if (!treeNode.isContainer() && !treeNode.hasSlots()) {
        return canvas.createLocation({
          target: node.parent,
          source: this.id,
          event: e,
          detail: {
            type: _lowcodeTypes.IPublicTypeLocationDetailType.Children,
            index: null,
            near: {
              node: node,
              pos: 'replace'
            },
            valid: true // TODO: future validation the slot limit
          }
        });
      }
      var loc1 = this.drillLocate(treeNode, e);
      if (loc1) {
        return loc1;
      }
      return canvas.createLocation({
        target: node.parent,
        source: this.id,
        event: e,
        detail: {
          type: _lowcodeTypes.IPublicTypeLocationDetailType.Children,
          index: null,
          valid: false,
          focus: {
            type: 'slots'
          }
        }
      });
    }
    var focusNode;
    // focus
    if (!expanded && (treeNode.isContainer() || treeNode.hasSlots())) {
      focusNode = node;
    }

    // before
    var titleRect = this.getTreeTitleRect(treeNode) || rect;
    if (globalY < titleRect.top + titleRect.height / 2) {
      return canvas.createLocation({
        target: node.parent,
        source: this.id,
        event: e,
        detail: {
          type: _lowcodeTypes.IPublicTypeLocationDetailType.Children,
          index: index,
          valid: document === null || document === void 0 ? void 0 : document.checkNesting(node.parent, dragObject),
          near: {
            node: node,
            pos: 'before'
          },
          focus: checkRecursion(focusNode, dragObject) ? {
            type: 'node',
            node: focusNode
          } : undefined
        }
      });
    }
    if (globalY > titleRect.bottom) {
      focusNode = undefined;
    }
    if (expanded) {
      // drill
      var loc = this.drillLocate(treeNode, e);
      if (loc) {
        return loc;
      }
    }

    // after
    return canvas.createLocation({
      target: node.parent,
      source: this.id,
      event: e,
      detail: {
        type: _lowcodeTypes.IPublicTypeLocationDetailType.Children,
        index: (index || 0) + 1,
        valid: document === null || document === void 0 ? void 0 : document.checkNesting(node.parent, dragObject),
        near: {
          node: node,
          pos: 'after'
        },
        focus: checkRecursion(focusNode, dragObject) ? {
          type: 'node',
          node: focusNode
        } : undefined
      }
    });
  };
  _proto.drillLocate = function drillLocate(treeNode, e) {
    var _this$pluginContext4 = this.pluginContext,
      canvas = _this$pluginContext4.canvas,
      project = _this$pluginContext4.project;
    var document = project.getCurrentDocument();
    var dragObject = e.dragObject,
      globalY = e.globalY;
    if (!dragObject) {
      return null;
    }
    if (!checkRecursion(treeNode.node, dragObject)) {
      return null;
    }
    if ((0, _lowcodeUtils.isDragAnyObject)(dragObject)) {
      // TODO: future
      return null;
    }
    var container = treeNode.node;
    var detail = {
      type: _lowcodeTypes.IPublicTypeLocationDetailType.Children
    };
    var locationData = {
      target: container,
      detail: detail,
      source: this.id,
      event: e
    };
    var isSlotContainer = treeNode.hasSlots();
    var isContainer = treeNode.isContainer();
    if (container.isSlotNode && !treeNode.expanded) {
      // 未展开，直接定位到内部第一个节点
      if (isSlotContainer) {
        detail.index = null;
        detail.focus = {
          type: 'slots'
        };
        detail.valid = false;
      } else {
        detail.index = 0;
        detail.valid = document === null || document === void 0 ? void 0 : document.checkNesting(container, dragObject);
      }
    }
    var items = null;
    var slotsRect;
    var focusSlots = false;
    // isSlotContainer
    if (isSlotContainer) {
      slotsRect = this.getTreeSlotsRect(treeNode);
      if (slotsRect) {
        if (globalY <= slotsRect.bottom) {
          focusSlots = true;
          items = treeNode.slots;
        } else if (!isContainer) {
          // 不在 slots 范围，又不是 container 的情况，高亮 slots 区
          detail.index = null;
          detail.focus = {
            type: 'slots'
          };
          detail.valid = false;
          return canvas.createLocation(locationData);
        }
      }
    }
    if (!items && isContainer) {
      items = treeNode.children;
    }
    if (!items) {
      return null;
    }
    var l = items.length;
    var index = 0;
    var before = l < 1;
    var current;
    var currentIndex = index;
    for (; index < l; index++) {
      current = items[index];
      currentIndex = index;
      var rect = this.getTreeNodeRect(current);
      if (!rect) {
        continue;
      }

      // rect
      if (globalY < rect.top) {
        before = true;
        break;
      }
      if (globalY > rect.bottom) {
        continue;
      }
      var loc = this.getNear(current, e, index, rect);
      if (loc) {
        return loc;
      }
    }
    if (focusSlots) {
      detail.focus = {
        type: 'slots'
      };
      detail.valid = false;
      detail.index = null;
    } else {
      if (current) {
        detail.index = before ? currentIndex : currentIndex + 1;
        detail.near = {
          node: current.node,
          pos: before ? 'before' : 'after'
        };
      } else {
        detail.index = l;
      }
      detail.valid = document === null || document === void 0 ? void 0 : document.checkNesting(container, dragObject);
    }
    return canvas.createLocation(locationData);
  };
  _proto.purge = function purge() {
    var _canvas$dragon2, _this$treeMaster3;
    var canvas = this.pluginContext.canvas;
    (_canvas$dragon2 = canvas.dragon) === null || _canvas$dragon2 === void 0 ? void 0 : _canvas$dragon2.removeSensor(this);
    (_this$treeMaster3 = this.treeMaster) === null || _this$treeMaster3 === void 0 ? void 0 : _this$treeMaster3.removeBoard(this);
  };
  _proto.mount = function mount(shell) {
    var _this3 = this;
    if (this._shell === shell) {
      return;
    }
    this._shell = shell;
    var _this$pluginContext5 = this.pluginContext,
      canvas = _this$pluginContext5.canvas,
      project = _this$pluginContext5.project;
    if (shell) {
      var _project$currentDocum, _this$treeMaster4;
      this._scrollTarget = canvas.createScrollTarget(shell);
      this._sensorAvailable = true;

      // check if there is current selection and scroll to it
      var selection = (_project$currentDocum = project.currentDocument) === null || _project$currentDocum === void 0 ? void 0 : _project$currentDocum.selection;
      var topNodes = selection === null || selection === void 0 ? void 0 : selection.getTopNodes(true);
      var tree = (_this$treeMaster4 = this.treeMaster) === null || _this$treeMaster4 === void 0 ? void 0 : _this$treeMaster4.currentTree;
      if (topNodes && topNodes[0] && tree) {
        var treeNode = tree.getTreeNodeById(topNodes[0].id);
        if (treeNode) {
          // at this moment, it is possible that pane is not ready yet, so
          // put ui related operations to the next loop
          setTimeout(function () {
            tree.setNodeSelected(treeNode.nodeId);
            _this3.scrollToNode(treeNode, null, 4);
          }, 0);
        }
      }
    } else {
      this._scrollTarget = undefined;
      this._sensorAvailable = false;
    }
  };
  _proto.getInsertionRect = function getInsertionRect() {
    var _this$_shell$querySel;
    if (!this._shell) {
      return undefined;
    }
    return (_this$_shell$querySel = this._shell.querySelector('.insertion')) === null || _this$_shell$querySel === void 0 ? void 0 : _this$_shell$querySel.getBoundingClientRect();
  };
  _proto.getTreeNodeRect = function getTreeNodeRect(treeNode) {
    var _this$_shell$querySel2;
    if (!this._shell) {
      return undefined;
    }
    return (_this$_shell$querySel2 = this._shell.querySelector(".tree-node[data-id=\"" + treeNode.nodeId + "\"]")) === null || _this$_shell$querySel2 === void 0 ? void 0 : _this$_shell$querySel2.getBoundingClientRect();
  };
  _proto.getTreeTitleRect = function getTreeTitleRect(treeNode) {
    var _this$_shell$querySel3;
    if (!this._shell) {
      return undefined;
    }
    return (_this$_shell$querySel3 = this._shell.querySelector(".tree-node-title[data-id=\"" + treeNode.nodeId + "\"]")) === null || _this$_shell$querySel3 === void 0 ? void 0 : _this$_shell$querySel3.getBoundingClientRect();
  };
  _proto.getTreeSlotsRect = function getTreeSlotsRect(treeNode) {
    var _this$_shell$querySel4;
    if (!this._shell) {
      return undefined;
    }
    return (_this$_shell$querySel4 = this._shell.querySelector(".tree-node-slots[data-id=\"" + treeNode.nodeId + "\"]")) === null || _this$_shell$querySel4 === void 0 ? void 0 : _this$_shell$querySel4.getBoundingClientRect();
  };
  (0, _createClass2["default"])(PaneController, [{
    key: "sensorAvailable",
    get:
    /**
     * @see IPublicModelSensor
     */
    function get() {
      return this._sensorAvailable;
    }
  }, {
    key: "bounds",
    get:
    /**
     * @see IScrollable
     */
    function get() {
      if (!this._shell) {
        return null;
      }
      return this._shell.getBoundingClientRect();
    }
  }, {
    key: "scrollTarget",
    get:
    /**
     * @see IScrollable
     */
    function get() {
      return this._scrollTarget;
    }
  }]);
  return PaneController;
}();
function checkRecursion(parent, dragObject) {
  if (!parent) {
    return false;
  }
  if ((0, _lowcodeUtils.isDragNodeObject)(dragObject)) {
    var nodes = dragObject.nodes;
    if (nodes.some(function (node) {
      return node.contains(parent);
    })) {
      return false;
    }
  }
  return true;
}
function getPosFromEvent(_ref, stop) {
  var target = _ref.target;
  if (!target || !stop.contains(target)) {
    return null;
  }
  if (target.matches('.insertion')) {
    return 'unchanged';
  }
  var closest = target.closest('[data-id]');
  if (!closest || !stop.contains(closest)) {
    return null;
  }
  var nodeId = closest.dataset.id;
  return {
    focusSlots: closest.matches('.tree-node-slots'),
    nodeId: nodeId
  };
}