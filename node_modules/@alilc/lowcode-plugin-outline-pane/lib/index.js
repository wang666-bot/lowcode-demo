"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.OutlinePaneContext = OutlinePaneContext;
exports.OutlinePlugin = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _pane = require("./views/pane");
var _outline = require("./icons/outline");
var _consts = require("./helper/consts");
var _treeMaster = require("./controllers/tree-master");
var _paneController = require("./controllers/pane-controller");
var _react = require("react");
function OutlinePaneContext(props) {
  var treeMaster = props.treeMaster || new _treeMaster.TreeMaster(props.pluginContext, props.options);
  var _useState = (0, _react.useState)(function () {
      return new _paneController.PaneController(props.paneName || _consts.MasterPaneName, treeMaster);
    }),
    masterPaneController = _useState[0],
    setMasterPaneController = _useState[1];
  (0, _react.useEffect)(function () {
    return treeMaster.onPluginContextChange(function () {
      setMasterPaneController(new _paneController.PaneController(props.paneName || _consts.MasterPaneName, treeMaster));
    });
  }, []);
  return /*#__PURE__*/React.createElement(_pane.Pane, (0, _extends2["default"])({
    treeMaster: treeMaster,
    controller: masterPaneController,
    key: masterPaneController.id,
    hideFilter: props.hideFilter
  }, props));
}
var OutlinePlugin = exports.OutlinePlugin = function OutlinePlugin(ctx, options) {
  var skeleton = ctx.skeleton,
    config = ctx.config,
    canvas = ctx.canvas,
    project = ctx.project;
  var isInFloatArea = true;
  var hasPreferenceForOutline = config.getPreference().contains('outline-pane-pinned-status-isFloat', 'skeleton');
  if (hasPreferenceForOutline) {
    isInFloatArea = config.getPreference().get('outline-pane-pinned-status-isFloat', 'skeleton');
  }
  var showingPanes = {
    masterPane: false,
    backupPane: false
  };
  var treeMaster = new _treeMaster.TreeMaster(ctx, options);
  return {
    init: function init() {
      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var _canvas$dragon2, _canvas$dragon3;
        var switchPanes;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              skeleton.add({
                area: 'leftArea',
                name: 'outlinePane',
                type: 'PanelDock',
                index: -1,
                content: {
                  name: _consts.MasterPaneName,
                  props: {
                    icon: _outline.IconOutline,
                    description: treeMaster.pluginContext.intlNode('Outline Tree')
                  },
                  content: OutlinePaneContext
                },
                panelProps: (0, _extends2["default"])({
                  area: isInFloatArea ? 'leftFloatArea' : 'leftFixedArea',
                  keepVisibleWhileDragging: true
                }, config.get('defaultOutlinePaneProps')),
                contentProps: {
                  treeTitleExtra: config.get('treeTitleExtra'),
                  treeMaster: treeMaster,
                  paneName: _consts.MasterPaneName
                }
              });
              skeleton.add({
                area: 'rightArea',
                name: _consts.BackupPaneName,
                type: 'Panel',
                props: {
                  hiddenWhenInit: true
                },
                content: OutlinePaneContext,
                contentProps: {
                  paneName: _consts.BackupPaneName,
                  treeMaster: treeMaster
                },
                index: 1
              });

              // 处理 master pane 和 backup pane 切换
              switchPanes = function switchPanes() {
                var _canvas$dragon;
                var isDragging = (_canvas$dragon = canvas.dragon) === null || _canvas$dragon === void 0 ? void 0 : _canvas$dragon.dragging;
                var hasVisibleTreeBoard = showingPanes.backupPane || showingPanes.masterPane;
                var shouldShowBackupPane = isDragging && !hasVisibleTreeBoard;
                if (shouldShowBackupPane) {
                  skeleton.showPanel(_consts.BackupPaneName);
                } else {
                  skeleton.hidePanel(_consts.BackupPaneName);
                }
              };
              (_canvas$dragon2 = canvas.dragon) === null || _canvas$dragon2 === void 0 ? void 0 : _canvas$dragon2.onDragstart(function () {
                switchPanes();
              });
              (_canvas$dragon3 = canvas.dragon) === null || _canvas$dragon3 === void 0 ? void 0 : _canvas$dragon3.onDragend(function () {
                switchPanes();
              });
              skeleton.onShowPanel(function (key) {
                if (key === _consts.MasterPaneName) {
                  showingPanes.masterPane = true;
                }
                if (key === _consts.BackupPaneName) {
                  showingPanes.backupPane = true;
                }
              });
              skeleton.onHidePanel(function (key) {
                if (key === _consts.MasterPaneName) {
                  showingPanes.masterPane = false;
                  switchPanes();
                }
                if (key === _consts.BackupPaneName) {
                  showingPanes.backupPane = false;
                }
              });
              project.onChangeDocument(function (document) {
                if (!document) {
                  return;
                }
                var selection = document.selection;
                selection === null || selection === void 0 ? void 0 : selection.onSelectionChange(function () {
                  var selectedNodes = selection === null || selection === void 0 ? void 0 : selection.getNodes();
                  if (!selectedNodes || selectedNodes.length === 0) {
                    return;
                  }
                  var tree = treeMaster.currentTree;
                  selectedNodes.forEach(function (node) {
                    var treeNode = tree === null || tree === void 0 ? void 0 : tree.getTreeNodeById(node.id);
                    tree === null || tree === void 0 ? void 0 : tree.expandAllAncestors(treeNode);
                  });
                });
              });
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
};
OutlinePlugin.meta = {
  eventPrefix: 'OutlinePlugin',
  preferenceDeclaration: {
    title: '大纲树插件配置',
    properties: [{
      key: 'extraTitle',
      type: 'object',
      description: '副标题'
    }]
  }
};
OutlinePlugin.pluginName = 'OutlinePlugin';