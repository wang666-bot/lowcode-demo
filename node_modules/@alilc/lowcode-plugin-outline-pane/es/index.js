import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _extends from "@babel/runtime/helpers/extends";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { Pane } from './views/pane';
import { IconOutline } from './icons/outline';
import { MasterPaneName, BackupPaneName } from './helper/consts';
import { TreeMaster } from './controllers/tree-master';
import { PaneController } from './controllers/pane-controller';
import { useState, useEffect } from 'react';
export function OutlinePaneContext(props) {
  var treeMaster = props.treeMaster || new TreeMaster(props.pluginContext, props.options);
  var _useState = useState(function () {
      return new PaneController(props.paneName || MasterPaneName, treeMaster);
    }),
    masterPaneController = _useState[0],
    setMasterPaneController = _useState[1];
  useEffect(function () {
    return treeMaster.onPluginContextChange(function () {
      setMasterPaneController(new PaneController(props.paneName || MasterPaneName, treeMaster));
    });
  }, []);
  return /*#__PURE__*/React.createElement(Pane, _extends({
    treeMaster: treeMaster,
    controller: masterPaneController,
    key: masterPaneController.id,
    hideFilter: props.hideFilter
  }, props));
}
export var OutlinePlugin = function OutlinePlugin(ctx, options) {
  var skeleton = ctx.skeleton,
    config = ctx.config,
    canvas = ctx.canvas,
    project = ctx.project;
  var isInFloatArea = true;
  var hasPreferenceForOutline = config.getPreference().contains('outline-pane-pinned-status-isFloat', 'skeleton');
  if (hasPreferenceForOutline) {
    isInFloatArea = config.getPreference().get('outline-pane-pinned-status-isFloat', 'skeleton');
  }
  var showingPanes = {
    masterPane: false,
    backupPane: false
  };
  var treeMaster = new TreeMaster(ctx, options);
  return {
    init: function init() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _canvas$dragon2, _canvas$dragon3;
        var switchPanes;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              skeleton.add({
                area: 'leftArea',
                name: 'outlinePane',
                type: 'PanelDock',
                index: -1,
                content: {
                  name: MasterPaneName,
                  props: {
                    icon: IconOutline,
                    description: treeMaster.pluginContext.intlNode('Outline Tree')
                  },
                  content: OutlinePaneContext
                },
                panelProps: _extends({
                  area: isInFloatArea ? 'leftFloatArea' : 'leftFixedArea',
                  keepVisibleWhileDragging: true
                }, config.get('defaultOutlinePaneProps')),
                contentProps: {
                  treeTitleExtra: config.get('treeTitleExtra'),
                  treeMaster: treeMaster,
                  paneName: MasterPaneName
                }
              });
              skeleton.add({
                area: 'rightArea',
                name: BackupPaneName,
                type: 'Panel',
                props: {
                  hiddenWhenInit: true
                },
                content: OutlinePaneContext,
                contentProps: {
                  paneName: BackupPaneName,
                  treeMaster: treeMaster
                },
                index: 1
              });

              // 处理 master pane 和 backup pane 切换
              switchPanes = function switchPanes() {
                var _canvas$dragon;
                var isDragging = (_canvas$dragon = canvas.dragon) === null || _canvas$dragon === void 0 ? void 0 : _canvas$dragon.dragging;
                var hasVisibleTreeBoard = showingPanes.backupPane || showingPanes.masterPane;
                var shouldShowBackupPane = isDragging && !hasVisibleTreeBoard;
                if (shouldShowBackupPane) {
                  skeleton.showPanel(BackupPaneName);
                } else {
                  skeleton.hidePanel(BackupPaneName);
                }
              };
              (_canvas$dragon2 = canvas.dragon) === null || _canvas$dragon2 === void 0 ? void 0 : _canvas$dragon2.onDragstart(function () {
                switchPanes();
              });
              (_canvas$dragon3 = canvas.dragon) === null || _canvas$dragon3 === void 0 ? void 0 : _canvas$dragon3.onDragend(function () {
                switchPanes();
              });
              skeleton.onShowPanel(function (key) {
                if (key === MasterPaneName) {
                  showingPanes.masterPane = true;
                }
                if (key === BackupPaneName) {
                  showingPanes.backupPane = true;
                }
              });
              skeleton.onHidePanel(function (key) {
                if (key === MasterPaneName) {
                  showingPanes.masterPane = false;
                  switchPanes();
                }
                if (key === BackupPaneName) {
                  showingPanes.backupPane = false;
                }
              });
              project.onChangeDocument(function (document) {
                if (!document) {
                  return;
                }
                var selection = document.selection;
                selection === null || selection === void 0 ? void 0 : selection.onSelectionChange(function () {
                  var selectedNodes = selection === null || selection === void 0 ? void 0 : selection.getNodes();
                  if (!selectedNodes || selectedNodes.length === 0) {
                    return;
                  }
                  var tree = treeMaster.currentTree;
                  selectedNodes.forEach(function (node) {
                    var treeNode = tree === null || tree === void 0 ? void 0 : tree.getTreeNodeById(node.id);
                    tree === null || tree === void 0 ? void 0 : tree.expandAllAncestors(treeNode);
                  });
                });
              });
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
};
OutlinePlugin.meta = {
  eventPrefix: 'OutlinePlugin',
  preferenceDeclaration: {
    title: '大纲树插件配置',
    properties: [{
      key: 'extraTitle',
      type: 'object',
      description: '副标题'
    }]
  }
};
OutlinePlugin.pluginName = 'OutlinePlugin';