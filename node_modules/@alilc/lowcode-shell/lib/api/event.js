"use strict";

exports.__esModule = true;
exports.Event = void 0;
exports.getEvent = getEvent;
var _lowcodeUtils = require("@alilc/lowcode-utils");
var logger = (0, _lowcodeUtils.getLogger)({
  level: 'warn',
  bizName: 'shell-event'
});
var eventBusSymbol = Symbol('eventBus');
var Event = exports.Event = /*#__PURE__*/function () {
  function Event(eventBus, options, workspaceMode) {
    if (workspaceMode === void 0) {
      workspaceMode = false;
    }
    this.workspaceMode = workspaceMode;
    this[eventBusSymbol] = void 0;
    this.options = void 0;
    this[eventBusSymbol] = eventBus;
    this.options = options;
    if (!this.options.prefix) {
      logger.warn('prefix is required while initializing Event');
    }
  }

  /**
   * 监听事件
   * @param event 事件名称
   * @param listener 事件回调
   */
  var _proto = Event.prototype;
  _proto.on = function on(event, listener) {
    if ((0, _lowcodeUtils.isPluginEventName)(event)) {
      return this[eventBusSymbol].on(event, listener);
    } else {
      logger.warn("fail to monitor on event " + event + ", event should have a prefix like 'somePrefix:eventName'");
      return function () {};
    }
  }

  /**
   * 监听事件，会在其他回调函数之前执行
   * @param event 事件名称
   * @param listener 事件回调
   */;
  _proto.prependListener = function prependListener(event, listener) {
    if ((0, _lowcodeUtils.isPluginEventName)(event)) {
      return this[eventBusSymbol].prependListener(event, listener);
    } else {
      logger.warn("fail to prependListener event " + event + ", event should have a prefix like 'somePrefix:eventName'");
      return function () {};
    }
  }

  /**
   * 取消监听事件
   * @param event 事件名称
   * @param listener 事件回调
   */;
  _proto.off = function off(event, listener) {
    this[eventBusSymbol].off(event, listener);
  }

  /**
   * 触发事件
   * @param event 事件名称
   * @param args 事件参数
   * @returns
   */;
  _proto.emit = function emit(event) {
    var _this$eventBusSymbol;
    if (!this.options.prefix) {
      logger.warn('Event#emit has been forbidden while prefix is not specified');
      return;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    (_this$eventBusSymbol = this[eventBusSymbol]).emit.apply(_this$eventBusSymbol, [this.options.prefix + ":" + event].concat(args));
  }

  /**
   * DO NOT USE if u fully understand what this method does.
   * @param event
   * @param args
   */;
  _proto.__internalEmit__ = function __internalEmit__(event) {
    var _this$eventBusSymbol2;
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    (_this$eventBusSymbol2 = this[eventBusSymbol]).emit.apply(_this$eventBusSymbol2, [event].concat(args));
  };
  return Event;
}();
function getEvent(editor, options) {
  if (options === void 0) {
    options = {
      prefix: 'common'
    };
  }
  return new Event(editor.eventBus, options);
}