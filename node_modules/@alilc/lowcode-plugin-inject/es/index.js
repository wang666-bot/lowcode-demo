import _Notification from "@alifd/next/es/notification";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import * as React from 'react';
import { plugins, setters } from '@alilc/lowcode-engine';
import { IPublicEnumPluginRegisterLevel } from '@alilc/lowcode-types';
import { getInjectedResource, injectAssets, needInject, injectComponents, filterPackages, setInjectServerHost } from './utils';
import { AppInject } from './appInject';
var injectedPluginConfigMap = null;
var injectedPlugins = [];
export function getInjectedPlugin(_x, _x2) {
  return _getInjectedPlugin.apply(this, arguments);
}
function _getInjectedPlugin() {
  _getInjectedPlugin = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(name, ctx) {
    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          if (injectedPluginConfigMap) {
            _context4.next = 6;
            break;
          }
          injectedPluginConfigMap = {};
          _context4.next = 4;
          return getInjectedResource('plugin');
        case 4:
          injectedPlugins = _context4.sent;
          if (injectedPlugins && injectedPlugins.length > 0) {
            injectedPlugins.forEach(function (item) {
              var _item$module;
              var pluginName = (_item$module = item.module) === null || _item$module === void 0 ? void 0 : _item$module.pluginName;
              if (!pluginName) {
                var config = item.module(ctx);
                pluginName = config === null || config === void 0 ? void 0 : config.name;
              }
              injectedPluginConfigMap[pluginName] = item.module;
            });
          }
        case 6:
          if (!(name === undefined)) {
            _context4.next = 8;
            break;
          }
          return _context4.abrupt("return", undefined);
        case 8:
          return _context4.abrupt("return", injectedPluginConfigMap[name]);
        case 9:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _getInjectedPlugin.apply(this, arguments);
}
var Inject = function Inject(ctx, options) {
  var _options;
  if (options === void 0) {
    options = {};
  }
  if (!needInject) {
    return {
      init: function init() {}
    };
  }
  if (ctx.registerLevel === IPublicEnumPluginRegisterLevel.Workspace) {
    return AppInject(ctx, options);
  }
  if ((_options = options) !== null && _options !== void 0 && _options.injectServerHost) {
    setInjectServerHost(options.injectServerHost);
  }

  // inject 已有的设计器插件
  // 覆盖后续的插件注册逻辑，所有只有本插件后面注册的插件才可以支持 inject 逻辑
  var originalRegister = plugins.register;
  plugins.register = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(plugin, pluginOptions, options) {
      var pluginName, pluginConfig, injectedSameNamePlugin;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            pluginName = plugin.pluginName;
            if (!pluginName) {
              pluginConfig = plugin(ctx, pluginOptions); // 兼容逻辑
              pluginName = pluginConfig.name;
            }
            _context.next = 4;
            return getInjectedPlugin(pluginName, ctx);
          case 4:
            injectedSameNamePlugin = _context.sent;
            if (!injectedSameNamePlugin) {
              _context.next = 10;
              break;
            }
            injectedPluginConfigMap[pluginName] = null;
            return _context.abrupt("return", originalRegister.call(this, injectedSameNamePlugin, pluginOptions, options));
          case 10:
            return _context.abrupt("return", originalRegister.call(this, plugin, pluginOptions, options));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    return function (_x3, _x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }();
  return {
    // 插件名，注册环境下唯一
    name: 'LowcodePluginInjectAlt',
    // 依赖的插件（插件名数组）
    dep: [],
    // 插件的初始化函数，在引擎初始化之后会立刻调用
    init: function init() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var injectedSetters;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              // inject 新的设计器插件
              if (injectedPluginConfigMap) {
                // TODO 改为引擎的 onInit 事件
                setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
                  var key;
                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.t0 = _regeneratorRuntime.keys(injectedPluginConfigMap);
                      case 1:
                        if ((_context2.t1 = _context2.t0()).done) {
                          _context2.next = 8;
                          break;
                        }
                        key = _context2.t1.value;
                        if (!injectedPluginConfigMap[key]) {
                          _context2.next = 6;
                          break;
                        }
                        _context2.next = 6;
                        return plugins.register(injectedPluginConfigMap[key], {
                          autoInit: true
                        }, {
                          autoInit: true
                        });
                      case 6:
                        _context2.next = 1;
                        break;
                      case 8:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2);
                })));
              }
              _context3.next = 3;
              return getInjectedResource('vs');
            case 3:
              injectedSetters = _context3.sent;
              injectedSetters.forEach(function (item) {
                setters.registerSetter(item.module.displayName, item.module);
              });
              if (injectedPlugins.length > 0 || injectedSetters.length > 0) {
                _Notification.success({
                  title: '成功注入以下插件',
                  content: /*#__PURE__*/React.createElement("div", null, injectedPlugins && injectedPlugins.map(function (item) {
                    return /*#__PURE__*/React.createElement("p", null, "\u8BBE\u8BA1\u5668\u63D2\u4EF6\uFF1A", /*#__PURE__*/React.createElement("b", null, item.name));
                  }), injectedSetters && injectedSetters.map(function (item) {
                    return /*#__PURE__*/React.createElement("p", null, "setter\uFF1A", /*#__PURE__*/React.createElement("b", null, item.name));
                  }))
                });
              }
            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
};
Inject.pluginName = 'LowcodePluginInjectAlt';
export default Inject;
Inject.meta = {
  dependencies: [],
  preferenceDeclaration: {
    title: '注入资源的主机地址',
    properties: [{
      key: 'injectServerHost',
      type: 'string',
      description: '注入资源的主机地址'
    }]
  }
};
export { injectAssets, injectComponents, filterPackages };