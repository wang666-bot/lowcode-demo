import _extends from "@babel/runtime/helpers/extends";
import _Icon from "@alifd/next/lib/icon";
import _Menu from "@alifd/next/lib/menu";
import { IPublicEnumContextMenuType } from '@alilc/lowcode-types';
import { Logger } from '@alilc/lowcode-utils';
import classNames from 'classnames';
import React from 'react';
import './context-menu.scss';
var logger = new Logger({
  level: 'warn',
  bizName: 'utils'
});
var Item = _Menu.Item,
  Divider = _Menu.Divider,
  PopupItem = _Menu.PopupItem;
var MAX_LEVEL = 2;
var Tree = function Tree(props) {
  var _props$options$nodes;
  var node = props.node;
  if (!node) {
    return /*#__PURE__*/React.createElement("div", {
      className: "engine-context-menu-tree-wrap"
    }, props.children);
  }
  var _ref = props.options.pluginContext || {},
    common = _ref.common;
  var _ref2 = (common === null || common === void 0 ? void 0 : common.utils) || {},
    intl = _ref2.intl;
  var indent = node.zLevel * 8 + 32;
  var style = {
    paddingLeft: indent,
    marginLeft: -indent,
    marginRight: -10,
    paddingRight: 10
  };
  return /*#__PURE__*/React.createElement(Tree, _extends({}, props, {
    node: node.parent
  }), /*#__PURE__*/React.createElement("div", {
    className: "engine-context-menu-title",
    onClick: function onClick() {
      var _props$options$destro, _props$options;
      (_props$options$destro = (_props$options = props.options).destroy) === null || _props$options$destro === void 0 ? void 0 : _props$options$destro.call(_props$options);
      node.select();
    },
    style: style
  }, ((_props$options$nodes = props.options.nodes) === null || _props$options$nodes === void 0 ? void 0 : _props$options$nodes[0].id) === node.id ? /*#__PURE__*/React.createElement(_Icon, {
    className: "engine-context-menu-tree-selecte-icon",
    size: "small",
    type: "success"
  }) : null, intl(node.title)), /*#__PURE__*/React.createElement("div", {
    className: "engine-context-menu-tree-children"
  }, props.children));
};
var destroyFn;
export function parseContextMenuAsReactNode(menus, options) {
  var _ref3 = options.pluginContext || {},
    common = _ref3.common,
    commonUI = _ref3.commonUI;
  var _ref4 = (common === null || common === void 0 ? void 0 : common.utils) || {},
    _ref4$intl = _ref4.intl,
    intl = _ref4$intl === void 0 ? function (title) {
      return title;
    } : _ref4$intl;
  var _ref5 = commonUI || {},
    HelpTip = _ref5.HelpTip;
  var children = [];
  menus.forEach(function (menu, index) {
    if (menu.type === IPublicEnumContextMenuType.SEPARATOR) {
      children.push( /*#__PURE__*/React.createElement(Divider, {
        key: menu.name || index
      }));
      return;
    }
    if (menu.type === IPublicEnumContextMenuType.MENU_ITEM) {
      if (menu.items && menu.items.length) {
        children.push( /*#__PURE__*/React.createElement(PopupItem, {
          className: classNames('engine-context-menu-item', {
            disabled: menu.disabled
          }),
          key: menu.name,
          label: /*#__PURE__*/React.createElement("div", {
            className: "engine-context-menu-text"
          }, intl(menu.title))
        }, /*#__PURE__*/React.createElement(_Menu, {
          className: "next-context engine-context-menu"
        }, parseContextMenuAsReactNode(menu.items, options))));
      } else {
        children.push( /*#__PURE__*/React.createElement(Item, {
          className: classNames('engine-context-menu-item', {
            disabled: menu.disabled
          }),
          disabled: menu.disabled,
          onClick: function onClick() {
            var _menu$action;
            (_menu$action = menu.action) === null || _menu$action === void 0 ? void 0 : _menu$action.call(menu);
          },
          key: menu.name
        }, /*#__PURE__*/React.createElement("div", {
          className: "engine-context-menu-text"
        }, menu.title ? intl(menu.title) : null, menu.help ? /*#__PURE__*/React.createElement(HelpTip, {
          size: "xs",
          help: menu.help,
          direction: "right"
        }) : null)));
      }
    }
    if (menu.type === IPublicEnumContextMenuType.NODE_TREE) {
      var _options$nodes;
      children.push( /*#__PURE__*/React.createElement(Tree, {
        node: (_options$nodes = options.nodes) === null || _options$nodes === void 0 ? void 0 : _options$nodes[0],
        options: options
      }));
    }
  });
  return children;
}
export function parseContextMenuProperties(menus, options, level) {
  var _destroyFn;
  if (level === void 0) {
    level = 1;
  }
  (_destroyFn = destroyFn) === null || _destroyFn === void 0 ? void 0 : _destroyFn();
  var nodes = options.nodes,
    destroy = options.destroy;
  if (level > MAX_LEVEL) {
    logger.warn('context menu level is too deep, please check your context menu config');
    return [];
  }
  return menus.filter(function (menu) {
    return !menu.condition || menu.condition && menu.condition(nodes || []);
  }).map(function (menu) {
    var name = menu.name,
      title = menu.title,
      _menu$type = menu.type,
      type = _menu$type === void 0 ? IPublicEnumContextMenuType.MENU_ITEM : _menu$type,
      help = menu.help;
    var result = {
      name: name,
      title: title,
      type: type,
      help: help,
      action: function action() {
        var _menu$action2;
        destroy === null || destroy === void 0 ? void 0 : destroy();
        (_menu$action2 = menu.action) === null || _menu$action2 === void 0 ? void 0 : _menu$action2.call(menu, nodes || [], options.event);
      },
      disabled: menu.disabled && menu.disabled(nodes || []) || false
    };
    if ('items' in menu && menu.items) {
      result.items = parseContextMenuProperties(typeof menu.items === 'function' ? menu.items(nodes || []) : menu.items, options, level + 1);
    }
    return result;
  }).reduce(function (menus, currentMenu) {
    if (!currentMenu.name) {
      return menus.concat([currentMenu]);
    }
    var index = menus.find(function (item) {
      return item.name === currentMenu.name;
    });
    if (!index) {
      return menus.concat([currentMenu]);
    } else {
      return menus;
    }
  }, []);
}
var cachedMenuItemHeight;
function getMenuItemHeight() {
  if (cachedMenuItemHeight) {
    return cachedMenuItemHeight;
  }
  var root = document.documentElement;
  var styles = getComputedStyle(root);
  var menuItemHeight = styles.getPropertyValue('--context-menu-item-height').trim();
  cachedMenuItemHeight = menuItemHeight;
  return menuItemHeight;
}
export function createContextMenu(children, _ref6) {
  var event = _ref6.event,
    _ref6$offset = _ref6.offset,
    offset = _ref6$offset === void 0 ? [0, 0] : _ref6$offset;
  event.preventDefault();
  event.stopPropagation();
  var viewportWidth = window.innerWidth;
  var viewportHeight = window.innerHeight;
  var dividerCount = React.Children.count(children.filter(function (child) {
    return /*#__PURE__*/React.isValidElement(child) && child.type === Divider;
  }));
  var popupItemCount = React.Children.count(children.filter(function (child) {
    return /*#__PURE__*/React.isValidElement(child) && (child.type === PopupItem || child.type === Item);
  }));
  var menuHeight = popupItemCount * parseInt(getMenuItemHeight(), 10) + dividerCount * 8 + 16;
  var menuWidthLimit = 200;
  var x = event.clientX + offset[0];
  var y = event.clientY + offset[1];
  if (x + menuWidthLimit > viewportWidth) {
    x = x - menuWidthLimit;
  }
  if (y + menuHeight > viewportHeight) {
    y = y - menuHeight;
  }
  var menuInstance = _Menu.create({
    target: document.body,
    offset: [x, y],
    children: children,
    className: 'engine-context-menu'
  });
  destroyFn = menuInstance.destroy;
  return destroyFn;
}