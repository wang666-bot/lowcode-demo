"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.ProvideViewPluginContext = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _lowcodeTypes = require("@alilc/lowcode-types");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
/**
 * 高阶组件（HOC）：为组件提供 view 插件上下文。
 *
 * @param {React.ComponentType} Component - 需要被封装的组件。
 * @param {string|string[]} viewName - 视图名称或视图名称数组，用于过滤特定的视图插件上下文。
 * @returns {React.ComponentType} 返回封装后的组件。
 *
 * @example
 * // 用法示例（函数组件）:
 * const EnhancedComponent = ProvideViewPluginContext(MyComponent, "viewName");
 */
var ProvideViewPluginContext = exports.ProvideViewPluginContext = function ProvideViewPluginContext(Component, viewName) {
  // 创建一个新的函数组件，以便在其中使用 Hooks
  return function WithPluginContext(props) {
    var _props$pluginContext;
    var getPluginContextFun = (0, _react.useCallback)(function (editorWindow) {
      if (!(editorWindow !== null && editorWindow !== void 0 && editorWindow.currentEditorView)) {
        return null;
      }
      if (viewName) {
        var items = editorWindow === null || editorWindow === void 0 ? void 0 : editorWindow.editorViews.filter(function (d) {
          return d.viewName === viewName || Array.isArray(viewName) && viewName.includes(d.viewName);
        });
        return items[0];
      } else {
        return editorWindow.currentEditorView;
      }
    }, []);
    var _ref = props.pluginContext || {},
      workspace = _ref.workspace;
    var _useState = (0, _react.useState)(getPluginContextFun(workspace === null || workspace === void 0 ? void 0 : workspace.window)),
      pluginContext = _useState[0],
      setPluginContext = _useState[1];
    (0, _react.useEffect)(function () {
      if (workspace !== null && workspace !== void 0 && workspace.window) {
        var ctx = getPluginContextFun(workspace.window);
        ctx && setPluginContext(ctx);
      }
      return workspace === null || workspace === void 0 ? void 0 : workspace.onChangeActiveEditorView(function () {
        var ctx = getPluginContextFun(workspace.window);
        ctx && setPluginContext(ctx);
      });
    }, [workspace, getPluginContextFun]);
    if (((_props$pluginContext = props.pluginContext) === null || _props$pluginContext === void 0 ? void 0 : _props$pluginContext.registerLevel) !== _lowcodeTypes.IPublicEnumPluginRegisterLevel.Workspace || !props.pluginContext) {
      return /*#__PURE__*/_react["default"].createElement(Component, props);
    }
    return /*#__PURE__*/_react["default"].createElement(Component, (0, _extends2["default"])({}, props, {
      pluginContext: pluginContext
    }));
  };
};