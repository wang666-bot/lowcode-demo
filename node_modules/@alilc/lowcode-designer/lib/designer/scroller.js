"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.Scroller = exports.ScrollTarget = void 0;
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _lowcodeUtils = require("@alilc/lowcode-utils");
var ScrollTarget = exports.ScrollTarget = /*#__PURE__*/function () {
  function ScrollTarget(target) {
    this.target = target;
    this.doc = void 0;
    if (isWindow(target)) {
      this.doc = target.document.documentElement;
    }
  }
  var _proto = ScrollTarget.prototype;
  _proto.scrollTo = function scrollTo(options) {
    this.target.scrollTo(options);
  };
  _proto.scrollToXY = function scrollToXY(x, y) {
    this.target.scrollTo(x, y);
  };
  (0, _createClass2["default"])(ScrollTarget, [{
    key: "left",
    get: function get() {
      return 'scrollX' in this.target ? this.target.scrollX : this.target.scrollLeft;
    }
  }, {
    key: "top",
    get: function get() {
      return 'scrollY' in this.target ? this.target.scrollY : this.target.scrollTop;
    }
  }, {
    key: "scrollHeight",
    get: function get() {
      return (this.doc || this.target).scrollHeight;
    }
  }, {
    key: "scrollWidth",
    get: function get() {
      return (this.doc || this.target).scrollWidth;
    }
  }]);
  return ScrollTarget;
}();
function isWindow(obj) {
  return obj && obj.document;
}
function easing(n) {
  return Math.sin(n * Math.PI / 2);
}
var SCROLL_ACCURACY = 30;
var Scroller = exports.Scroller = /*#__PURE__*/function () {
  function Scroller(scrollable) {
    this.pid = void 0;
    this.scrollable = void 0;
    this.scrollable = scrollable;
  }
  var _proto2 = Scroller.prototype;
  _proto2.scrollTo = function scrollTo(options) {
    var _this = this;
    this.cancel();
    var scrollTarget = this.scrollTarget;
    if (!scrollTarget) {
      return;
    }
    var pid;
    var left = scrollTarget.left;
    var top = scrollTarget.top;
    var end = function end() {
      _this.cancel();
    };
    if ((left === options.left || options.left == null) && top === options.top) {
      end();
      return;
    }
    var duration = 200;
    var start = +new Date();
    var animate = function animate() {
      if (pid !== _this.pid) {
        return;
      }
      var now = +new Date();
      var time = Math.min(1, (now - start) / duration);
      var eased = easing(time);
      var opt = {};
      if (options.left != null) {
        opt.left = eased * (options.left - left) + left;
      }
      if (options.top != null) {
        opt.top = eased * (options.top - top) + top;
      }
      scrollTarget.scrollTo(opt);
      if (time < 1) {
        _this.pid = requestAnimationFrame(animate);
        pid = _this.pid;
      } else {
        end();
      }
    };
    this.pid = requestAnimationFrame(animate);
    pid = this.pid;
  };
  _proto2.scrolling = function scrolling(point) {
    var _this2 = this;
    this.cancel();
    var _this$scrollable = this.scrollable,
      bounds = _this$scrollable.bounds,
      _this$scrollable$scal = _this$scrollable.scale,
      scale = _this$scrollable$scal === void 0 ? 1 : _this$scrollable$scal;
    var scrollTarget = this.scrollTarget;
    if (!scrollTarget || !bounds) {
      return;
    }
    var x = point.globalX;
    var y = point.globalY;
    var maxScrollHeight = scrollTarget.scrollHeight - bounds.height / scale;
    var maxScrollWidth = scrollTarget.scrollWidth - bounds.width / scale;
    var sx = scrollTarget.left;
    var sy = scrollTarget.top;
    var ax = 0;
    var ay = 0;
    if (y < bounds.top + SCROLL_ACCURACY) {
      ay = -Math.min(Math.max(bounds.top + SCROLL_ACCURACY - y, 10), 50) / scale;
    } else if (y > bounds.bottom - SCROLL_ACCURACY) {
      ay = Math.min(Math.max(y + SCROLL_ACCURACY - bounds.bottom, 10), 50) / scale;
    }
    if (x < bounds.left + SCROLL_ACCURACY) {
      ax = -Math.min(Math.max(bounds.top + SCROLL_ACCURACY - y, 10), 50) / scale;
    } else if (x > bounds.right - SCROLL_ACCURACY) {
      ax = Math.min(Math.max(x + SCROLL_ACCURACY - bounds.right, 10), 50) / scale;
    }
    if (!ax && !ay) {
      return;
    }
    var animate = function animate() {
      var scroll = false;
      if (ay > 0 && sy < maxScrollHeight || ay < 0 && sy > 0) {
        sy += ay;
        sy = Math.min(Math.max(sy, 0), maxScrollHeight);
        scroll = true;
      }
      if (ax > 0 && sx < maxScrollWidth || ax < 0 && sx > 0) {
        sx += ax;
        sx = Math.min(Math.max(sx, 0), maxScrollWidth);
        scroll = true;
      }
      if (!scroll) {
        return;
      }
      scrollTarget.scrollTo({
        left: sx,
        top: sy
      });
      _this2.pid = requestAnimationFrame(animate);
    };
    animate();
  };
  _proto2.cancel = function cancel() {
    if (this.pid) {
      cancelAnimationFrame(this.pid);
    }
    this.pid = undefined;
  };
  (0, _createClass2["default"])(Scroller, [{
    key: "scrollTarget",
    get: function get() {
      var target = this.scrollable.scrollTarget;
      if (!target) {
        return null;
      }
      if ((0, _lowcodeUtils.isElement)(target)) {
        target = new ScrollTarget(target);
        this.scrollable.scrollTarget = target;
      }
      return target;
    }
  }]);
  return Scroller;
}();