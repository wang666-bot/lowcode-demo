"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.Dragon = void 0;
exports.isDragAnyObject = isDragAnyObject;
exports.isDragNodeDataObject = isDragNodeDataObject;
exports.isDragNodeObject = isDragNodeObject;
exports.isInvalidPoint = isInvalidPoint;
exports.isLocateEvent = isLocateEvent;
exports.isSameAs = isSameAs;
exports.isShaken = isShaken;
exports.setShaken = setShaken;
var _initializerDefineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/initializerDefineProperty"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));
var _initializerWarningHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/initializerWarningHelper"));
var _lowcodeEditorCore = require("@alilc/lowcode-editor-core");
var _lowcodeTypes = require("@alilc/lowcode-types");
var _lowcodeUtils = require("@alilc/lowcode-utils");
var _simulator = require("../simulator");
var _misc = require("../utils/misc");
var _dec, _dec2, _dec3, _class, _descriptor, _descriptor2, _descriptor3;
/**
 * @deprecated use same function in @alilc/lowcode-utils
 */
function isDragNodeObject(obj) {
  return obj && obj.type === _lowcodeTypes.IPublicEnumDragObjectType.Node;
}

/**
 * @deprecated use same function in @alilc/lowcode-utils
 */
function isDragNodeDataObject(obj) {
  return obj && obj.type === _lowcodeTypes.IPublicEnumDragObjectType.NodeData;
}

/**
 * @deprecated use same function in @alilc/lowcode-utils
 */
function isDragAnyObject(obj) {
  return obj && obj.type !== _lowcodeTypes.IPublicEnumDragObjectType.NodeData && obj.type !== _lowcodeTypes.IPublicEnumDragObjectType.Node;
}
function isLocateEvent(e) {
  return e && e.type === 'LocateEvent';
}
var SHAKE_DISTANCE = 4;

/**
 * mouse shake check
 */
function isShaken(e1, e2) {
  if (e1.shaken) {
    return true;
  }
  if (e1.target !== e2.target) {
    return true;
  }
  return Math.pow(e1.clientY - e2.clientY, 2) + Math.pow(e1.clientX - e2.clientX, 2) > SHAKE_DISTANCE;
}
function isInvalidPoint(e, last) {
  return e.clientX === 0 && e.clientY === 0 && last && (Math.abs(last.clientX - e.clientX) > 5 || Math.abs(last.clientY - e.clientY) > 5);
}
function isSameAs(e1, e2) {
  return e1.clientY === e2.clientY && e1.clientX === e2.clientX;
}
function setShaken(e) {
  e.shaken = true;
}
function getSourceSensor(dragObject) {
  var _dragObject$nodes$, _dragObject$nodes$$do;
  if (!isDragNodeObject(dragObject)) {
    return null;
  }
  return ((_dragObject$nodes$ = dragObject.nodes[0]) === null || _dragObject$nodes$ === void 0 ? void 0 : (_dragObject$nodes$$do = _dragObject$nodes$.document) === null || _dragObject$nodes$$do === void 0 ? void 0 : _dragObject$nodes$$do.simulator) || null;
}
function isDragEvent(e) {
  var _e$type;
  return e === null || e === void 0 ? void 0 : (_e$type = e.type) === null || _e$type === void 0 ? void 0 : _e$type.startsWith('drag');
}
/**
 * Drag-on 拖拽引擎
 */
var Dragon = exports.Dragon = (_dec = _lowcodeEditorCore.obx.ref, _dec2 = _lowcodeEditorCore.obx.ref, _dec3 = _lowcodeEditorCore.obx.ref, (_class = /*#__PURE__*/function () {
  function Dragon(designer) {
    this.designer = designer;
    this.sensors = [];
    this.nodeInstPointerEvents = void 0;
    this.key = Math.random();
    /**
     * current active sensor, 可用于感应区高亮
     */
    (0, _initializerDefineProperty2["default"])(this, "_activeSensor", _descriptor, this);
    (0, _initializerDefineProperty2["default"])(this, "_dragging", _descriptor2, this);
    (0, _initializerDefineProperty2["default"])(this, "_canDrop", _descriptor3, this);
    this.viewName = void 0;
    this.emitter = (0, _lowcodeEditorCore.createModuleEventBus)('Dragon');
    (0, _lowcodeEditorCore.makeObservable)(this);
    this.viewName = designer.viewName;
  }

  /**
   * Quick listen a shell(container element) drag behavior
   * @param shell container element
   * @param boost boost got a drag object
   */
  var _proto = Dragon.prototype;
  _proto.from = function from(shell, boost) {
    var _this = this;
    var mousedown = function mousedown(e) {
      // ESC or RightClick
      if (e.which === 3 || e.button === 2) {
        return;
      }

      // Get a new node to be dragged
      var dragObject = boost(e);
      if (!dragObject) {
        return;
      }
      _this.boost(dragObject, e);
    };
    shell.addEventListener('mousedown', mousedown);
    return function () {
      shell.removeEventListener('mousedown', mousedown);
    };
  }

  /**
   * boost your dragObject for dragging(flying) 发射拖拽对象
   *
   * @param dragObject 拖拽对象
   * @param boostEvent 拖拽初始时事件
   */;
  _proto.boost = function boost(dragObject, boostEvent, fromRglNode) {
    var _this2 = this;
    var designer = this.designer;
    var masterSensors = this.getMasterSensors();
    var handleEvents = (0, _misc.makeEventsHandler)(boostEvent, masterSensors);
    var newBie = !isDragNodeObject(dragObject);
    var forceCopyState = isDragNodeObject(dragObject) && dragObject.nodes.some(function (node) {
      return typeof node.isSlot === 'function' ? node.isSlot() : node.isSlot;
    });
    var isBoostFromDragAPI = isDragEvent(boostEvent);
    var lastSensor;
    this._dragging = false;
    var getRGL = function getRGL(e) {
      var _nodeInst$node;
      var locateEvent = createLocateEvent(e);
      var sensor = chooseSensor(locateEvent);
      if (!sensor || !sensor.getNodeInstanceFromElement) return {};
      var nodeInst = sensor.getNodeInstanceFromElement(e.target);
      return (nodeInst === null || nodeInst === void 0 ? void 0 : (_nodeInst$node = nodeInst.node) === null || _nodeInst$node === void 0 ? void 0 : _nodeInst$node.getRGL()) || {};
    };
    var checkesc = function checkesc(e) {
      if (e.keyCode === 27) {
        designer.clearLocation();
        over();
      }
    };
    var copy = false;
    var checkcopy = function checkcopy(e) {
      /* istanbul ignore next */
      if (isDragEvent(e) && e.dataTransfer) {
        if (newBie || forceCopyState) {
          e.dataTransfer.dropEffect = 'copy';
        }
        return;
      }
      if (newBie) {
        return;
      }
      if (e.altKey || e.ctrlKey) {
        copy = true;
        _this2.setCopyState(true);
        /* istanbul ignore next */
        if (isDragEvent(e) && e.dataTransfer) {
          e.dataTransfer.dropEffect = 'copy';
        }
      } else {
        copy = false;
        if (!forceCopyState) {
          _this2.setCopyState(false);
          /* istanbul ignore next */
          if (isDragEvent(e) && e.dataTransfer) {
            e.dataTransfer.dropEffect = 'move';
          }
        }
      }
    };
    var lastArrive;
    var drag = function drag(e) {
      // FIXME: donot setcopy when: newbie & no location
      checkcopy(e);
      if (isInvalidPoint(e, lastArrive)) return;
      if (lastArrive && isSameAs(e, lastArrive)) {
        lastArrive = e;
        return;
      }
      lastArrive = e;
      var _getRGL = getRGL(e),
        isRGL = _getRGL.isRGL,
        rglNode = _getRGL.rglNode;
      var locateEvent = createLocateEvent(e);
      var sensor = chooseSensor(locateEvent);

      /* istanbul ignore next */
      if (isRGL) {
        // 禁止被拖拽元素的阻断
        var nodeInst = dragObject.nodes[0].getDOMNode();
        if (nodeInst && nodeInst.style) {
          _this2.nodeInstPointerEvents = true;
          nodeInst.style.pointerEvents = 'none';
        }
        // 原生拖拽
        _this2.emitter.emit('rgl.sleeping', false);
        if (fromRglNode && fromRglNode.id === rglNode.id) {
          designer.clearLocation();
          _this2.clearState();
          _this2.emitter.emit('drag', locateEvent);
          return;
        }
        _this2._canDrop = !!(sensor !== null && sensor !== void 0 && sensor.locate(locateEvent));
        if (_this2._canDrop) {
          var _locateEvent$dragObje;
          _this2.emitter.emit('rgl.add.placeholder', {
            rglNode: rglNode,
            fromRglNode: fromRglNode,
            node: (_locateEvent$dragObje = locateEvent.dragObject) === null || _locateEvent$dragObje === void 0 ? void 0 : _locateEvent$dragObje.nodes[0],
            event: e
          });
          designer.clearLocation();
          _this2.clearState();
          _this2.emitter.emit('drag', locateEvent);
          return;
        }
      } else {
        _this2._canDrop = false;
        _this2.emitter.emit('rgl.remove.placeholder');
        _this2.emitter.emit('rgl.sleeping', true);
      }
      if (sensor) {
        sensor.fixEvent(locateEvent);
        sensor.locate(locateEvent);
      } else {
        designer.clearLocation();
      }
      _this2.emitter.emit('drag', locateEvent);
    };
    var dragstart = function dragstart() {
      _this2._dragging = true;
      setShaken(boostEvent);
      var locateEvent = createLocateEvent(boostEvent);
      if (newBie || forceCopyState) {
        _this2.setCopyState(true);
      } else {
        chooseSensor(locateEvent);
      }
      _this2.setDraggingState(true);
      // ESC cancel drag
      if (!isBoostFromDragAPI) {
        handleEvents(function (doc) {
          doc.addEventListener('keydown', checkesc, false);
        });
      }
      _this2.emitter.emit('dragstart', locateEvent);
    };

    // route: drag-move
    var move = function move(e) {
      /* istanbul ignore next */
      if (isBoostFromDragAPI) {
        e.preventDefault();
      }
      if (_this2._dragging) {
        // process dragging
        drag(e);
        return;
      }

      // first move check is shaken
      if (isShaken(boostEvent, e)) {
        // is shaken dragstart
        dragstart();
        drag(e);
      }
    };
    var didDrop = true;
    /* istanbul ignore next */
    var drop = function drop(e) {
      e.preventDefault();
      e.stopPropagation();
      didDrop = true;
    };

    // end-tail drag process
    var over = function over(e) {
      // 禁止被拖拽元素的阻断
      if (_this2.nodeInstPointerEvents) {
        var nodeInst = dragObject.nodes[0].getDOMNode();
        if (nodeInst && nodeInst.style) {
          nodeInst.style.pointerEvents = '';
        }
        _this2.nodeInstPointerEvents = false;
      }

      // 发送drop事件
      if (e) {
        var _getRGL2 = getRGL(e),
          isRGL = _getRGL2.isRGL,
          rglNode = _getRGL2.rglNode;
        /* istanbul ignore next */
        if (isRGL && _this2._canDrop && _this2._dragging) {
          var tarNode = dragObject.nodes[0];
          if (rglNode.id !== tarNode.id) {
            var _designer$project$cur;
            // 避免死循环
            _this2.emitter.emit('rgl.drop', {
              rglNode: rglNode,
              node: tarNode
            });
            var selection = (_designer$project$cur = designer.project.currentDocument) === null || _designer$project$cur === void 0 ? void 0 : _designer$project$cur.selection;
            selection === null || selection === void 0 ? void 0 : selection.select(tarNode.id);
          }
        }
      }

      // 移除磁帖占位消息
      _this2.emitter.emit('rgl.remove.placeholder');

      /* istanbul ignore next */
      if (e && isDragEvent(e)) {
        e.preventDefault();
      }
      if (lastSensor) {
        lastSensor.deactiveSensor();
      }
      /* istanbul ignore next */
      if (isBoostFromDragAPI) {
        if (!didDrop) {
          designer.clearLocation();
        }
      } else {
        _this2.setNativeSelection(true);
      }
      _this2.clearState();
      var exception;
      if (_this2._dragging) {
        _this2._dragging = false;
        try {
          _this2.emitter.emit('dragend', {
            dragObject: dragObject,
            copy: copy
          });
        } catch (ex) /* istanbul ignore next */{
          exception = ex;
        }
      }
      designer.clearLocation();
      handleEvents(function (doc) {
        /* istanbul ignore next */
        if (isBoostFromDragAPI) {
          doc.removeEventListener('dragover', move, true);
          doc.removeEventListener('dragend', over, true);
          doc.removeEventListener('drop', drop, true);
        } else {
          doc.removeEventListener('mousemove', move, true);
          doc.removeEventListener('mouseup', over, true);
        }
        doc.removeEventListener('mousedown', over, true);
        doc.removeEventListener('keydown', checkesc, false);
        doc.removeEventListener('keydown', checkcopy, false);
        doc.removeEventListener('keyup', checkcopy, false);
      });
      /* istanbul ignore next */
      if (exception) {
        throw exception;
      }
    };

    // create drag locate event
    var createLocateEvent = function createLocateEvent(e) {
      var _e$view;
      var evt = {
        type: 'LocateEvent',
        dragObject: dragObject,
        target: e.target,
        originalEvent: e
      };
      var sourceDocument = (_e$view = e.view) === null || _e$view === void 0 ? void 0 : _e$view.document;

      // event from current document
      if (!sourceDocument || sourceDocument === document) {
        evt.globalX = e.clientX;
        evt.globalY = e.clientY;
      } else /* istanbul ignore next */{
          // event from simulator sandbox
          var srcSim;
          var lastSim = lastSensor && (0, _simulator.isSimulatorHost)(lastSensor) ? lastSensor : null;
          // check source simulator
          if (lastSim && lastSim.contentDocument === sourceDocument) {
            srcSim = lastSim;
          } else {
            srcSim = masterSensors.find(function (sim) {
              return sim.contentDocument === sourceDocument;
            });
            if (!srcSim && lastSim) {
              srcSim = lastSim;
            }
          }
          if (srcSim) {
            // transform point by simulator
            var g = srcSim.viewport.toGlobalPoint(e);
            evt.globalX = g.clientX;
            evt.globalY = g.clientY;
            evt.canvasX = e.clientX;
            evt.canvasY = e.clientY;
            evt.sensor = srcSim;
          } else {
            // this condition will not happen, just make sure ts ok
            evt.globalX = e.clientX;
            evt.globalY = e.clientY;
          }
        }
      return evt;
    };
    var sourceSensor = getSourceSensor(dragObject);
    /* istanbul ignore next */
    var chooseSensor = function chooseSensor(e) {
      // this.sensors will change on dragstart
      var sensors = _this2.sensors.concat(masterSensors);
      var sensor = e.sensor && e.sensor.isEnter(e) ? e.sensor : sensors.find(function (s) {
        return s.sensorAvailable && s.isEnter(e);
      });
      if (!sensor) {
        // TODO: enter some area like componentspanel cancel
        if (lastSensor) {
          sensor = lastSensor;
        } else if (e.sensor) {
          sensor = e.sensor;
        } else if (sourceSensor) {
          sensor = sourceSensor;
        }
      }
      if (sensor !== lastSensor) {
        if (lastSensor) {
          lastSensor.deactiveSensor();
        }
        lastSensor = sensor;
      }
      if (sensor) {
        e.sensor = sensor;
        sensor.fixEvent(e);
      }
      _this2._activeSensor = sensor;
      return sensor;
    };

    /* istanbul ignore next */
    if (isDragEvent(boostEvent)) {
      var dataTransfer = boostEvent.dataTransfer;
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'all';
        try {
          dataTransfer.setData('application/json', '{}');
        } catch (ex) {
          // ignore
        }
      }
      dragstart();
    } else {
      this.setNativeSelection(false);
    }
    handleEvents(function (doc) {
      /* istanbul ignore next */
      if (isBoostFromDragAPI) {
        doc.addEventListener('dragover', move, true);
        // dragexit
        didDrop = false;
        doc.addEventListener('drop', drop, true);
        doc.addEventListener('dragend', over, true);
      } else {
        doc.addEventListener('mousemove', move, true);
        doc.addEventListener('mouseup', over, true);
      }
      doc.addEventListener('mousedown', over, true);
    });

    // future think: drag things from browser-out or a iframe-pane

    if (!newBie && !isBoostFromDragAPI) {
      handleEvents(function (doc) {
        doc.addEventListener('keydown', checkcopy, false);
        doc.addEventListener('keyup', checkcopy, false);
      });
    }
  }

  /* istanbul ignore next */;
  _proto.getMasterSensors = function getMasterSensors() {
    return Array.from(new Set(this.designer.project.documents.map(function (doc) {
      var _doc$simulator;
      if (doc.active && (_doc$simulator = doc.simulator) !== null && _doc$simulator !== void 0 && _doc$simulator.sensorAvailable) {
        return doc.simulator;
      }
      return null;
    }).filter(Boolean)));
  };
  _proto.getSimulators = function getSimulators() {
    return new Set(this.designer.project.documents.map(function (doc) {
      return doc.simulator;
    }));
  }

  // #region ======== drag and drop helpers ============
  ;
  _proto.setNativeSelection = function setNativeSelection(enableFlag) {
    (0, _lowcodeUtils.setNativeSelection)(enableFlag);
    this.getSimulators().forEach(function (sim) {
      sim === null || sim === void 0 ? void 0 : sim.setNativeSelection(enableFlag);
    });
  }

  /**
   * 设置拖拽态
   */;
  _proto.setDraggingState = function setDraggingState(state) {
    _lowcodeUtils.cursor.setDragging(state);
    this.getSimulators().forEach(function (sim) {
      sim === null || sim === void 0 ? void 0 : sim.setDraggingState(state);
    });
  }

  /**
   * 设置拷贝态
   */;
  _proto.setCopyState = function setCopyState(state) {
    _lowcodeUtils.cursor.setCopy(state);
    this.getSimulators().forEach(function (sim) {
      sim === null || sim === void 0 ? void 0 : sim.setCopyState(state);
    });
  }

  /**
   * 清除所有态：拖拽态、拷贝态
   */;
  _proto.clearState = function clearState() {
    _lowcodeUtils.cursor.release();
    this.getSimulators().forEach(function (sim) {
      sim === null || sim === void 0 ? void 0 : sim.clearState();
    });
  }
  // #endregion

  /**
   * 添加投放感应区
   */;
  _proto.addSensor = function addSensor(sensor) {
    this.sensors.push(sensor);
  }

  /**
   * 移除投放感应
   */;
  _proto.removeSensor = function removeSensor(sensor) {
    var i = this.sensors.indexOf(sensor);
    if (i > -1) {
      this.sensors.splice(i, 1);
    }
  };
  _proto.onDragstart = function onDragstart(func) {
    var _this3 = this;
    this.emitter.on('dragstart', func);
    return function () {
      _this3.emitter.removeListener('dragstart', func);
    };
  };
  _proto.onDrag = function onDrag(func) {
    var _this4 = this;
    this.emitter.on('drag', func);
    return function () {
      _this4.emitter.removeListener('drag', func);
    };
  };
  _proto.onDragend = function onDragend(func) {
    var _this5 = this;
    this.emitter.on('dragend', func);
    return function () {
      _this5.emitter.removeListener('dragend', func);
    };
  };
  (0, _createClass2["default"])(Dragon, [{
    key: "activeSensor",
    get: function get() {
      return this._activeSensor;
    }
  }, {
    key: "dragging",
    get: function get() {
      return this._dragging;
    }
  }]);
  return Dragon;
}(), (_descriptor = (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "_activeSensor", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "_dragging", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
}), _descriptor3 = (0, _applyDecoratedDescriptor2["default"])(_class.prototype, "_canDrop", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function initializer() {
    return false;
  }
})), _class));