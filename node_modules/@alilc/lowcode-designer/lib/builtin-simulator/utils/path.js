"use strict";

exports.__esModule = true;
exports.generateComponentName = generateComponentName;
exports.getNormalizedImportPath = getNormalizedImportPath;
exports.isPackagePath = isPackagePath;
exports.joinPath = joinPath;
exports.makeRelativePath = makeRelativePath;
exports.removeVersion = removeVersion;
exports.resolveAbsoluatePath = resolveAbsoluatePath;
exports.toTitleCase = toTitleCase;
/**
 * Check whether a component is external package, e.g. @ali/uxcore
 * @param path Component path
 */
function isPackagePath(path) {
  return !path.startsWith('.') && !path.startsWith('/');
}

/**
 * Title cased string
 * @param s original string
 */
function toTitleCase(s) {
  return s.split(/[-_ .]+/).map(function (token) {
    return token[0].toUpperCase() + token.substring(1);
  }).join('');
}

/**
 * Make up an import name/tag for components
 * @param path Original path name
 */
function generateComponentName(path) {
  var parts = path.split('/');
  var name = parts.pop();
  if (name && /^index\./.test(name)) {
    name = parts.pop();
  }
  return name ? toTitleCase(name) : 'Component';
}

/**
 * normalizing import path for easier comparison
 */
function getNormalizedImportPath(path) {
  var segments = path.split('/');
  var basename = segments.pop();
  if (!basename) {
    return path;
  }
  var ignoredExtensions = ['.ts', '.js', '.tsx', '.jsx'];
  var extIndex = basename.lastIndexOf('.');
  if (extIndex > -1) {
    var ext = basename.slice(extIndex);
    if (ignoredExtensions.includes(ext)) {
      basename = basename.slice(0, extIndex);
    }
  }
  if (basename !== 'index') {
    segments.push(basename);
  }
  return segments.join('/');
}

/**
 * make a relative path
 *
 * @param toPath abolute path
 * @param fromPath absolute path
 */
function makeRelativePath(toPath, fromPath) {
  // not a absolute path, eg. @ali/uxcore
  if (!toPath.startsWith('/')) {
    return toPath;
  }
  var toParts = toPath.split('/');
  var fromParts = fromPath.split('/');

  // find shared path header
  var length = Math.min(fromParts.length, toParts.length);
  var sharedUpTo = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      sharedUpTo = i;
      break;
    }
  }

  // find how many levels to go up from
  // minus another 1 since we do not include the final
  var numGoUp = fromParts.length - sharedUpTo - 1;

  // generate final path
  var outputParts = [];
  if (numGoUp === 0) {
    // in the same dir
    outputParts.push('.');
  } else {
    // needs to go up
    for (var _i = 0; _i < numGoUp; ++_i) {
      outputParts.push('..');
    }
  }
  outputParts = outputParts.concat(toParts.slice(sharedUpTo));
  return outputParts.join('/');
}
function normalizeArray(parts, allowAboveRoot) {
  var res = [];
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i];

    // ignore empty parts
    if (!p || p === '.') {
      continue;
    }
    if (p === '..') {
      if (res.length && res[res.length - 1] !== '..') {
        res.pop();
      } else if (allowAboveRoot) {
        res.push('..');
      }
    } else {
      res.push(p);
    }
  }
  return res;
}
function normalize(path) {
  var isAbsolute = path[0] === '/';
  var segments = normalizeArray(path.split('/'), !isAbsolute);
  if (isAbsolute) {
    segments.unshift('');
  } else if (segments.length < 1 || segments[0] !== '..') {
    segments.unshift('.');
  }
  return segments.join('/');
}

/**
 * Resolve component with absolute path to relative path
 * @param path absolute path of component from project
 */
function resolveAbsoluatePath(path, base) {
  if (!path.startsWith('.')) {
    // eg.  /usr/path/to, @ali/button
    return path;
  }
  path = path.replace(/\\/g, '/');
  if (base.slice(-1) !== '/') {
    base += '/';
  }
  return normalize(base + path);
}
function joinPath() {
  var path = '';
  for (var _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) {
    segments[_key] = arguments[_key];
  }
  for (var _i2 = 0, _segments = segments; _i2 < _segments.length; _i2++) {
    var seg = _segments[_i2];
    if (seg) {
      if (path === '') {
        path += seg;
      } else {
        path += "/" + seg;
      }
    }
  }
  return normalize(path);
}
function removeVersion(path) {
  if (path.lastIndexOf('@') > 0) {
    path = path.replace(/(@?[^@]+)(@[\w.-]+)(.+)/, '$1$3');
  }
  return path;
}