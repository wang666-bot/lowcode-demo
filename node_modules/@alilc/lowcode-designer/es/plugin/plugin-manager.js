import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _createClass from "@babel/runtime/helpers/createClass";
function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { engineConfig } from '@alilc/lowcode-editor-core';
import { getLogger } from '@alilc/lowcode-utils';
import { filterValidOptions, isLowCodeRegisterOptions } from './plugin-utils';
import { LowCodePluginRuntime } from './plugin';
// eslint-disable-next-line import/no-named-as-default
import LowCodePluginContext from './plugin-context';
import { invariant } from '../utils';
import sequencify from './sequencify';
import semverSatisfies from 'semver/functions/satisfies';
var logger = getLogger({
  level: 'warn',
  bizName: 'designer:pluginManager'
});

// 保留的事件前缀
var RESERVED_EVENT_PREFIX = ['designer', 'editor', 'skeleton', 'renderer', 'render', 'utils', 'plugin', 'engine', 'editor-core', 'engine-core', 'plugins', 'event', 'events', 'log', 'logger', 'ctx', 'context'];
export var LowCodePluginManager = /*#__PURE__*/function () {
  function LowCodePluginManager(contextApiAssembler, viewName) {
    var _this = this;
    if (viewName === void 0) {
      viewName = 'global';
    }
    this.viewName = viewName;
    this.plugins = [];
    this.pluginsMap = new Map();
    this.pluginContextMap = new Map();
    this.pluginPreference = new Map();
    this.contextApiAssembler = void 0;
    this._getLowCodePluginContext = function (options) {
      var pluginName = options.pluginName;
      var context = _this.pluginContextMap.get(pluginName);
      if (!context) {
        context = new LowCodePluginContext(options, _this.contextApiAssembler);
        _this.pluginContextMap.set(pluginName, context);
      }
      return context;
    };
    this.contextApiAssembler = contextApiAssembler;
  }
  var _proto = LowCodePluginManager.prototype;
  _proto.isEngineVersionMatched = function isEngineVersionMatched(versionExp) {
    var engineVersion = engineConfig.get('ENGINE_VERSION');
    // ref: https://github.com/npm/node-semver#functions
    // 1.0.1-beta should match '^1.0.0'
    return semverSatisfies(engineVersion, versionExp, {
      includePrerelease: true
    });
  }

  /**
   * register a plugin
   * @param pluginConfigCreator - a creator function which returns the plugin config
   * @param options - the plugin options
   * @param registerOptions - the plugin register options
   */;
  _proto.register =
  /*#__PURE__*/
  function () {
    var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(pluginModel, options, registerOptions) {
      var _newPluginModel$meta, _registerOptions, _registerOptions2;
      var pluginName, _pluginModel$meta, meta, preferenceDeclaration, engines, eventPrefix, isReservedPrefix, ctx, customFilterValidOptions, pluginTransducer, newPluginModel, newOptions, config, allowOverride, originalPlugin, engineVersionExp, plugin;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            // registerOptions maybe in the second place
            if (isLowCodeRegisterOptions(options)) {
              registerOptions = options;
              options = {};
            }
            pluginName = pluginModel.pluginName, _pluginModel$meta = pluginModel.meta, meta = _pluginModel$meta === void 0 ? {} : _pluginModel$meta;
            preferenceDeclaration = meta.preferenceDeclaration, engines = meta.engines; // filter invalid eventPrefix
            eventPrefix = meta.eventPrefix;
            isReservedPrefix = RESERVED_EVENT_PREFIX.find(function (item) {
              return item === eventPrefix;
            });
            if (isReservedPrefix) {
              meta.eventPrefix = undefined;
              logger.warn("plugin " + pluginName + " is trying to use " + eventPrefix + " as event prefix, which is a reserved event prefix, please use another one");
            }
            ctx = this._getLowCodePluginContext({
              pluginName: pluginName,
              meta: meta
            });
            customFilterValidOptions = engineConfig.get('customPluginFilterOptions', filterValidOptions);
            pluginTransducer = engineConfig.get('customPluginTransducer', null);
            if (!pluginTransducer) {
              _context.next = 15;
              break;
            }
            _context.next = 12;
            return pluginTransducer(pluginModel, ctx, options);
          case 12:
            _context.t0 = _context.sent;
            _context.next = 16;
            break;
          case 15:
            _context.t0 = pluginModel;
          case 16:
            newPluginModel = _context.t0;
            newOptions = customFilterValidOptions(options, (_newPluginModel$meta = newPluginModel.meta) === null || _newPluginModel$meta === void 0 ? void 0 : _newPluginModel$meta.preferenceDeclaration);
            config = newPluginModel(ctx, newOptions); // compat the legacy way to declare pluginName
            // @ts-ignore
            pluginName = pluginName || config.name;
            invariant(pluginName, 'pluginConfigCreator.pluginName required', config);
            ctx.setPreference(pluginName, preferenceDeclaration);
            allowOverride = ((_registerOptions = registerOptions) === null || _registerOptions === void 0 ? void 0 : _registerOptions.override) === true;
            if (!this.pluginsMap.has(pluginName)) {
              _context.next = 32;
              break;
            }
            if (allowOverride) {
              _context.next = 28;
              break;
            }
            throw new Error("Plugin with name " + pluginName + " exists");
          case 28:
            // clear existing plugin
            originalPlugin = this.pluginsMap.get(pluginName);
            logger.log('plugin override, originalPlugin with name ', pluginName, ' will be destroyed, config:', originalPlugin === null || originalPlugin === void 0 ? void 0 : originalPlugin.config);
            originalPlugin === null || originalPlugin === void 0 ? void 0 : originalPlugin.destroy();
            this.pluginsMap["delete"](pluginName);
          case 32:
            engineVersionExp = engines && engines.lowcodeEngine;
            if (!(engineVersionExp && !this.isEngineVersionMatched(engineVersionExp))) {
              _context.next = 35;
              break;
            }
            throw new Error("plugin " + pluginName + " skipped, engine check failed, current engine version is " + engineConfig.get('ENGINE_VERSION') + ", meta.engines.lowcodeEngine is " + engineVersionExp);
          case 35:
            plugin = new LowCodePluginRuntime(pluginName, this, config, meta); // support initialization of those plugins which registered
            // after normal initialization by plugin-manager
            if (!((_registerOptions2 = registerOptions) !== null && _registerOptions2 !== void 0 && _registerOptions2.autoInit)) {
              _context.next = 39;
              break;
            }
            _context.next = 39;
            return plugin.init();
          case 39:
            this.plugins.push(plugin);
            this.pluginsMap.set(pluginName, plugin);
            logger.log("plugin registered with pluginName: " + pluginName + ", config: ", config, 'meta:', meta);
          case 42:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function register(_x, _x2, _x3) {
      return _register.apply(this, arguments);
    }
    return register;
  }();
  _proto.get = function get(pluginName) {
    return this.pluginsMap.get(pluginName);
  };
  _proto.getAll = function getAll() {
    return this.plugins;
  };
  _proto.has = function has(pluginName) {
    return this.pluginsMap.has(pluginName);
  };
  _proto["delete"] = /*#__PURE__*/function () {
    var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(pluginName) {
      var plugin, idx;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            plugin = this.plugins.find(function (_ref) {
              var name = _ref.name;
              return name === pluginName;
            });
            if (plugin) {
              _context2.next = 3;
              break;
            }
            return _context2.abrupt("return", false);
          case 3:
            _context2.next = 5;
            return plugin.destroy();
          case 5:
            idx = this.plugins.indexOf(plugin);
            this.plugins.splice(idx, 1);
            return _context2.abrupt("return", this.pluginsMap["delete"](pluginName));
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function _delete(_x4) {
      return _delete2.apply(this, arguments);
    }
    return _delete;
  }();
  _proto.init = /*#__PURE__*/function () {
    var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(pluginPreference) {
      var pluginNames, pluginObj, _sequencify, missingTasks, sequence, _iterator, _step, pluginName;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            pluginNames = [];
            pluginObj = {};
            this.pluginPreference = pluginPreference;
            this.plugins.forEach(function (plugin) {
              pluginNames.push(plugin.name);
              pluginObj[plugin.name] = plugin;
            });
            _sequencify = sequencify(pluginObj, pluginNames), missingTasks = _sequencify.missingTasks, sequence = _sequencify.sequence;
            invariant(!missingTasks.length, 'plugin dependency missing', missingTasks);
            logger.log('load plugin sequence:', sequence);
            _iterator = _createForOfIteratorHelperLoose(sequence);
          case 8:
            if ((_step = _iterator()).done) {
              _context3.next = 21;
              break;
            }
            pluginName = _step.value;
            _context3.prev = 10;
            _context3.next = 13;
            return this.pluginsMap.get(pluginName).init();
          case 13:
            _context3.next = 19;
            break;
          case 15:
            _context3.prev = 15;
            _context3.t0 = _context3["catch"](10);
            logger.error("Failed to init plugin:" + pluginName + ", it maybe affect those plugins which depend on this.");
            logger.error(_context3.t0);
          case 19:
            _context3.next = 8;
            break;
          case 21:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[10, 15]]);
    }));
    function init(_x5) {
      return _init.apply(this, arguments);
    }
    return init;
  }();
  _proto.destroy = /*#__PURE__*/function () {
    var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
      var _iterator2, _step2, plugin;
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _iterator2 = _createForOfIteratorHelperLoose(this.plugins);
          case 1:
            if ((_step2 = _iterator2()).done) {
              _context4.next = 7;
              break;
            }
            plugin = _step2.value;
            _context4.next = 5;
            return plugin.destroy();
          case 5:
            _context4.next = 1;
            break;
          case 7:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function destroy() {
      return _destroy.apply(this, arguments);
    }
    return destroy;
  }();
  _proto.getPluginPreference = function getPluginPreference(pluginName) {
    if (!this.pluginPreference) {
      return null;
    }
    return this.pluginPreference.get(pluginName);
  };
  _proto.toProxy = function toProxy() {
    return new Proxy(this, {
      get: function get(target, prop, receiver) {
        if (target.pluginsMap.has(prop)) {
          var _target$pluginsMap$ge;
          // 禁用态的插件，直接返回 undefined
          if (target.pluginsMap.get(prop).disabled) {
            return undefined;
          }
          return (_target$pluginsMap$ge = target.pluginsMap.get(prop)) === null || _target$pluginsMap$ge === void 0 ? void 0 : _target$pluginsMap$ge.toProxy();
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }

  /* istanbul ignore next */;
  _proto.setDisabled = function setDisabled(pluginName, flag) {
    var _this$pluginsMap$get;
    if (flag === void 0) {
      flag = true;
    }
    logger.warn("plugin:" + pluginName + " has been set disable:" + flag);
    (_this$pluginsMap$get = this.pluginsMap.get(pluginName)) === null || _this$pluginsMap$get === void 0 ? void 0 : _this$pluginsMap$get.setDisabled(flag);
  };
  _proto.dispose = /*#__PURE__*/function () {
    var _dispose = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return this.destroy();
          case 2:
            this.plugins = [];
            this.pluginsMap.clear();
          case 4:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function dispose() {
      return _dispose.apply(this, arguments);
    }
    return dispose;
  }();
  _createClass(LowCodePluginManager, [{
    key: "size",
    get: function get() {
      return this.pluginsMap.size;
    }
  }]);
  return LowCodePluginManager;
}();