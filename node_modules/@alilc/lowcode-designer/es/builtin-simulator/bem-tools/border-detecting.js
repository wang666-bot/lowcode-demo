import _createClass from "@babel/runtime/helpers/createClass";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
var _class, _class2;
import { Component, Fragment, PureComponent } from 'react';
import classNames from 'classnames';
import { computed, observer, Title } from '@alilc/lowcode-editor-core';
import { getClosestNode } from '@alilc/lowcode-utils';
import { intl } from '../../locale';
export var BorderDetectingInstance = /*#__PURE__*/function (_PureComponent) {
  _inheritsLoose(BorderDetectingInstance, _PureComponent);
  function BorderDetectingInstance() {
    return _PureComponent.apply(this, arguments) || this;
  }
  var _proto = BorderDetectingInstance.prototype;
  _proto.render = function render() {
    var _this$props = this.props,
      title = _this$props.title,
      rect = _this$props.rect,
      scale = _this$props.scale,
      scrollX = _this$props.scrollX,
      scrollY = _this$props.scrollY,
      isLocked = _this$props.isLocked;
    if (!rect) {
      return null;
    }
    var style = {
      width: rect.width * scale,
      height: rect.height * scale,
      transform: "translate(" + (scrollX + rect.left) * scale + "px, " + (scrollY + rect.top) * scale + "px)"
    };
    var className = classNames('lc-borders lc-borders-detecting');

    // TODO:
    // 1. thinkof icon
    // 2. thinkof top|bottom|inner space

    return /*#__PURE__*/React.createElement("div", {
      className: className,
      style: style
    }, /*#__PURE__*/React.createElement(Title, {
      title: title,
      className: "lc-borders-title"
    }), isLocked ? /*#__PURE__*/React.createElement(Title, {
      title: intl('locked'),
      className: "lc-borders-status"
    }) : null);
  };
  return BorderDetectingInstance;
}(PureComponent);
export var BorderDetecting = observer(_class = (_class2 = /*#__PURE__*/function (_Component) {
  _inheritsLoose(BorderDetecting, _Component);
  function BorderDetecting() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto2 = BorderDetecting.prototype;
  _proto2.render = function render() {
    var _current$componentMet,
      _this = this;
    var host = this.props.host;
    var current = this.current;
    var canHoverHook = current === null || current === void 0 ? void 0 : (_current$componentMet = current.componentMeta.advanced.callbacks) === null || _current$componentMet === void 0 ? void 0 : _current$componentMet.onHoverHook;
    var canHover = canHoverHook && typeof canHoverHook === 'function' ? canHoverHook(current.internalToShellNode()) : true;
    if (!canHover || !current || host.viewport.scrolling || host.liveEditing.editing) {
      return null;
    }

    // rootNode, hover whole viewport
    var focusNode = current.document.focusNode;
    if (!focusNode.contains(current)) {
      return null;
    }
    if (current.contains(focusNode)) {
      var bounds = host.viewport.bounds;
      return /*#__PURE__*/React.createElement(BorderDetectingInstance, {
        key: "line-root",
        title: current.title,
        scale: this.scale,
        scrollX: host.viewport.scrollX,
        scrollY: host.viewport.scrollY,
        rect: new DOMRect(0, 0, bounds.width, bounds.height)
      });
    }
    var lockedNode = getClosestNode(current, function (n) {
      var _n$parent;
      // 假如当前节点就是 locked 状态，要从当前节点的父节点开始查找
      return !!(current !== null && current !== void 0 && current.isLocked ? (_n$parent = n.parent) === null || _n$parent === void 0 ? void 0 : _n$parent.isLocked : n.isLocked);
    });
    if (lockedNode && lockedNode.getId() !== current.getId()) {
      // 选中父节锁定的节点
      return /*#__PURE__*/React.createElement(BorderDetectingInstance, {
        key: "line-h",
        title: current.title,
        scale: this.scale,
        scrollX: this.scrollX,
        scrollY: this.scrollY
        // @ts-ignore
        ,
        rect: host.computeComponentInstanceRect(host.getComponentInstances(lockedNode)[0], lockedNode.componentMeta.rootSelector),
        isLocked: (lockedNode === null || lockedNode === void 0 ? void 0 : lockedNode.getId()) !== current.getId()
      });
    }
    var instances = host.getComponentInstances(current);
    if (!instances || instances.length < 1) {
      return null;
    }
    if (instances.length === 1) {
      return /*#__PURE__*/React.createElement(BorderDetectingInstance, {
        key: "line-h",
        title: current.title,
        scale: this.scale,
        scrollX: this.scrollX,
        scrollY: this.scrollY,
        rect: host.computeComponentInstanceRect(instances[0], current.componentMeta.rootSelector)
      });
    }
    return /*#__PURE__*/React.createElement(Fragment, null, instances.map(function (inst, i) {
      return /*#__PURE__*/React.createElement(BorderDetectingInstance, {
        key: "line-h-" + i,
        title: current.title,
        scale: _this.scale,
        scrollX: _this.scrollX,
        scrollY: _this.scrollY,
        rect: host.computeComponentInstanceRect(inst, current.componentMeta.rootSelector)
      });
    }));
  };
  _createClass(BorderDetecting, [{
    key: "scale",
    get: function get() {
      return this.props.host.viewport.scale;
    }
  }, {
    key: "scrollX",
    get: function get() {
      return this.props.host.viewport.scrollX;
    }
  }, {
    key: "scrollY",
    get: function get() {
      return this.props.host.viewport.scrollY;
    }
  }, {
    key: "current",
    get: function get() {
      var host = this.props.host;
      var doc = host.currentDocument;
      if (!doc) {
        return null;
      }
      var selection = doc.selection;
      var current = host.designer.detecting.current;
      if (!current || current.document !== doc || selection.has(current.id)) {
        return null;
      }
      return current;
    }
  }]);
  return BorderDetecting;
}(Component), (_applyDecoratedDescriptor(_class2.prototype, "scale", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, "scale"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "scrollX", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, "scrollX"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "scrollY", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, "scrollY"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "current", [computed], Object.getOwnPropertyDescriptor(_class2.prototype, "current"), _class2.prototype)), _class2)) || _class;