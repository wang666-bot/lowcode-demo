import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
var _class;
import { Component } from 'react';
import { observer } from '@alilc/lowcode-editor-core';
import { isVertical } from '../../designer';
import './insertion.less';
import { isLocationChildrenDetail } from '@alilc/lowcode-utils';
/**
 * 处理拖拽子节点(INode)情况
 */
function processChildrenDetail(sim, container, detail) {
  var edge = detail.edge || null;
  if (!edge) {
    edge = sim.computeRect(container);
    if (!edge) {
      return {};
    }
  }
  var ret = {
    edge: edge,
    insertType: 'before'
  };
  if (detail.near) {
    var _detail$near = detail.near,
      node = _detail$near.node,
      pos = _detail$near.pos,
      rect = _detail$near.rect,
      align = _detail$near.align;
    ret.nearRect = rect || sim.computeRect(node);
    ret.nearNode = node;
    if (pos === 'replace') {
      // FIXME: ret.nearRect mybe null
      ret.coverRect = ret.nearRect;
      ret.insertType = 'cover';
    } else if (!ret.nearRect || ret.nearRect.width === 0 && ret.nearRect.height === 0) {
      ret.nearRect = ret.edge;
      ret.insertType = 'after';
      ret.vertical = isVertical(ret.nearRect);
    } else {
      ret.insertType = pos;
      ret.vertical = align ? align === 'V' : isVertical(ret.nearRect);
    }
    return ret;
  }

  // from outline-tree: has index, but no near
  // TODO: think of shadowNode & ConditionFlow
  var index = detail.index;
  if (index == null) {
    ret.coverRect = ret.edge;
    ret.insertType = 'cover';
    return ret;
  }
  var nearNode = container.children.get(index);
  if (!nearNode) {
    // index = 0, eg. nochild,
    nearNode = container.children.get(index > 0 ? index - 1 : 0);
    if (!nearNode) {
      ret.insertType = 'cover';
      ret.coverRect = edge;
      return ret;
    }
    ret.insertType = 'after';
  }
  if (nearNode) {
    ret.nearRect = sim.computeRect(nearNode);
    if (!ret.nearRect || ret.nearRect.width === 0 && ret.nearRect.height === 0) {
      ret.nearRect = ret.edge;
      ret.insertType = 'after';
    }
    ret.vertical = isVertical(ret.nearRect);
    ret.nearNode = nearNode;
  } else {
    ret.insertType = 'cover';
    ret.coverRect = edge;
  }
  return ret;
}

/**
 * 将 detail 信息转换为页面"坐标"信息
 */
function processDetail(_ref) {
  var target = _ref.target,
    detail = _ref.detail,
    document = _ref.document;
  var sim = document.simulator;
  if (!sim) {
    return {};
  }
  if (isLocationChildrenDetail(detail)) {
    return processChildrenDetail(sim, target, detail);
  } else {
    // TODO: others...
    var instances = sim.getComponentInstances(target);
    if (!instances) {
      return {};
    }
    var edge = sim.computeComponentInstanceRect(instances[0], target.componentMeta.rootSelector);
    return edge ? {
      edge: edge,
      insertType: 'cover',
      coverRect: edge
    } : {};
  }
}
export var InsertionView = observer(_class = /*#__PURE__*/function (_Component) {
  _inheritsLoose(InsertionView, _Component);
  function InsertionView() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = InsertionView.prototype;
  _proto.render = function render() {
    var _host$currentDocument, _loc$target, _loc$target$component, _loc$detail;
    var host = this.props.host;
    var loc = (_host$currentDocument = host.currentDocument) === null || _host$currentDocument === void 0 ? void 0 : _host$currentDocument.dropLocation;
    if (!loc) {
      return null;
    }
    // 如果是个绝对定位容器，不需要渲染插入标记
    if ((_loc$target = loc.target) !== null && _loc$target !== void 0 && (_loc$target$component = _loc$target.componentMeta) !== null && _loc$target$component !== void 0 && _loc$target$component.advanced.isAbsoluteLayoutContainer) {
      return null;
    }
    var _host$viewport = host.viewport,
      scale = _host$viewport.scale,
      scrollX = _host$viewport.scrollX,
      scrollY = _host$viewport.scrollY;
    var _processDetail = processDetail(loc),
      edge = _processDetail.edge,
      insertType = _processDetail.insertType,
      coverRect = _processDetail.coverRect,
      nearRect = _processDetail.nearRect,
      vertical = _processDetail.vertical,
      nearNode = _processDetail.nearNode;
    if (!edge) {
      return null;
    }
    var className = 'lc-insertion';
    if (((_loc$detail = loc.detail) === null || _loc$detail === void 0 ? void 0 : _loc$detail.valid) === false) {
      className += ' invalid';
    }
    var style = {};
    var x;
    var y;
    if (insertType === 'cover') {
      className += ' cover';
      x = (coverRect.left + scrollX) * scale;
      y = (coverRect.top + scrollY) * scale;
      style.width = coverRect.width * scale;
      style.height = coverRect.height * scale;
    } else {
      var _componentMeta;
      if (!nearRect) {
        return null;
      }
      if (vertical) {
        className += ' vertical';
        x = ((insertType === 'before' ? nearRect.left : nearRect.right) + scrollX) * scale;
        y = (nearRect.top + scrollY) * scale;
        style.height = nearRect.height * scale;
      } else {
        x = (nearRect.left + scrollX) * scale;
        y = ((insertType === 'before' ? nearRect.top : nearRect.bottom) + scrollY) * scale;
        style.width = nearRect.width * scale;
      }
      if (y === 0 && nearNode !== null && nearNode !== void 0 && (_componentMeta = nearNode.componentMeta) !== null && _componentMeta !== void 0 && _componentMeta.isTopFixed) {
        return null;
      }
    }
    style.transform = "translate3d(" + x + "px, " + y + "px, 0)";
    // style.transition = 'all 0.2s ease-in-out';

    return /*#__PURE__*/React.createElement("div", {
      className: className,
      style: style
    });
  };
  return InsertionView;
}(Component)) || _class;