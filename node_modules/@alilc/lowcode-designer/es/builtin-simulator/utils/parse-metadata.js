import _extends from "@babel/runtime/helpers/extends";
import PropTypes from 'prop-types';
import { isValidElement } from 'react';
import { isElement } from '@alilc/lowcode-utils';
export var primitiveTypes = ['string', 'number', 'array', 'bool', 'func', 'object', 'node', 'element', 'symbol', 'any'];
// eslint-disable-next-line @typescript-eslint/ban-types
function makeRequired(propType, lowcodeType) {
  function lowcodeCheckTypeIsRequired() {
    return propType.isRequired.apply(propType, arguments);
  }
  if (typeof lowcodeType === 'string') {
    lowcodeType = {
      type: lowcodeType
    };
  }
  lowcodeCheckTypeIsRequired.lowcodeType = _extends({}, lowcodeType, {
    isRequired: true
  });
  return lowcodeCheckTypeIsRequired;
}

// eslint-disable-next-line @typescript-eslint/ban-types
function define(propType, lowcodeType) {
  if (propType === void 0) {
    propType = PropTypes.any;
  }
  if (lowcodeType === void 0) {
    lowcodeType = {};
  }
  if (!propType._inner && propType.name !== 'lowcodeCheckType') {
    propType.lowcodeType = lowcodeType;
  }
  function lowcodeCheckType() {
    return propType.apply(void 0, arguments);
  }
  lowcodeCheckType.lowcodeType = lowcodeType;
  lowcodeCheckType.isRequired = makeRequired(propType, lowcodeType);
  return lowcodeCheckType;
}
export var LowcodeTypes = _extends({}, PropTypes, {
  define: define
});
window.PropTypes = LowcodeTypes;
if (window.React) {
  window.React.PropTypes = LowcodeTypes;
}

// override primitive type checkers
primitiveTypes.forEach(function (type) {
  var propType = PropTypes[type];
  if (!propType) {
    return;
  }
  propType._inner = true;
  LowcodeTypes[type] = define(propType, type);
});

// You can ensure that your prop is limited to specific values by treating
// it as an enum.
LowcodeTypes.oneOf = function (list) {
  return define(PropTypes.oneOf(list), {
    type: 'oneOf',
    value: list
  });
};

// An array of a certain type
LowcodeTypes.arrayOf = function (type) {
  return define(PropTypes.arrayOf(type), {
    type: 'arrayOf',
    value: type.lowcodeType || 'any'
  });
};

// An object with property values of a certain type
LowcodeTypes.objectOf = function (type) {
  return define(PropTypes.objectOf(type), {
    type: 'objectOf',
    value: type.lowcodeType || 'any'
  });
};

// An object that could be one of many types
LowcodeTypes.oneOfType = function (types) {
  var itemTypes = types.map(function (type) {
    return type.lowcodeType || 'any';
  });
  return define(PropTypes.oneOfType(types), {
    type: 'oneOfType',
    value: itemTypes
  });
};

// An object with warnings on extra properties
LowcodeTypes.exact = function (typesMap) {
  var configs = Object.keys(typesMap).map(function (key) {
    var _typesMap$key;
    return {
      name: key,
      propType: ((_typesMap$key = typesMap[key]) === null || _typesMap$key === void 0 ? void 0 : _typesMap$key.lowcodeType) || 'any'
    };
  });
  return define(PropTypes.exact(typesMap), {
    type: 'exact',
    value: configs
  });
};

// An object taking on a particular shape
LowcodeTypes.shape = function (typesMap) {
  if (typesMap === void 0) {
    typesMap = {};
  }
  var configs = Object.keys(typesMap).map(function (key) {
    var _typesMap$key2;
    return {
      name: key,
      propType: ((_typesMap$key2 = typesMap[key]) === null || _typesMap$key2 === void 0 ? void 0 : _typesMap$key2.lowcodeType) || 'any'
    };
  });
  return define(PropTypes.shape(typesMap), {
    type: 'shape',
    value: configs
  });
};
var BasicTypes = ['string', 'number', 'object'];
export function parseProps(component) {
  if (!component) {
    return [];
  }
  var propTypes = component.propTypes || {};
  var defaultProps = component.defaultProps || {};
  var result = {};
  if (!propTypes) return [];
  Object.keys(propTypes).forEach(function (key) {
    var propTypeItem = propTypes[key];
    var defaultValue = defaultProps[key];
    var lowcodeType = propTypeItem.lowcodeType;
    if (lowcodeType) {
      result[key] = {
        name: key,
        propType: lowcodeType
      };
      if (defaultValue != null) {
        result[key].defaultValue = defaultValue;
      }
      return;
    }
    var i = primitiveTypes.length;
    while (i-- > 0) {
      var k = primitiveTypes[i];
      if (LowcodeTypes[k] === propTypeItem) {
        result[key] = {
          name: key,
          propType: k
        };
        if (defaultValue != null) {
          result[key].defaultValue = defaultValue;
        }
        return;
      }
    }
    result[key] = {
      name: key,
      propType: 'any'
    };
    if (defaultValue != null) {
      result[key].defaultValue = defaultValue;
    }
  });
  Object.keys(defaultProps).forEach(function (key) {
    if (result[key]) return;
    var defaultValue = defaultProps[key];
    var type = typeof defaultValue;
    if (type === 'boolean') {
      type = 'bool';
    } else if (type === 'function') {
      type = 'func';
    } else if (type === 'object' && Array.isArray(defaultValue)) {
      type = 'array';
    } else if (defaultValue && /*#__PURE__*/isValidElement(defaultValue)) {
      type = 'node';
    } else if (defaultValue && isElement(defaultValue)) {
      type = 'element';
    } else if (!BasicTypes.includes(type)) {
      type = 'any';
    }
    result[key] = {
      name: key,
      propType: type || 'any',
      defaultValue: defaultValue
    };
  });
  return Object.keys(result).map(function (key) {
    return result[key];
  });
}
export function parseMetadata(component) {
  return _extends({
    props: parseProps(component)
  }, component.componentMetadata);
}