var useRAF = typeof requestAnimationFrame === 'function';

// eslint-disable-next-line @typescript-eslint/ban-types
export function throttle(func, delay) {
  var lastArgs;
  var lastThis;
  var result;
  var timerId;
  var lastCalled;
  var lastInvoked = 0;
  function invoke(time) {
    var args = lastArgs;
    var thisArg = lastThis;
    lastArgs = undefined;
    lastThis = undefined;
    lastInvoked = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function startTimer(pendingFunc, wait) {
    if (useRAF) {
      return requestAnimationFrame(pendingFunc);
    }
    return setTimeout(pendingFunc, wait);
  }
  function leadingEdge(time) {
    lastInvoked = time;
    timerId = startTimer(timerExpired, delay);
    return invoke(time);
  }
  function shouldInvoke(time) {
    var timeSinceLastCalled = time - lastCalled;
    var timeSinceLastInvoked = time - lastInvoked;
    return lastCalled === undefined || timeSinceLastCalled >= delay || timeSinceLastCalled < 0 || timeSinceLastInvoked >= delay;
  }
  function remainingWait(time) {
    var timeSinceLastCalled = time - lastCalled;
    var timeSinceLastInvoked = time - lastInvoked;
    return Math.min(delay - timeSinceLastCalled, delay - timeSinceLastInvoked);
  }
  function timerExpired() {
    var time = Date.now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = startTimer(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = undefined;
    if (lastArgs) {
      return invoke(time);
    }
    lastArgs = undefined;
    lastThis = undefined;
    return result;
  }
  function debounced() {
    var time = Date.now();
    var isInvoking = shouldInvoke(time);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    lastThis = this;
    lastCalled = time;
    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCalled);
      }
      timerId = startTimer(timerExpired, delay);
      return invoke(lastCalled);
    }
    if (timerId === undefined) {
      timerId = startTimer(timerExpired, delay);
    }
    return result;
  }
  return debounced;
}