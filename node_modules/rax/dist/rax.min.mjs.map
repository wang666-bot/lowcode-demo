{"version":3,"file":"rax.min.mjs","sources":["../src/vdom/host.js","../src/vdom/element.js","../src/types.js","../src/vdom/flattenChildren.js","../src/vdom/scheduler.js","../src/error.js","../src/createElement.js","../src/invokeFunctionsWithContext.js","../src/vdom/shallowEqual.js","../src/constant.js","../src/hooks.js","../src/toArray.js","../src/vdom/getNearestParent.js","../src/createContext.js","../src/createRef.js","../src/forwardRef.js","../src/memo.js","../src/fragment.js","../src/vdom/instantiateComponent.js","../src/vdom/component.js","../src/vdom/root.js","../src/vdom/instance.js","../src/vdom/ref.js","../src/vdom/shouldUpdateComponent.js","../src/vdom/getElementKeyName.js","../src/vdom/getPrevSiblingNativeNode.js","../src/vdom/base.js","../src/assign.js","../src/vdom/native.js","../src/vdom/reactive.js","../src/vdom/updater.js","../src/vdom/performInSandbox.js","../src/vdom/composite.js","../src/vdom/text.js","../src/vdom/fragment.js","../src/vdom/empty.js","../src/render.js","../src/vdom/injectRenderOptions.js","../src/vdom/inject.js","../src/version.js","../src/index.js"],"sourcesContent":["/*\n * Stateful things in runtime\n */\nexport default {\n  __mountID: 1,\n  __isUpdating: false,\n  // Inject\n  driver: null,\n  // Roots\n  rootComponents: {},\n  rootInstances: {},\n  // Current owner component\n  owner: null,\n};\n","import checkPropTypes from 'prop-types/checkPropTypes';\n\nexport default function Element(type, key, ref, props, owner) {\n  let element = {\n    // Built-in properties that belong on the element\n    type,\n    key,\n    ref,\n    props,\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    const propTypes = type.propTypes;\n\n    // Validate its props provided by the propTypes definition\n    if (propTypes) {\n      const displayName = type.displayName || type.name;\n      checkPropTypes(\n        propTypes,\n        props,\n        'prop',\n        displayName,\n      );\n    }\n\n    // We make validation flag non-enumerable, so the test framework could ignore it\n    Object.defineProperty(element, '__validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n\n    // Props is immutable\n    if (Object.freeze) {\n      Object.freeze(props);\n    }\n  }\n\n  return element;\n};\n","export function isNull(obj) {\n  return obj === null;\n}\n\nexport function isFunction(obj) {\n  return typeof obj === 'function';\n}\n\nexport function isObject(obj) {\n  return typeof obj === 'object';\n}\n\nexport function isPlainObject(obj) {\n  return EMPTY_OBJECT.toString.call(obj) === '[object Object]';\n}\n\nexport function isArray(array) {\n  return Array.isArray(array);\n}\n\nexport function isString(string) {\n  return typeof string === 'string';\n}\n\nexport function isNumber(string) {\n  return typeof string === 'number';\n}\n\nexport function isFalsy(val) {\n  return !Boolean(val);\n}\n\nexport const NOOP = () => {};\nexport const EMPTY_OBJECT = {};\n","import { isArray } from '../types';\n\nfunction traverseChildren(children, result) {\n  if (isArray(children)) {\n    for (let i = 0, l = children.length; i < l; i++) {\n      traverseChildren(children[i], result);\n    }\n  } else {\n    result.push(children);\n  }\n}\n\nexport default function flattenChildren(children) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  traverseChildren(children, result);\n\n  // If length equal 1, return the only one.\n  return result.length - 1 ? result : result[0];\n}\n","let updateCallbacks = [];\nlet effectCallbacks = [];\nlet layoutCallbacks = [];\nexport let scheduler = setTimeout;\n\nif (process.env.NODE_ENV !== 'production') {\n  // Wrapper timer for hijack timers in jest\n  scheduler = (callback) => {\n    setTimeout(callback);\n  };\n}\n\nfunction invokeFunctionsWithClear(callbacks) {\n  let callback;\n  while (callback = callbacks.shift()) {\n    callback();\n  }\n}\n\n// Schedule before next render\nexport function schedule(callback) {\n  if (updateCallbacks.length === 0) {\n    scheduler(flush);\n  }\n  updateCallbacks.push(callback);\n}\n\n// Flush before next render\nexport function flush() {\n  invokeFunctionsWithClear(updateCallbacks);\n}\n\nexport function scheduleEffect(callback) {\n  if (effectCallbacks.length === 0) {\n    scheduler(flushEffect);\n  }\n  effectCallbacks.push(callback);\n}\n\nexport function flushEffect() {\n  invokeFunctionsWithClear(effectCallbacks);\n}\n\nexport function scheduleLayout(callback) {\n  layoutCallbacks.push(callback);\n}\n\nexport function flushLayout() {\n  invokeFunctionsWithClear(layoutCallbacks);\n}\n","import Host from './vdom/host';\nimport { scheduler } from './vdom/scheduler';\nimport { NOOP, isPlainObject } from './types';\n\nfunction createMinifiedError(type, code, obj) {\n  var typeInfo = obj === undefined ? '' : ' got: ' + getTypeInfo(obj);\n  return new Error(`${type}: #${code}, ${getRenderErrorInfo()}.` + typeInfo);\n}\n\nexport function getTypeInfo(obj) {\n  return isPlainObject(obj) ? Object.keys(obj) : obj;\n}\n\nexport function getRenderErrorInfo() {\n  const ownerComponent = Host.owner;\n  return ownerComponent ? `check <${ownerComponent.__getName()}>` : 'no owner';\n}\n\n/**\n * Minified code:\n *  1: Hooks called outside a component, or multiple version of Rax are used.\n *  6: Invalid component type, expected a class or function component.\n *  4: Too many re-renders, the number of renders is limited to prevent an infinite loop.\n *  5: Rax driver not found.\n * @param code {Number}\n * @param obj {Object}\n */\nexport function throwMinifiedError(code, obj) {\n  throw createMinifiedError('Error', code, obj);\n}\n\n/**\n * Minified Code:\n * 0: Invalid element type, expected a string or a class/function component but got \"null\" or \"undefined\".\n * 2. Invalid child type, expected types: Element instance, string, boolean, array, null, undefined.\n * 3. Ref can not attach because multiple copies of Rax are used.\n * @param {number} code\n * @param {string} info\n */\nexport function throwMinifiedWarn(code, obj) {\n  let err = createMinifiedError('Warn', code, obj);\n  scheduler(() => {\n    throw err;\n  }, 0);\n}\n\nexport function throwError(message, obj) {\n  let typeInfo = obj === undefined ? '' :\n    '(found: ' + (isPlainObject(obj) ? `object with keys {${Object.keys(obj)}}` : obj) + ')';\n\n  throw Error(`${message} ${typeInfo}`);\n}\n\nexport let warning = NOOP;\n\nif (process.env.NODE_ENV !== 'production') {\n  warning = (template, ...args) => {\n    if (typeof console !== 'undefined') {\n      let argsWithFormat = args.map(item => '' + item);\n      argsWithFormat.unshift('Warning: ' + template);\n      // Don't use spread (or .apply) directly because it breaks IE9\n      Function.prototype.apply.call(console.error, console, argsWithFormat);\n    }\n\n    // For works in DevTools when enable `Pause on caught exceptions`\n    // that can find the component where caused this warning\n    try {\n      let argIndex = 0;\n      const message = 'Warning: ' + template.replace(/%s/g, () => args[argIndex++]);\n      throw new Error(message);\n    } catch (e) {}\n  };\n}\n\n","import Host from './vdom/host';\nimport Element from './vdom/element';\nimport flattenChildren from './vdom/flattenChildren';\nimport { warning, throwError, throwMinifiedWarn } from './error';\nimport { isString, isArray, NOOP } from './types';\nimport validateChildKeys from './validateChildKeys';\n\nconst RESERVED_PROPS = {\n  key: true,\n  ref: true,\n};\n\nexport default function createElement(type, config, children) {\n  // Reserved names are extracted\n  let props = {};\n  let propName;\n  let key = null;\n  let ref = null;\n\n  if (config != null) {\n    ref = config.ref === undefined ? null : config.ref;\n    key = config.key === undefined ? null : '' + config.key;\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (!RESERVED_PROPS[propName]) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children arguments can be more than one\n  const childrenLength = arguments.length - 2;\n  if (childrenLength > 0) {\n    if (childrenLength === 1 && !isArray(children)) {\n      props.children = children;\n    } else {\n      let childArray = children;\n      if (childrenLength > 1) {\n        childArray = new Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n      }\n      props.children = flattenChildren(childArray);\n    }\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    let defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  if (type == null) {\n    if (process.env.NODE_ENV !== 'production') {\n      throwError(`Invalid element type, expected a string or a class/function component but got \"${type}\".`);\n    } else {\n      // A empty component replaced avoid break render in production\n      type = NOOP;\n      throwMinifiedWarn(0);\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (isString(ref) && !Host.owner) {\n      warning(\n        `Adding a string ref \"${ref}\" that was not created inside render method, or multiple copies of Rax are used.`\n      );\n    }\n\n    for (let i = 2; i < arguments.length; i ++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  return new Element(\n    type,\n    key,\n    ref,\n    props,\n    Host.owner\n  );\n}\n\n","export default function invokeFunctionsWithContext(fns, context, value) {\n  for (let i = 0, l = fns && fns.length; i < l; i++) {\n    fns[i].call(context, value);\n  }\n}\n","import { isNull, isObject, EMPTY_OBJECT } from '../types';\n\nconst hasOwnProperty = EMPTY_OBJECT.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nexport function is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y; // eslint-disable-line no-self-compare\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nexport default function shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (!isObject(objA) || isNull(objA) || !isObject(objB) || isNull(objB)) {\n    return false;\n  }\n\n  let keysA = Object.keys(objA);\n  let keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/* Common constant variables for rax */\n\nexport const INTERNAL = '_internal';\nexport const INSTANCE = '_instance';\nexport const NATIVE_NODE = '_nativeNode';\nexport const RENDERED_COMPONENT = '_renderedComponent';\n","import Host from './vdom/host';\nimport { scheduleEffect, flushEffect } from './vdom/scheduler';\nimport { is } from './vdom/shallowEqual';\nimport { isArray, isFunction, isNull } from './types';\nimport { warning, throwError, throwMinifiedError } from './error';\nimport { INSTANCE } from './constant';\n\nfunction getCurrentInstance() {\n  return Host.owner && Host.owner[INSTANCE];\n}\n\nfunction getCurrentRenderingInstance() {\n  const currentInstance = getCurrentInstance();\n  if (currentInstance) {\n    return currentInstance;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      throwError('Hooks called outside a component, or multiple version of Rax are used.');\n    } else {\n      throwMinifiedError(1);\n    }\n  }\n}\n\nfunction areInputsEqual(inputs, prevInputs) {\n  if (isNull(prevInputs) || inputs.length !== prevInputs.length) {\n    return false;\n  }\n\n  for (let i = 0; i < inputs.length; i++) {\n    if (is(inputs[i], prevInputs[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function useState(initialState) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n\n  if (!hooks[hookID]) {\n    // If the initial state is the result of an expensive computation,\n    // you may provide a function instead for lazy initial state.\n    if (isFunction(initialState)) {\n      initialState = initialState();\n    }\n\n    const setState = newState => {\n      // Flush all effects first before update state\n      if (!Host.__isUpdating) {\n        flushEffect();\n      }\n\n      const hook = hooks[hookID];\n      const eagerState = hook[2];\n      // function updater\n      if (isFunction(newState)) {\n        newState = newState(eagerState);\n      }\n\n      if (!is(newState, eagerState)) {\n        // Current instance is in render update phase.\n        // After this one render finish, will continue run.\n        hook[2] = newState;\n        if (getCurrentInstance() === currentInstance) {\n          // Marked as is scheduled that could finish hooks.\n          currentInstance.__isScheduled = true;\n        } else {\n          currentInstance.__update();\n        }\n      }\n    };\n\n    hooks[hookID] = [\n      initialState,\n      setState,\n      initialState\n    ];\n  }\n\n  const hook = hooks[hookID];\n  if (!is(hook[0], hook[2])) {\n    hook[0] = hook[2];\n    currentInstance.__shouldUpdate = true;\n  }\n\n  return hook;\n}\n\nexport function useContext(context) {\n  const currentInstance = getCurrentRenderingInstance();\n  return currentInstance.useContext(context);\n}\n\nexport function useEffect(effect, inputs) {\n  useEffectImpl(effect, inputs, true);\n}\n\nexport function useLayoutEffect(effect, inputs) {\n  useEffectImpl(effect, inputs);\n}\n\nfunction useEffectImpl(effect, inputs, defered) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n  inputs = inputs === undefined ? null : inputs;\n\n  if (!hooks[hookID]) {\n    const __create = (immediately) => {\n      if (!immediately && defered) return scheduleEffect(() => __create(true));\n      const { current } = __create;\n      if (current) {\n        __destory.current = current();\n        __create.current = null;\n\n        if (process.env.NODE_ENV !== 'production') {\n          const currentDestory = __destory.current;\n          if (currentDestory !== undefined && typeof currentDestory !== 'function') {\n            let msg;\n            if (currentDestory === null) {\n              msg =\n                ' You returned null. If your effect does not require clean ' +\n                'up, return undefined (or nothing).';\n            } else if (typeof currentDestory.then === 'function') {\n              msg =\n                '\\n\\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' +\n                'Instead, write the async function inside your effect ' +\n                'and call it immediately:\\n\\n' +\n                'useEffect(() => {\\n' +\n                '  async function fetchData() {\\n' +\n                '    // You can await here\\n' +\n                '    const response = await MyAPI.getData(someId);\\n' +\n                '    // ...\\n' +\n                '  }\\n' +\n                '  fetchData();\\n' +\n                '}, [someId]); // Or [] if effect doesn\\'t need props or state.';\n            } else {\n              msg = ' You returned: ' + currentDestory;\n            }\n\n            warning(\n              'An effect function must not return anything besides a function, ' +\n              'which is used for clean-up.' + msg,\n            );\n          }\n        }\n      }\n    };\n\n    const __destory = (immediately) => {\n      if (!immediately && defered) return scheduleEffect(() => __destory(true));\n      const { current } = __destory;\n      if (current) {\n        current();\n        __destory.current = null;\n      }\n    };\n\n    __create.current = effect;\n\n    hooks[hookID] = {\n      __create,\n      __destory,\n      __prevInputs: inputs,\n      __inputs: inputs\n    };\n\n    currentInstance.didMount.push(__create);\n    currentInstance.willUnmount.push(() => __destory(true));\n    currentInstance.didUpdate.push(() => {\n      const { __prevInputs, __inputs, __create } = hooks[hookID];\n      if (__inputs == null || !areInputsEqual(__inputs, __prevInputs)) {\n        __destory();\n        __create();\n      }\n    });\n  } else {\n    const hook = hooks[hookID];\n    const { __create, __inputs: prevInputs } = hook;\n    hook.__inputs = inputs;\n    hook.__prevInputs = prevInputs;\n    __create.current = effect;\n  }\n}\n\nexport function useImperativeHandle(ref, create, inputs) {\n  const nextInputs = isArray(inputs) ? inputs.concat([ref]) : null;\n\n  useLayoutEffect(() => {\n    if (isFunction(ref)) {\n      ref(create());\n      return () => ref(null);\n    } else if (ref != null) {\n      ref.current = create();\n      return () => {\n        ref.current = null;\n      };\n    }\n  }, nextInputs);\n}\n\nexport function useRef(initialValue) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n\n  if (!hooks[hookID]) {\n    hooks[hookID] = {\n      current: initialValue\n    };\n  }\n\n  return hooks[hookID];\n}\n\nexport function useCallback(callback, inputs) {\n  return useMemo(() => callback, inputs);\n}\n\nexport function useMemo(create, inputs) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n  inputs = inputs === undefined ? null : inputs;\n\n  if (!hooks[hookID]) {\n    hooks[hookID] = [create(), inputs];\n  } else {\n    const prevInputs = hooks[hookID][1];\n    if (isNull(inputs) || !areInputsEqual(inputs, prevInputs)) {\n      hooks[hookID] = [create(), inputs];\n    }\n  }\n\n  return hooks[hookID][0];\n}\n\nexport function useReducer(reducer, initialArg, init) {\n  const currentInstance = getCurrentRenderingInstance();\n  const hookID = currentInstance.getHookID();\n  const hooks = currentInstance.getHooks();\n  const hook = hooks[hookID];\n\n  if (!hook) {\n    const initialState = isFunction(init) ? init(initialArg) : initialArg;\n\n    const dispatch = action => {\n      // Flush all effects first before update state\n      if (!Host.__isUpdating) {\n        flushEffect();\n      }\n\n      const hook = hooks[hookID];\n      // Reducer will update in the next render, before that we add all\n      // actions to the queue\n      const queue = hook[2];\n\n      if (getCurrentInstance() === currentInstance) {\n        queue.__actions.push(action);\n        currentInstance.__isScheduled = true;\n      } else {\n        const currentState = queue.__eagerState;\n        const eagerReducer = queue.__eagerReducer;\n        const eagerState = eagerReducer(currentState, action);\n        if (is(eagerState, currentState)) {\n          return;\n        }\n        queue.__eagerState = eagerState;\n        queue.__actions.push(action);\n        currentInstance.__update();\n      }\n    };\n\n    return hooks[hookID] = [\n      initialState,\n      dispatch,\n      {\n        __actions: [],\n        __eagerReducer: reducer,\n        __eagerState: initialState\n      }\n    ];\n  }\n\n  const queue = hook[2];\n  let next = hook[0];\n\n  if (currentInstance.__reRenders > 0) {\n    for (let i = 0; i < queue.__actions.length; i++) {\n      next = reducer(next, queue.__actions[i]);\n    }\n  } else {\n    next = queue.__eagerState;\n  }\n\n  if (!is(next, hook[0])) {\n    hook[0] = next;\n    currentInstance.__shouldUpdate = true;\n  }\n\n  queue.__eagerReducer = reducer;\n  queue.__eagerState = next;\n  queue.__actions.length = 0;\n\n  return hooks[hookID];\n}\n","import { isArray } from './types';\n\nexport default function toArray(obj) {\n  return isArray(obj) ? obj : [obj];\n}\n","import { INTERNAL } from '../constant';\n\nexport default function getNearestParent(instance, matcher) {\n  let parent;\n  while (instance && instance[INTERNAL]) {\n    if (matcher(instance)) {\n      parent = instance;\n      break;\n    }\n    instance = instance[INTERNAL].__parentInstance;\n  }\n  return parent;\n}","import invokeFunctionsWithContext from './invokeFunctionsWithContext';\nimport { useState, useLayoutEffect } from './hooks';\nimport { isFunction } from './types';\nimport toArray from './toArray';\nimport getNearestParent from './vdom/getNearestParent';\n\nlet id = 0;\n\nexport default function createContext(defaultValue) {\n  const contextID = '_c' + id++;\n\n  // Provider Component\n  class Provider {\n    constructor() {\n      this.__contextID = contextID;\n      this.__handlers = [];\n    }\n    __on(handler) {\n      this.__handlers.push(handler);\n    }\n    __off(handler) {\n      this.__handlers = this.__handlers.filter(h => h !== handler);\n    }\n    // Like getChildContext but called in SSR\n    _getChildContext() {\n      return {\n        [contextID]: this\n      };\n    }\n    // `getValue()` called in rax-server-renderer\n    getValue() {\n      return this.props.value !== undefined ? this.props.value : defaultValue;\n    }\n    componentDidUpdate(prevProps) {\n      if (this.props.value !== prevProps.value) {\n        invokeFunctionsWithContext(this.__handlers, null, this.getValue());\n      }\n    }\n    render() {\n      return this.props.children;\n    }\n  }\n\n  function getNearestParentProvider(instance) {\n    return getNearestParent(instance, parent => parent.__contextID === contextID);\n  }\n\n  // Consumer Component\n  function Consumer(props, context) {\n    // Current `context[contextID]` only works in SSR\n    const [provider] = useState(() => context[contextID] || getNearestParentProvider(this));\n    let value = provider ? provider.getValue() : defaultValue;\n    const [prevValue, setValue] = useState(value);\n\n    if (value !== prevValue) {\n      setValue(value);\n      return; // Interrupt execution of consumer.\n    }\n\n    useLayoutEffect(() => {\n      if (provider) {\n        provider.__on(setValue);\n        return () => {\n          provider.__off(setValue);\n        };\n      }\n    }, []);\n\n    // Consumer requires a function as a child.\n    // The function receives the current context value.\n    const consumer = toArray(props.children)[0];\n    if (isFunction(consumer)) {\n      return consumer(value);\n    }\n  }\n\n  return {\n    Provider,\n    Consumer,\n    // `_contextID` and `_defaultValue` accessed in rax-server-renderer\n    _contextID: contextID,\n    _defaultValue: defaultValue,\n    __getNearestParentProvider: getNearestParentProvider,\n  };\n}\n","export default function createRef() {\n  return {\n    current: null\n  };\n}","export default function(render) {\n  // _forwardRef is also use in rax server renderer\n  render._forwardRef = true;\n  return render;\n}","import shallowEqual from './vdom/shallowEqual';\n\nexport default function memo(type, compare) {\n  compare = compare || shallowEqual;\n\n  // Memo could composed\n  if (type.__compares) {\n    type.__compares.push(compare);\n  } else {\n    type.__compares = [compare];\n  }\n\n  return type;\n}\n","export default function Fragment(props) {\n  return props.children;\n}","import Host from './host';\nimport {isString, isNumber, isArray, isNull, isPlainObject} from '../types';\nimport { throwMinifiedWarn, throwError } from '../error';\n\nexport default function instantiateComponent(element) {\n  let instance;\n\n  if (isPlainObject(element) && element !== null && element.type) {\n    // Special case string values\n    if (isString(element.type)) {\n      instance = new Host.__Native(element);\n    } else {\n      instance = new Host.__Composite(element);\n    }\n  } else if (isString(element) || isNumber(element)) {\n    instance = new Host.__Text(String(element));\n  } else if (isArray(element)) {\n    instance = new Host.__Fragment(element);\n  } else {\n    if (!(element === undefined || isNull(element) || element === false || element === true)) {\n      if (process.env.NODE_ENV !== 'production') {\n        throwError('Invalid child type, expected types: Element instance, string, boolean, array, null, undefined.', element);\n      } else {\n        throwMinifiedWarn(2, element);\n      }\n    }\n\n    instance = new Host.__Empty(element);\n  }\n\n  return instance;\n}\n","/**\n * Base component class.\n */\nexport default class Component {\n  constructor(props, context) {\n    this.props = props;\n    this.context = context;\n    this.refs = {};\n  }\n\n  setState(partialState, callback) {\n    // The updater property is injected when composite component mounting\n    this.updater.setState(this, partialState, callback);\n  }\n\n  forceUpdate(callback) {\n    this.updater.forceUpdate(this, callback);\n  }\n}\n\n/**\n * Pure component.\n */\nexport class PureComponent extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.__isPureComponent = true;\n  }\n}\n","import Component from './component';\nimport {INTERNAL, RENDERED_COMPONENT} from '../constant';\n\nlet rootID = 1;\n\nclass Root extends Component {\n  constructor() {\n    super();\n    // Using fragment instead of null for avoid create a comment node when init mount\n    this.__element = [];\n    this.__rootID = rootID++;\n  }\n\n  __getPublicInstance() {\n    return this.__getRenderedComponent().__getPublicInstance();\n  }\n\n  __getRenderedComponent() {\n    return this[INTERNAL][RENDERED_COMPONENT];\n  }\n\n  __update(element) {\n    this.__element = element;\n    this.forceUpdate();\n  }\n\n  render() {\n    return this.__element;\n  }\n}\n\nexport default Root;\n","import Host from './host';\nimport createElement from '../createElement';\nimport instantiateComponent from './instantiateComponent';\nimport Root from './root';\nimport {INTERNAL, RENDERED_COMPONENT} from '../constant';\n\n/**\n * Instance manager\n * @NOTE Key should not be compressed, for that will be added to native node and cause DOM Exception.\n */\nconst KEY = '_r';\n\nexport default {\n  set(node, instance) {\n    if (!node[KEY]) {\n      node[KEY] = instance;\n      // Record root instance to roots map\n      if (instance.__rootID) {\n        Host.rootInstances[instance.__rootID] = instance;\n        Host.rootComponents[instance.__rootID] = instance[INTERNAL];\n      }\n    }\n  },\n  get(node) {\n    return node[KEY];\n  },\n  remove(node) {\n    let instance = this.get(node);\n    if (instance) {\n      node[KEY] = null;\n      if (instance.__rootID) {\n        delete Host.rootComponents[instance.__rootID];\n        delete Host.rootInstances[instance.__rootID];\n      }\n    }\n  },\n  mount(element, container, { parent, hydrate }) {\n    if (process.env.NODE_ENV !== 'production') {\n      Host.measurer && Host.measurer.beforeRender();\n    }\n\n    const driver = Host.driver;\n\n    // Real native root node is body\n    if (container == null) {\n      container = driver.createBody();\n    }\n\n    const renderOptions = {\n      element,\n      container,\n      hydrate\n    };\n\n    // Before render callback\n    driver.beforeRender && driver.beforeRender(renderOptions);\n\n    // Get the context from the conceptual parent component.\n    let parentContext;\n    if (parent) {\n      let parentInternal = parent[INTERNAL];\n      parentContext = parentInternal.__processChildContext(parentInternal._context);\n    }\n\n    // Update root component\n    let prevRootInstance = this.get(container);\n    if (prevRootInstance && prevRootInstance.__rootID) {\n      if (parentContext) {\n        // Using __penddingContext to pass new context\n        prevRootInstance[INTERNAL].__penddingContext = parentContext;\n      }\n      prevRootInstance.__update(element);\n\n      // After render callback\n      driver.afterRender && driver.afterRender(renderOptions);\n\n      return prevRootInstance;\n    }\n\n    // Init root component with empty children\n    let renderedComponent = instantiateComponent(createElement(Root));\n    let defaultContext = parentContext || {};\n    let rootInstance = renderedComponent.__mountComponent(container, parent, defaultContext);\n    this.set(container, rootInstance);\n\n    // Mount new element through update queue avoid when there is in rendering phase\n    rootInstance.__update(element);\n\n    // After render callback\n    driver.afterRender && driver.afterRender(renderOptions);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Devtool render new root hook\n      Host.reconciler.renderNewRootComponent(rootInstance[INTERNAL][RENDERED_COMPONENT]);\n      Host.measurer && Host.measurer.afterRender();\n    }\n\n    return rootInstance;\n  }\n};\n","/*\n * Ref manager\n */\nimport { isFunction, isObject } from '../types';\nimport { INSTANCE } from '../constant';\nimport { warning, throwMinifiedWarn } from '../error';\n\nexport function updateRef(prevElement, nextElement, component) {\n  let prevRef = prevElement ? prevElement.ref : null;\n  let nextRef = nextElement ? nextElement.ref : null;\n\n  // Update refs in owner component\n  if (prevRef !== nextRef) {\n    // Detach prev RenderedElement's ref\n    prevRef && detachRef(prevElement._owner, prevRef, component);\n    // Attach next RenderedElement's ref\n    nextRef && attachRef(nextElement._owner, nextRef, component);\n  }\n}\n\nexport function attachRef(ownerComponent, ref, component) {\n  if (!ownerComponent) {\n    if (process.env.NODE_ENV !== 'production') {\n      warning('Ref can not attach because multiple copies of Rax are used.');\n    } else {\n      throwMinifiedWarn(3);\n    }\n    return;\n  }\n\n  let instance = component.__getPublicInstance();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (instance == null) {\n      warning('Do not attach ref to function component because they donâ€™t have instances.');\n    }\n  }\n\n  if (isFunction(ref)) {\n    ref(instance);\n  } else if (isObject(ref)) {\n    ref.current = instance;\n  } else {\n    ownerComponent[INSTANCE].refs[ref] = instance;\n  }\n}\n\nexport function detachRef(ownerComponent, ref, component) {\n  if (isFunction(ref)) {\n    // When the referenced component is unmounted and whenever the ref changes, the old ref will be called with null as an argument.\n    ref(null);\n  } else {\n    // Must match component and ref could detach the ref on owner when A's before ref is B's current ref\n    let instance = component.__getPublicInstance();\n\n    if (isObject(ref) && ref.current === instance) {\n      ref.current = null;\n    } else if (ownerComponent[INSTANCE].refs[ref] === instance) {\n      delete ownerComponent[INSTANCE].refs[ref];\n    }\n  }\n}\n","import {isArray, isString, isNumber, isObject, isFalsy} from '../types';\n\nfunction shouldUpdateComponent(prevElement, nextElement) {\n  let prevFalsy = isFalsy(prevElement);\n  let nextFalsy = isFalsy(nextElement);\n  if (prevFalsy || nextFalsy) {\n    return prevFalsy === nextFalsy;\n  }\n\n  if (isArray(prevElement) && isArray(nextElement)) {\n    return true;\n  }\n\n  const isPrevStringOrNumber = isString(prevElement) || isNumber(prevElement);\n  if (isPrevStringOrNumber) {\n    return isString(nextElement) || isNumber(nextElement);\n  } else {\n    // prevElement and nextElement could be array, typeof [] is \"object\"\n    return (\n      isObject(prevElement) &&\n      isObject(nextElement) &&\n      prevElement.type === nextElement.type &&\n      prevElement.key === nextElement.key\n    );\n  }\n}\n\nexport default shouldUpdateComponent;\n","import { isString } from '../types';\nimport { warning } from '../error';\n\nexport default function getElementKeyName(children, element, index) {\n  // `element && element.key` will cause elementKey receive \"\" when element is \"\"\n  const elementKey = element ? element.key : void 0;\n  const defaultName = '.' + index.toString(36); // Inner child name default format fallback\n\n  // Key should must be string type\n  if (isString(elementKey)) {\n    let keyName = '$' + elementKey;\n    // Child keys must be unique.\n    let keyUnique = children[keyName] === undefined;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!keyUnique) {\n        // Only the first child will be used when encountered two children with the same key\n        warning(`Encountered two children with the same key \"${elementKey}\".`);\n      }\n    }\n\n    return keyUnique ? keyName : defaultName;\n  } else {\n    return defaultName;\n  }\n}\n","import Host from './host';\nimport { isArray } from '../types';\nimport { INTERNAL } from '../constant';\n\n/**\n * This function is usually been used to find the closet previous sibling native node of FragmentComponent.\n * FragmentComponent does not have a native node in the DOM tree, so when it is replaced, the new node has no corresponding location to insert.\n * So we need to look forward from the current mount position of the FragmentComponent to the nearest component which have the native node.\n * @param component\n * @return nativeNode\n */\nexport default function getPrevSiblingNativeNode(component) {\n  let parent = component;\n  while (parent = component.__parentInstance &&\n    component.__parentInstance[INTERNAL]) {\n    if (parent instanceof Host.__Composite) {\n      component = parent;\n      continue;\n    }\n\n    const keys = Object.keys(parent.__renderedChildren);\n    // Find previous sibling native node from current mount index\n    for (let i = component.__mountIndex - 1; i >= 0; i--) {\n      const nativeNode = parent.__renderedChildren[keys[i]].__getNativeNode();\n      // Fragment component always return array\n      if (isArray(nativeNode)) {\n        if (nativeNode.length > 0) {\n          // Get the last one\n          return nativeNode[nativeNode.length - 1];\n        }\n      } else {\n        // Others maybe native node or empty node\n        return nativeNode;\n      }\n    }\n\n    // Find parent over parent\n    if (parent instanceof Host.__Fragment) {\n      component = parent;\n    } else {\n      return null;\n    }\n  }\n}\n","import Host from './host';\nimport { INSTANCE, INTERNAL, NATIVE_NODE } from '../constant';\n\n/**\n * Base Component\n */\nexport default class BaseComponent {\n  constructor(element) {\n    this.__currentElement = element;\n  }\n\n  __initComponent(parent, parentInstance, context) {\n    this._parent = parent;\n    this.__parentInstance = parentInstance;\n    this._context = context;\n    this._mountID = Host.__mountID++;\n  }\n\n  __destoryComponent() {\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.unmountComponent(this);\n    }\n\n    this.__currentElement\n      = this[NATIVE_NODE]\n      = this._parent\n      = this.__parentInstance\n      = this._context\n      = null;\n\n    if (this[INSTANCE]) {\n      this[INSTANCE] = this[INSTANCE][INTERNAL] = null;\n    }\n  }\n\n  __mountComponent(parent, parentInstance, context, nativeNodeMounter) {\n    this.__initComponent(parent, parentInstance, context);\n    this.__mountNativeNode(nativeNodeMounter);\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.mountComponent(this);\n    }\n\n    const instance = {};\n    instance[INTERNAL] = this;\n\n    return instance;\n  }\n\n  unmountComponent(shouldNotRemoveChild) {\n    if (this[NATIVE_NODE] && !shouldNotRemoveChild) {\n      Host.driver.removeChild(this[NATIVE_NODE], this._parent);\n    }\n\n    this.__destoryComponent();\n  }\n\n  __getName() {\n    let currentElement = this.__currentElement;\n    let type = currentElement && currentElement.type;\n\n    return (\n      type && type.displayName ||\n      type && type.name ||\n      type || // Native component's name is type\n      currentElement\n    );\n  }\n\n  __mountNativeNode(nativeNodeMounter) {\n    let nativeNode = this.__getNativeNode();\n    let parent = this._parent;\n\n    if (nativeNodeMounter) {\n      nativeNodeMounter(nativeNode, parent);\n    } else {\n      Host.driver.appendChild(nativeNode, parent);\n    }\n  }\n\n  __getNativeNode() {\n    return this[NATIVE_NODE] == null\n      ? this[NATIVE_NODE] = this.__createNativeNode()\n      : this[NATIVE_NODE];\n  }\n\n  __getPublicInstance() {\n    return this.__getNativeNode();\n  }\n}\n","export default Object.assign;\n","import Host from './host';\nimport { detachRef, attachRef, updateRef } from './ref';\nimport instantiateComponent from './instantiateComponent';\nimport shouldUpdateComponent from './shouldUpdateComponent';\nimport getElementKeyName from './getElementKeyName';\nimport getPrevSiblingNativeNode from './getPrevSiblingNativeNode';\nimport Instance from './instance';\nimport BaseComponent from './base';\nimport toArray from '../toArray';\nimport { isFunction, isArray, isNull } from '../types';\nimport assign from '../assign';\nimport { INSTANCE, INTERNAL, NATIVE_NODE } from '../constant';\n\nconst STYLE = 'style';\nconst CHILDREN = 'children';\nconst TREE = 'tree';\nconst EVENT_PREFIX_REGEXP = /^on[A-Z]/;\n\n/**\n * Native Component\n */\nexport default class NativeComponent extends BaseComponent {\n  __mountComponent(parent, parentInstance, context, nativeNodeMounter) {\n    this.__initComponent(parent, parentInstance, context);\n\n    const currentElement = this.__currentElement;\n    const props = currentElement.props;\n    const type = currentElement.type;\n    const children = props[CHILDREN];\n    const appendType = props.append || TREE; // Default is tree\n\n    // Clone a copy for style diff\n    this.__prevStyleCopy = assign({}, props[STYLE]);\n\n    let instance = {\n      type,\n      props,\n    };\n    instance[INTERNAL] = this;\n\n    this[INSTANCE] = instance;\n\n    if (appendType === TREE) {\n      // Should after process children when mount by tree mode\n      this.__mountChildren(children, context);\n      this.__mountNativeNode(nativeNodeMounter);\n    } else {\n      // Should before process children when mount by node mode\n      this.__mountNativeNode(nativeNodeMounter);\n      this.__mountChildren(children, context);\n    }\n\n    // Ref acttach\n    if (currentElement && currentElement.ref) {\n      attachRef(currentElement._owner, currentElement.ref, this);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.mountComponent(this);\n    }\n\n    return instance;\n  }\n\n  __mountChildren(children, context) {\n    if (children == null) return children;\n\n    const nativeNode = this.__getNativeNode();\n    return this.__mountChildrenImpl(nativeNode, toArray(children), context);\n  }\n\n  __mountChildrenImpl(parent, children, context, nativeNodeMounter) {\n    let renderedChildren = this.__renderedChildren = {};\n\n    const renderedChildrenImage = [];\n    for (let i = 0, l = children.length; i < l; i++) {\n      const element = children[i];\n      const renderedChild = instantiateComponent(element);\n      const name = getElementKeyName(renderedChildren, element, i);\n      renderedChildren[name] = renderedChild;\n      renderedChild.__mountIndex = i;\n      // Mount children\n      const mountImage = renderedChild.__mountComponent(\n        parent,\n        this[INSTANCE],\n        context,\n        nativeNodeMounter\n      );\n      renderedChildrenImage.push(mountImage);\n    }\n\n    return renderedChildrenImage;\n  }\n\n  __unmountChildren(shouldNotRemoveChild) {\n    let renderedChildren = this.__renderedChildren;\n\n    if (renderedChildren) {\n      for (let name in renderedChildren) {\n        let renderedChild = renderedChildren[name];\n        renderedChild.unmountComponent(shouldNotRemoveChild);\n      }\n      this.__renderedChildren = null;\n    }\n  }\n\n  unmountComponent(shouldNotRemoveChild) {\n    if (this[NATIVE_NODE]) {\n      let ref = this.__currentElement.ref;\n      if (ref) {\n        detachRef(this.__currentElement._owner, ref, this);\n      }\n\n      Instance.remove(this[NATIVE_NODE]);\n\n      if (!shouldNotRemoveChild) {\n        Host.driver.removeChild(this[NATIVE_NODE], this._parent);\n      }\n    }\n\n    this.__unmountChildren(true);\n\n    this.__prevStyleCopy = null;\n    this.__destoryComponent();\n  }\n\n  __updateComponent(prevElement, nextElement, prevContext, nextContext) {\n    // Replace current element\n    this.__currentElement = nextElement;\n\n    updateRef(prevElement, nextElement, this);\n\n    let prevProps = prevElement.props;\n    let nextProps = nextElement.props;\n\n    this.__updateProperties(prevProps, nextProps);\n\n    // If the prevElement has no child, mount children directly\n    if (prevProps[CHILDREN] == null ||\n      isArray(prevProps[CHILDREN]) && prevProps[CHILDREN].length === 0) {\n      this.__mountChildren(nextProps[CHILDREN], nextContext);\n    } else {\n      this.__updateChildren(nextProps[CHILDREN], nextContext);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      Host.reconciler.receiveComponent(this);\n    }\n  }\n\n  __updateProperties(prevProps, nextProps) {\n    let propKey;\n    let styleName;\n    let styleUpdates;\n    const driver = Host.driver;\n    const nativeNode = this.__getNativeNode();\n\n    for (propKey in prevProps) {\n      // Continue children and null value prop or nextProps has some propKey that do noting\n      if (\n        propKey === CHILDREN ||\n        prevProps[propKey] == null ||\n        // Use hasOwnProperty here for avoid propKey name is some with method name in object proptotype\n        nextProps.hasOwnProperty(propKey)\n      ) {\n        continue;\n      }\n\n      if (propKey === STYLE) {\n        // Remove all style\n        let lastStyle = this.__prevStyleCopy;\n        for (styleName in lastStyle) {\n          styleUpdates = styleUpdates || {};\n          styleUpdates[styleName] = '';\n        }\n        this.__prevStyleCopy = null;\n      } else if (EVENT_PREFIX_REGEXP.test(propKey)) {\n        // Remove event\n        const eventListener = prevProps[propKey];\n\n        if (isFunction(eventListener)) {\n          driver.removeEventListener(\n            nativeNode,\n            propKey.slice(2).toLowerCase(),\n            eventListener\n          );\n        }\n      } else {\n        // Remove attribute\n        driver.removeAttribute(\n          nativeNode,\n          propKey,\n          prevProps[propKey]\n        );\n      }\n    }\n\n    for (propKey in nextProps) {\n      let nextProp = nextProps[propKey];\n      let prevProp = propKey === STYLE ? this.__prevStyleCopy :\n        prevProps != null ? prevProps[propKey] : undefined;\n\n      // Continue children or prevProp equal nextProp\n      if (\n        propKey === CHILDREN ||\n        prevProp === nextProp ||\n        nextProp == null && prevProp == null\n      ) {\n        continue;\n      }\n\n      // Update style\n      if (propKey === STYLE) {\n        if (nextProp) {\n          // Clone property\n          nextProp = this.__prevStyleCopy = assign({}, nextProp);\n        } else {\n          this.__prevStyleCopy = null;\n        }\n\n        if (prevProp != null) {\n          // Unset styles on `prevProp` but not on `nextProp`.\n          for (styleName in prevProp) {\n            if (!nextProp || !nextProp[styleName] && nextProp[styleName] !== 0) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = '';\n            }\n          }\n          // Update styles that changed since `prevProp`.\n          for (styleName in nextProp) {\n            if (prevProp[styleName] !== nextProp[styleName]) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = nextProp[styleName];\n            }\n          }\n        } else {\n          // Assign next prop when prev style is null\n          styleUpdates = nextProp;\n        }\n      } else if (EVENT_PREFIX_REGEXP.test(propKey)) {\n        // Update event binding\n        let eventName = propKey.slice(2).toLowerCase();\n\n        if (isFunction(prevProp)) {\n          driver.removeEventListener(nativeNode, eventName, prevProp, nextProps);\n        }\n\n        if (isFunction(nextProp)) {\n          driver.addEventListener(nativeNode, eventName, nextProp, nextProps);\n        }\n      } else {\n        // Update other property\n        if (nextProp != null) {\n          driver.setAttribute(\n            nativeNode,\n            propKey,\n            nextProp\n          );\n        } else {\n          driver.removeAttribute(\n            nativeNode,\n            propKey,\n            prevProps[propKey]\n          );\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          Host.measurer && Host.measurer.recordOperation({\n            instanceID: this._mountID,\n            type: 'update attribute',\n            payload: {\n              [propKey]: nextProp\n            }\n          });\n        }\n      }\n    }\n\n    if (styleUpdates) {\n      if (process.env.NODE_ENV !== 'production') {\n        Host.measurer && Host.measurer.recordOperation({\n          instanceID: this._mountID,\n          type: 'update style',\n          payload: styleUpdates\n        });\n      }\n\n      driver.setStyle(nativeNode, styleUpdates);\n    }\n  }\n\n  __updateChildren(nextChildrenElements, context) {\n    // prev rendered children\n    let prevChildren = this.__renderedChildren;\n    let driver = Host.driver;\n\n    if (nextChildrenElements == null && prevChildren == null) {\n      return;\n    }\n\n    let nextChildren = {};\n\n    if (nextChildrenElements != null) {\n      nextChildrenElements = toArray(nextChildrenElements);\n\n      // Update next children elements\n      for (let index = 0, length = nextChildrenElements.length; index < length; index++) {\n        let nextElement = nextChildrenElements[index];\n        let name = getElementKeyName(nextChildren, nextElement, index);\n        let prevChild = prevChildren && prevChildren[name];\n        let prevElement = prevChild && prevChild.__currentElement;\n        let prevContext = prevChild && prevChild._context;\n\n        // Try to update between the two of some name that has some element type,\n        // and move child in next children loop if need\n        if (prevChild != null && shouldUpdateComponent(prevElement, nextElement)) {\n          if (prevElement !== nextElement || prevContext !== context) {\n            // Pass the same context when updating children\n            prevChild.__updateComponent(prevElement, nextElement, context,\n              context);\n          }\n\n          nextChildren[name] = prevChild;\n        } else {\n          // Unmount the prevChild when some name with nextChild but different element type,\n          // and move child node in next children loop\n          if (prevChild) {\n            prevChild.__unmount = true;\n          }\n          // The child must be instantiated before it's mounted.\n          nextChildren[name] = instantiateComponent(nextElement);\n        }\n      }\n    }\n\n    let parent = this.__getNativeNode();\n    let isFragmentParent = isArray(parent);\n    let prevFirstChild = null;\n    let prevFirstNativeNode = null;\n    let isPrevFirstEmptyFragment = false;\n    let shouldUnmountPrevFirstChild = false;\n    let lastPlacedNode = null;\n\n    // Directly remove all children from component, if nextChildren is empty (null, [], '').\n    // `driver.removeChildren` is optional driver protocol.\n    let shouldRemoveAllChildren = Boolean(\n      driver.removeChildren\n      // nextChildElements == null or nextChildElements is empty\n      && (isNull(nextChildrenElements) || nextChildrenElements && !nextChildrenElements.length)\n      // Fragment parent can not remove parentNode's all child nodes directly.\n      && !isFragmentParent\n    );\n\n    // Unmount children that are no longer present.\n    if (prevChildren != null) {\n      for (let name in prevChildren) {\n        let prevChild = prevChildren[name];\n        let shouldUnmount = prevChild.__unmount || !nextChildren[name];\n\n        // Store old first child ref for append node ahead and maybe delay remove it\n        if (!prevFirstChild) {\n          shouldUnmountPrevFirstChild = shouldUnmount;\n          prevFirstChild = prevChild;\n          prevFirstNativeNode = prevFirstChild.__getNativeNode();\n\n          if (isArray(prevFirstNativeNode)) {\n            isPrevFirstEmptyFragment = prevFirstNativeNode.length === 0;\n            prevFirstNativeNode = prevFirstNativeNode[0];\n          }\n        } else if (shouldUnmount) {\n          prevChild.unmountComponent(shouldRemoveAllChildren);\n        }\n      }\n\n      // 1. When fragment embed fragment updated but prev fragment is empty\n      // that need to get the prev sibling native node.\n      // like: [ [] ] -> [ [1, 2] ]\n      // 2. When prev fragment is empty and update to other type\n      // like: [ [], 1 ] -> [ 1, 2 ]\n      if (isFragmentParent && parent.length === 0 || isPrevFirstEmptyFragment) {\n        lastPlacedNode = getPrevSiblingNativeNode(this);\n      }\n    }\n\n\n    if (nextChildren != null) {\n      // `nextIndex` will increment for each child in `nextChildren`\n      let nextIndex = 0;\n\n      function insertNodes(nativeNodes, parentNode) {\n        // The nativeNodes maybe fragment, so convert to array type\n        nativeNodes = toArray(nativeNodes);\n\n        for (let i = 0, l = nativeNodes.length; i < l; i++) {\n          if (lastPlacedNode) {\n            // Should reverse order when insert new child after lastPlacedNode:\n            // [lastPlacedNode, *newChild1, *newChild2],\n            // And if prev is empty fragment, lastPlacedNode is the prevSiblingNativeNode found.\n            driver.insertAfter(nativeNodes[l - 1 - i], lastPlacedNode);\n          } else if (prevFirstNativeNode) {\n            // [*newChild1, *newChild2, prevFirstNativeNode]\n            driver.insertBefore(nativeNodes[i], prevFirstNativeNode);\n          } else if (parentNode) {\n            // [*newChild1, *newChild2]\n            driver.appendChild(nativeNodes[i], parentNode);\n          }\n        }\n      }\n\n      for (let name in nextChildren) {\n        let nextChild = nextChildren[name];\n        let prevChild = prevChildren && prevChildren[name];\n\n        // Try to move the some key prevChild but current not at the some position\n        if (prevChild === nextChild) {\n          let prevChildNativeNode = prevChild.__getNativeNode();\n\n          if (prevChild.__mountIndex !== nextIndex) {\n            insertNodes(prevChildNativeNode);\n          }\n        } else {\n          // Mount nextChild that in prevChildren there has no some name\n\n          // Fragment extended native component, so if parent is fragment should get this._parent\n          if (isFragmentParent) {\n            parent = this._parent;\n          }\n\n          nextChild.__mountComponent(\n            parent,\n            this[INSTANCE],\n            context,\n            insertNodes // Insert nodes mounter\n          );\n        }\n\n        // Update to the latest mount order\n        nextChild.__mountIndex = nextIndex++;\n\n        // Get the last child\n        lastPlacedNode = nextChild.__getNativeNode();\n\n        if (isArray(lastPlacedNode)) {\n          lastPlacedNode = lastPlacedNode[lastPlacedNode.length - 1];\n        }\n      }\n    }\n\n    if (shouldUnmountPrevFirstChild) {\n      prevFirstChild.unmountComponent(shouldRemoveAllChildren);\n    }\n\n    if (shouldRemoveAllChildren) {\n      driver.removeChildren(this[NATIVE_NODE]);\n    }\n\n    this.__renderedChildren = nextChildren;\n  }\n\n  __createNativeNode() {\n    const instance = this[INSTANCE];\n    const nativeNode = Host.driver.createElement(instance.type, instance.props, this);\n    Instance.set(nativeNode, instance);\n    return nativeNode;\n  }\n}\n","import Host from './host';\nimport Component from './component';\nimport invokeFunctionsWithContext from '../invokeFunctionsWithContext';\nimport { throwMinifiedError } from '../error';\nimport { INTERNAL } from '../constant';\nimport { EMPTY_OBJECT } from '../types';\n\nconst RE_RENDER_LIMIT = 24;\n/**\n * Functional Reactive Component Class Wrapper\n */\nexport default class ReactiveComponent extends Component {\n  constructor(pureRender, ref) {\n    super();\n    // Marked ReactiveComponent.\n    this.__isReactiveComponent = true;\n    // A pure function\n    this.__render = pureRender;\n    this.__hookID = 0;\n    // Number of rerenders\n    this.__reRenders = 0;\n    this.__hooks = {};\n    // Is render scheduled\n    this.__isScheduled = false;\n    this.__shouldUpdate = false;\n    this.__children = null;\n    this.__contexts = {};\n    // Handles store\n    this.didMount = [];\n    this.didUpdate = [];\n    this.willUnmount = [];\n\n    this.state = EMPTY_OBJECT;\n\n    if (pureRender._forwardRef) {\n      this.__prevForwardRef = this._forwardRef = ref;\n    }\n\n    const compares = pureRender.__compares;\n    if (compares) {\n      this.shouldComponentUpdate = (nextProps) => {\n        // Process composed compare\n        let arePropsEqual = true;\n\n        // Compare push in and pop out\n        for (let i = compares.length - 1; i > -1; i--) {\n          if (arePropsEqual = compares[i](this.props, nextProps)) {\n            break;\n          }\n        }\n\n        return !arePropsEqual || this.__prevForwardRef !== this._forwardRef;\n      };\n    }\n  }\n\n  getHooks() {\n    return this.__hooks;\n  }\n\n  getHookID() {\n    return ++this.__hookID;\n  }\n\n  useContext(context) {\n    const contextID = context._contextID;\n    let contextItem = this.__contexts[contextID];\n    if (!contextItem) {\n      const provider = context.__getNearestParentProvider(this);\n      contextItem = this.__contexts[contextID] = {\n        __provider: provider\n      };\n\n      if (provider) {\n        const handleContextChange = (value) => {\n          // Check the last value that maybe alread rerender\n          // avoid rerender twice when provider value changed\n          if (contextItem.__lastValue !== value) {\n            this.__shouldUpdate = true;\n            this.__update();\n          }\n        };\n        provider.__on(handleContextChange);\n        this.willUnmount.push(() => provider.__off(handleContextChange));\n      }\n    }\n\n    return contextItem.__lastValue = contextItem.__provider ?\n      contextItem.__provider.getValue() : context._defaultValue;\n  }\n\n  componentWillMount() {\n    this.__shouldUpdate = true;\n  }\n\n  componentDidMount() {\n    invokeFunctionsWithContext(this.didMount);\n  }\n\n  componentWillReceiveProps() {\n    this.__shouldUpdate = true;\n  }\n\n  componentDidUpdate() {\n    invokeFunctionsWithContext(this.didUpdate);\n  }\n\n  componentWillUnmount() {\n    invokeFunctionsWithContext(this.willUnmount);\n  }\n\n  __update() {\n    this.setState(EMPTY_OBJECT);\n  }\n\n  render() {\n    if (process.env.NODE_ENV !== 'production') {\n      Host.measurer && Host.measurer.beforeRender();\n    }\n\n    this.__hookID = 0;\n    this.__reRenders = 0;\n    this.__isScheduled = false;\n    let children = this.__render(this.props, this._forwardRef ? this._forwardRef : this.context);\n\n    while (this.__isScheduled) {\n      this.__reRenders++;\n      if (this.__reRenders > RE_RENDER_LIMIT) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error('Too many re-renders, the number of renders is limited to prevent an infinite loop.');\n        } else {\n          throwMinifiedError(4);\n        }\n      }\n\n      this.__hookID = 0;\n      this.__isScheduled = false;\n      children = this.__render(this.props, this._forwardRef ? this._forwardRef : this.context);\n    }\n\n    if (this.__shouldUpdate) {\n      this.__children = children;\n      this.__shouldUpdate = false;\n    }\n\n    return this.__children;\n  }\n}\n","import Host from './host';\nimport { flushEffect, schedule, flushLayout } from './scheduler';\nimport { INTERNAL, RENDERED_COMPONENT } from '../constant';\n\n// Dirty components store\nlet dirtyComponents = [];\n\nfunction getPendingCallbacks(internal) {\n  return internal.__pendingCallbacks;\n}\n\nfunction setPendingCallbacks(internal, callbacks) {\n  return internal.__pendingCallbacks = callbacks;\n}\n\nfunction getPendingStateQueue(internal) {\n  return internal.__pendingStateQueue;\n}\n\nfunction setPendingStateQueue(internal, partialState) {\n  return internal.__pendingStateQueue = partialState;\n}\n\nfunction enqueueCallback(internal, callback) {\n  let callbackQueue = getPendingCallbacks(internal) || setPendingCallbacks(internal, []);\n  callbackQueue.push(callback);\n}\n\nfunction enqueueState(internal, partialState) {\n  let stateQueue = getPendingStateQueue(internal) || setPendingStateQueue(internal, []);\n  stateQueue.push(partialState);\n}\n\nfunction runUpdate(component) {\n  let internal = component[INTERNAL];\n  if (!internal) {\n    return;\n  }\n\n  Host.__isUpdating = true;\n\n  let prevElement = internal.__currentElement;\n  let prevUnmaskedContext = internal._context;\n  let nextUnmaskedContext = internal.__penddingContext || prevUnmaskedContext;\n  internal.__penddingContext = undefined;\n\n  if (getPendingStateQueue(internal) || internal.__isPendingForceUpdate) {\n    internal.__updateComponent(\n      prevElement,\n      prevElement,\n      prevUnmaskedContext,\n      nextUnmaskedContext\n    );\n\n    flushLayout();\n  }\n\n  Host.__isUpdating = false;\n}\n\nfunction mountOrderComparator(c1, c2) {\n  return c2[INTERNAL]._mountID - c1[INTERNAL]._mountID;\n}\n\nfunction performUpdate() {\n  if (Host.__isUpdating) {\n    return schedule(performUpdate);\n  }\n\n  let component;\n  let dirties = dirtyComponents;\n  if (dirties.length > 0) {\n    // Before next render, we will flush all the effects\n    flushEffect();\n    dirtyComponents = [];\n    // Since reconciling a component higher in the owner hierarchy usually (not\n    // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n    // them before their children by sorting the array.\n    if (dirties.length > 1) {\n      dirties = dirties.filter(c => !!c[INTERNAL]).sort(mountOrderComparator);\n    }\n\n    while (component = dirties.pop()) {\n      runUpdate(component);\n    }\n  }\n}\n\nfunction scheduleUpdate(component, shouldAsyncUpdate) {\n  if (dirtyComponents.indexOf(component) < 0) {\n    dirtyComponents.push(component);\n  }\n\n  if (shouldAsyncUpdate) {\n    // If have been scheduled before, do not need schedule again\n    if (dirtyComponents.length > 1) {\n      return;\n    }\n    schedule(performUpdate);\n  } else {\n    performUpdate();\n  }\n}\n\nfunction requestUpdate(component, partialState, callback) {\n  let internal = component[INTERNAL];\n\n  if (!internal) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Block other render\n      Host.__isUpdating = false;\n      console.error(\n        \"Warning: Can't perform a Rax state update on an unmounted component. This \" +\n          'is a no-op, but it indicates a memory leak in your application. To ' +\n          'fix, cancel all subscriptions and asynchronous tasks in %s.',\n        component.__isReactiveComponent\n          ? 'a useEffect cleanup function'\n          : 'the componentWillUnmount method',\n      );\n    }\n    return;\n  }\n\n  if (callback) {\n    enqueueCallback(internal, callback);\n  }\n\n  const hasComponentRendered = internal[RENDERED_COMPONENT];\n\n  // setState\n  if (partialState) {\n    // Function Component should force update\n    if (component.__isReactiveComponent) {\n      internal.__isPendingForceUpdate = true;\n    }\n    enqueueState(internal, partialState);\n    // State pending when request update in componentWillMount and componentWillReceiveProps,\n    // isPendingState default is false value (false or null) and set to true after componentWillReceiveProps,\n    // _renderedComponent is null when componentWillMount exec.\n    if (!internal.__isPendingState && hasComponentRendered) {\n      scheduleUpdate(component, true);\n    }\n  } else {\n    // forceUpdate\n    internal.__isPendingForceUpdate = true;\n\n    if (hasComponentRendered) {\n      scheduleUpdate(component);\n    }\n  }\n}\n\nconst Updater = {\n  setState(component, partialState, callback) {\n    // Flush all effects first before update state\n    if (!Host.__isUpdating) {\n      flushEffect();\n    }\n    requestUpdate(component, partialState, callback);\n  },\n  forceUpdate(component, callback) {\n    requestUpdate(component, null, callback);\n  }\n};\n\nexport default Updater;\n","import getNearestParent from './getNearestParent';\nimport { scheduler, scheduleLayout } from './scheduler';\nimport { INTERNAL } from '../constant';\n\nexport default function performInSandbox(fn, instance, callback) {\n  try {\n    return fn();\n  } catch (e) {\n    if (callback) {\n      callback(e);\n    } else {\n      handleError(instance, e);\n    }\n  }\n}\n\n/**\n * A class component becomes an error boundary if\n * it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch().\n * Use static getDerivedStateFromError() to render a fallback UI after an error has been thrown.\n * Use componentDidCatch() to log error information.\n * @param {*} instance\n * @param {*} error\n */\nexport function handleError(instance, error) {\n  let boundary = getNearestParent(instance, parent => {\n    return parent.componentDidCatch || parent.constructor && parent.constructor.getDerivedStateFromError;\n  });\n\n  if (boundary) {\n    scheduleLayout(() => {\n      const boundaryInternal = boundary[INTERNAL];\n      // Should not attempt to recover an unmounting error boundary\n      if (boundaryInternal) {\n        performInSandbox(() => {\n          if (boundary.componentDidCatch) {\n            boundary.componentDidCatch(error);\n          }\n\n          // Update state to the next render to show the fallback UI.\n          if (boundary.constructor && boundary.constructor.getDerivedStateFromError) {\n            const state = boundary.constructor.getDerivedStateFromError(error);\n            boundary.setState(state);\n          }\n        }, boundaryInternal.__parentInstance);\n      }\n    });\n  } else {\n    // Do not break when error happens\n    scheduler(() => {\n      throw error;\n    }, 0);\n  }\n}\n","import ReactiveComponent from './reactive';\nimport updater from './updater';\nimport Host from './host';\nimport { attachRef, updateRef, detachRef } from './ref';\nimport instantiateComponent from './instantiateComponent';\nimport shouldUpdateComponent from './shouldUpdateComponent';\nimport shallowEqual from './shallowEqual';\nimport BaseComponent from './base';\nimport getPrevSiblingNativeNode from './getPrevSiblingNativeNode';\nimport performInSandbox from './performInSandbox';\nimport toArray from '../toArray';\nimport { scheduleLayout } from './scheduler';\nimport { isFunction, isArray } from '../types';\nimport assign from '../assign';\nimport { INSTANCE, INTERNAL, RENDERED_COMPONENT } from '../constant';\nimport invokeFunctionsWithContext from '../invokeFunctionsWithContext';\nimport validateChildKeys from '../validateChildKeys';\nimport { throwError, throwMinifiedError } from '../error';\n\nlet measureLifeCycle;\nif (process.env.NODE_ENV !== 'production') {\n  measureLifeCycle = function(callback, instanceID, type) {\n    Host.measurer && Host.measurer.beforeLifeCycle(instanceID, type);\n    callback();\n    Host.measurer && Host.measurer.afterLifeCycle(instanceID, type);\n  };\n}\n\nfunction scheduleLayoutInSandbox(fn, instance) {\n  scheduleLayout(() => {\n    performInSandbox(fn, instance);\n  });\n}\n\nfunction scheduleLayoutCallbacksInSandbox(callbacks, instance) {\n  if (callbacks) {\n    scheduleLayoutInSandbox(() => {\n      invokeFunctionsWithContext(callbacks, instance);\n    }, instance);\n  }\n}\n\n/**\n * Composite Component\n */\nclass CompositeComponent extends BaseComponent {\n  __mountComponent(parent, parentInstance, context, nativeNodeMounter) {\n    this.__initComponent(parent, parentInstance, context);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._updateCount = 0;\n      Host.measurer && Host.measurer.beforeMountComponent(this._mountID, this);\n    }\n\n    let currentElement = this.__currentElement;\n    let Component = currentElement.type;\n    let ref = currentElement.ref;\n    let publicProps = currentElement.props;\n    let componentPrototype = Component.prototype;\n\n    // Context process\n    let publicContext = this.__processContext(context);\n\n    // Initialize the public class\n    let instance;\n    let renderedElement;\n\n    performInSandbox(() => {\n      if (componentPrototype && componentPrototype.render) {\n        // Class Component instance\n        instance = new Component(publicProps, publicContext);\n      } else if (isFunction(Component)) {\n        // Functional reactive component with hooks\n        instance = new ReactiveComponent(Component, ref);\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          throwError('Invalid component type, expected a class or function component.', Component);\n        } else {\n          throwMinifiedError(6, Component);\n        }\n      }\n    }, parentInstance);\n\n    if (!instance) {\n      return;\n    }\n\n    // These should be set up in the constructor, but as a convenience for\n    // simpler class abstractions, we set them up after the fact.\n    instance.props = publicProps;\n    instance.context = publicContext;\n    instance.refs = {};\n\n    // Inject the updater into instance\n    instance.updater = updater;\n    instance[INTERNAL] = this;\n    this[INSTANCE] = instance;\n\n    // Init state, must be set to an object or null\n    let initialState = instance.state;\n    if (initialState === undefined) {\n      // TODO clone the state?\n      instance.state = initialState = null;\n    }\n\n    if (instance.componentWillMount) {\n      performInSandbox(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          measureLifeCycle(() => {\n            instance.componentWillMount();\n          }, this._mountID, 'componentWillMount');\n        } else {\n          instance.componentWillMount();\n        }\n      }, instance);\n    }\n\n    Host.owner = this;\n    // Process pending state when call setState in componentWillMount\n    instance.state = this.__processPendingState(publicProps, publicContext);\n    const callbacks = this.__pendingCallbacks;\n    this.__pendingCallbacks = null;\n\n    performInSandbox(() => {\n      if (process.env.NODE_ENV !== 'production') {\n        measureLifeCycle(() => {\n          renderedElement = instance.render();\n        }, this._mountID, 'render');\n      } else {\n        renderedElement = instance.render();\n      }\n    }, instance);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateChildKeys(renderedElement, this.__currentElement.type);\n    }\n\n    Host.owner = null;\n\n    this[RENDERED_COMPONENT] = instantiateComponent(renderedElement);\n    this[RENDERED_COMPONENT].__mountComponent(\n      this._parent,\n      instance,\n      this.__processChildContext(context),\n      nativeNodeMounter\n    );\n\n    if (!currentElement.type._forwardRef && ref) {\n      attachRef(currentElement._owner, ref, this);\n    }\n\n    if (instance.componentDidMount) {\n      scheduleLayoutInSandbox(() => {\n        if (process.env.NODE_ENV !== 'production') {\n          measureLifeCycle(() => {\n            instance.componentDidMount();\n          }, this._mountID, 'componentDidMount');\n        } else {\n          instance.componentDidMount();\n        }\n      }, instance);\n    }\n\n    // Trigger setState callback\n    scheduleLayoutCallbacksInSandbox(callbacks, instance);\n\n    if (process.env.NODE_ENV !== 'production') {\n      scheduleLayout(() => {\n        Host.reconciler.mountComponent(this);\n        Host.measurer && Host.measurer.afterMountComponent(this._mountID);\n      });\n    }\n\n    return instance;\n  }\n\n  unmountComponent(shouldNotRemoveChild) {\n    let instance = this[INSTANCE];\n\n    // Unmounting a composite component maybe not complete mounted\n    // when throw error in component constructor stage\n    if (instance && instance.componentWillUnmount) {\n      performInSandbox(() => {\n        instance.componentWillUnmount();\n      }, instance);\n    }\n\n    if (this[RENDERED_COMPONENT] != null) {\n      let currentElement = this.__currentElement;\n      let ref = currentElement.ref;\n\n      if (!currentElement.type._forwardRef && ref) {\n        detachRef(currentElement._owner, ref, this);\n      }\n\n      this[RENDERED_COMPONENT].unmountComponent(shouldNotRemoveChild);\n      this[RENDERED_COMPONENT] = null;\n    }\n\n    // Reset pending fields\n    // Even if this component is scheduled for another async update,\n    // it would still be ignored because these fields are reset.\n    this.__pendingStateQueue = null;\n    this.__isPendingForceUpdate = false;\n\n    this.__destoryComponent();\n  }\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`\n   */\n  __processContext(context) {\n    let maskedContext = {};\n    let Component = this.__currentElement.type;\n    let contextTypes = Component.contextTypes;\n\n    if (contextTypes) {\n      for (let contextName in contextTypes) {\n        maskedContext[contextName] = context[contextName];\n      }\n    }\n\n    return maskedContext;\n  }\n\n  __processChildContext(currentContext) {\n    let instance = this[INSTANCE];\n    // The getChildContext method context should be current instance\n    let childContext = instance.getChildContext && instance.getChildContext();\n    if (childContext) {\n      return assign({}, currentContext, childContext);\n    }\n\n    return currentContext;\n  }\n\n  __processPendingState(props, context) {\n    let instance = this[INSTANCE];\n    let queue = this.__pendingStateQueue;\n    if (!queue) {\n      return instance.state;\n    }\n    // Reset pending queue\n    this.__pendingStateQueue = null;\n    let nextState = assign({}, instance.state);\n    for (let i = 0; i < queue.length; i++) {\n      let partial = queue[i];\n      assign(\n        nextState,\n        isFunction(partial) ?\n          partial.call(instance, nextState, props, context) :\n          partial\n      );\n    }\n\n    return nextState;\n  }\n\n  __updateComponent(\n    prevElement,\n    nextElement,\n    prevUnmaskedContext,\n    nextUnmaskedContext\n  ) {\n    let instance = this[INSTANCE];\n\n    // Maybe update component that has already been unmounted or failed mount.\n    if (!instance) {\n      return;\n    }\n\n    performInSandbox(() => {\n      if (process.env.NODE_ENV !== 'production') {\n        Host.measurer && Host.measurer.beforeUpdateComponent(this._mountID, this);\n      }\n\n      let willReceive;\n      let nextContext;\n      let nextProps;\n\n      // Determine if the context has changed or not\n      if (this._context === nextUnmaskedContext) {\n        nextContext = instance.context;\n      } else {\n        nextContext = this.__processContext(nextUnmaskedContext);\n        willReceive = true;\n      }\n\n      // Distinguish between a props update versus a simple state update\n      // Skip checking prop types again -- we don't read component.props to avoid\n      // warning for DOM component props in this upgrade\n      nextProps = nextElement.props;\n\n      if (prevElement !== nextElement) {\n        willReceive = true;\n      }\n\n      if (willReceive && instance.componentWillReceiveProps) {\n        // Calling this.setState() within componentWillReceiveProps will not trigger an additional render.\n        this.__isPendingState = true;\n        instance.componentWillReceiveProps(nextProps, nextContext);\n        this.__isPendingState = false;\n      }\n\n      // Update refs\n      if (this.__currentElement.type._forwardRef) {\n        instance.__prevForwardRef = prevElement.ref;\n        instance._forwardRef = nextElement.ref;\n      } else {\n        updateRef(prevElement, nextElement, this);\n      }\n\n      // Shoud update default\n      let shouldUpdate = true;\n      let prevProps = instance.props;\n      let prevState = instance.state;\n      // TODO: could delay execution processPendingState\n      let nextState = this.__processPendingState(nextProps, nextContext);\n      const callbacks = this.__pendingCallbacks;\n      this.__pendingCallbacks = null;\n\n      // ShouldComponentUpdate is not called when forceUpdate is used\n      if (!this.__isPendingForceUpdate) {\n        if (instance.shouldComponentUpdate) {\n          shouldUpdate = instance.shouldComponentUpdate(nextProps, nextState, nextContext);\n        } else if (instance.__isPureComponent) {\n          // Pure Component\n          shouldUpdate = !shallowEqual(prevProps, nextProps) ||\n            !shallowEqual(prevState, nextState);\n        }\n      }\n\n      if (shouldUpdate) {\n        this.__isPendingForceUpdate = false;\n        // Will set `this.props`, `this.state` and `this.context`.\n        let prevContext = instance.context;\n\n        // Cannot use this.setState() in componentWillUpdate.\n        // If need to update state in response to a prop change, use componentWillReceiveProps instead.\n        if (instance.componentWillUpdate) {\n          instance.componentWillUpdate(nextProps, nextState, nextContext);\n        }\n\n        // Replace with next\n        this.__currentElement = nextElement;\n        this._context = nextUnmaskedContext;\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = nextContext;\n\n        this.__updateRenderedComponent(nextUnmaskedContext);\n\n        if (instance.componentDidUpdate) {\n          scheduleLayoutInSandbox(() => {\n            instance.componentDidUpdate(prevProps, prevState, prevContext);\n          }, instance);\n        }\n\n        if (process.env.NODE_ENV !== 'production') {\n          // Calc update count.\n          this._updateCount++;\n        }\n      } else {\n        // If it's determined that a component should not update, we still want\n        // to set props and state but we shortcut the rest of the update.\n        this.__currentElement = nextElement;\n        this._context = nextUnmaskedContext;\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = nextContext;\n      }\n\n      scheduleLayoutCallbacksInSandbox(callbacks, instance);\n\n      if (process.env.NODE_ENV !== 'production') {\n        scheduleLayout(() => {\n          Host.measurer && Host.measurer.afterUpdateComponent(this._mountID);\n          Host.reconciler.receiveComponent(this);\n        });\n      }\n    }, instance);\n  }\n\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   */\n  __updateRenderedComponent(context) {\n    let prevRenderedComponent = this[RENDERED_COMPONENT];\n    let prevRenderedElement = prevRenderedComponent.__currentElement;\n\n    let instance = this[INSTANCE];\n    let nextRenderedElement;\n\n    Host.owner = this;\n\n    if (process.env.NODE_ENV !== 'production') {\n      measureLifeCycle(() => {\n        nextRenderedElement = instance.render();\n      }, this._mountID, 'render');\n    } else {\n      nextRenderedElement = instance.render();\n    }\n\n    Host.owner = null;\n\n    if (shouldUpdateComponent(prevRenderedElement, nextRenderedElement)) {\n      const prevRenderedUnmaskedContext = prevRenderedComponent._context;\n      const nextRenderedUnmaskedContext = this.__processChildContext(context);\n      // If getChildContext existed and invoked when component updated that will make\n      // prevRenderedUnmaskedContext not equal nextRenderedUnmaskedContext under the tree\n      if (prevRenderedElement !== nextRenderedElement || prevRenderedUnmaskedContext !== nextRenderedUnmaskedContext) {\n        // If element type is illegal catch the error\n        prevRenderedComponent.__updateComponent(\n          prevRenderedElement,\n          nextRenderedElement,\n          prevRenderedUnmaskedContext,\n          nextRenderedUnmaskedContext\n        );\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        Host.measurer && Host.measurer.recordOperation({\n          instanceID: this._mountID,\n          type: 'update component',\n          payload: {}\n        });\n      }\n    } else {\n      let lastNativeNode = null;\n      let prevNativeNode = prevRenderedComponent.__getNativeNode();\n      // Only prevNativeNode is empty fragment should find the prevSlibingNativeNode\n      // And current root component is fragment, but not need find the prevSlibingNativeNode when init mounting\n      if (isArray(prevNativeNode) && prevNativeNode.length === 0 && instance.__rootID == null) {\n        lastNativeNode = getPrevSiblingNativeNode(prevRenderedComponent);\n      }\n\n      prevRenderedComponent.unmountComponent(true);\n\n      this[RENDERED_COMPONENT] = instantiateComponent(nextRenderedElement);\n      this[RENDERED_COMPONENT].__mountComponent(\n        this._parent,\n        instance,\n        this.__processChildContext(context),\n        (newNativeNode, parent) => {\n          const driver = Host.driver;\n\n          prevNativeNode = toArray(prevNativeNode);\n          newNativeNode = toArray(newNativeNode);\n\n          // If the new length large then prev\n          for (let i = 0; i < newNativeNode.length; i++) {\n            let nativeNode = newNativeNode[i];\n            if (prevNativeNode[i]) {\n              driver.replaceChild(nativeNode, prevNativeNode[i]);\n            } else if (lastNativeNode) {\n              driver.insertAfter(nativeNode, lastNativeNode);\n            } else {\n              driver.appendChild(nativeNode, parent);\n            }\n            lastNativeNode = nativeNode;\n          }\n\n          // If the new length less then prev\n          for (let i = newNativeNode.length; i < prevNativeNode.length; i++) {\n            driver.removeChild(prevNativeNode[i]);\n          }\n        }\n      );\n    }\n  }\n\n  __getNativeNode() {\n    let renderedComponent = this[RENDERED_COMPONENT];\n    if (renderedComponent) {\n      return renderedComponent.__getNativeNode();\n    }\n  }\n\n  __getPublicInstance() {\n    let instance = this[INSTANCE];\n\n    // The functional components cannot be given refs\n    if (instance.__isReactiveComponent) return null;\n\n    return instance;\n  }\n}\n\nexport default CompositeComponent;\n","import Host from './host';\nimport BaseComponent from './base';\n\n/**\n * Text Component\n */\nclass TextComponent extends BaseComponent {\n  __updateComponent(prevElement, nextElement, context) {\n    nextElement = '' + nextElement;\n    // If text is some value that do not update even there number 1 and string \"1\"\n    if (prevElement !== nextElement) {\n      // Replace current element\n      this.__currentElement = nextElement;\n      Host.driver.updateText(this.__getNativeNode(), nextElement);\n\n      if (process.env.NODE_ENV !== 'production') {\n        this._stringText = this.__currentElement;\n        Host.reconciler.receiveComponent(this);\n      }\n    }\n  }\n\n  __createNativeNode() {\n    if (process.env.NODE_ENV !== 'production') {\n      this._stringText = this.__currentElement;\n    }\n    return Host.driver.createText(this.__currentElement, this);\n  }\n}\n\nexport default TextComponent;\n","import Host from './host';\nimport NativeComponent from './native';\nimport toArray from '../toArray';\nimport { INSTANCE, INTERNAL, NATIVE_NODE } from '../constant';\n\n/**\n * Fragment Component\n */\nclass FragmentComponent extends NativeComponent {\n  __mountComponent(parent, parentInstance, context, nativeNodeMounter) {\n    this.__initComponent(parent, parentInstance, context);\n\n    let instance = this[INSTANCE] = {};\n    instance[INTERNAL] = this;\n\n    const fragment = [];\n    this.__mountChildrenImpl(this._parent, this.__currentElement, context, (nativeNode) => {\n      nativeNode = toArray(nativeNode);\n      for (let i = 0; i < nativeNode.length; i++) {\n        fragment.push(nativeNode[i]);\n      }\n    });\n    if (nativeNodeMounter) {\n      nativeNodeMounter(fragment, parent);\n    } else {\n      for (let i = 0; i < fragment.length; i++) {\n        Host.driver.appendChild(fragment[i], parent);\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      this.__currentElement.type = FragmentComponent;\n      Host.reconciler.mountComponent(this);\n    }\n\n    return instance;\n  }\n\n  unmountComponent(shouldNotRemoveChild) {\n    if (!shouldNotRemoveChild) {\n      const nativeNode = this.__getNativeNode();\n      for (let i = 0, l = nativeNode.length; i < l; i++) {\n        Host.driver.removeChild(nativeNode[i]);\n      }\n    }\n\n    // Do not need remove child when their parent is removed\n    this.__unmountChildren(true);\n    this.__destoryComponent();\n  }\n\n  __updateComponent(prevElement, nextElement, prevContext, nextContext) {\n    // Replace current element\n    this.__currentElement = nextElement;\n    this.__updateChildren(this.__currentElement, nextContext);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this.__currentElement.type = FragmentComponent;\n      Host.reconciler.receiveComponent(this);\n    }\n  }\n\n  __getNativeNode() {\n    const renderedChildren = this.__renderedChildren || {};\n    return [].concat.apply([], Object.keys(renderedChildren).map(key => renderedChildren[key].__getNativeNode()));\n  }\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  FragmentComponent.displayName = 'Fragment';\n}\n\nexport default FragmentComponent;\n","import Host from './host';\nimport BaseComponent from './base';\n\n/**\n * Empty Component\n */\nclass EmptyComponent extends BaseComponent {\n  __createNativeNode() {\n    return Host.driver.createEmpty(this);\n  }\n  __updateComponent() {\n    return;\n  }\n}\n\nexport default EmptyComponent;\n","import injectRenderOptions from './vdom/injectRenderOptions';\nimport Instance from './vdom/instance';\nimport { isFunction, EMPTY_OBJECT } from './types';\nimport inject from './vdom/inject';\n\n// Inject init options to host, avoid circle deps between class component file and ./vdom/host\ninject();\n\nfunction render(element, container, options, callback) {\n  // Compatible with `render(element, container, callback)`\n  if (isFunction(options)) {\n    callback = options;\n    options = null;\n  }\n\n  options = options || EMPTY_OBJECT;\n  // Init inject\n  injectRenderOptions(options);\n\n  let rootComponent = Instance.mount(element, container, options);\n  let componentInstance = rootComponent.__getPublicInstance();\n\n  if (callback) {\n    callback.call(componentInstance);\n  }\n\n  return componentInstance;\n}\n\nexport default render;\n","import Host from './host';\nimport { throwError, throwMinifiedError } from '../error';\n\nexport default function injectRenderOptions({ driver, measurer }) {\n  // Inject render driver\n  if (!(Host.driver = driver || Host.driver)) {\n    if (process.env.NODE_ENV !== 'production') {\n      throwError('Rax driver not found.');\n    } else {\n      throwMinifiedError(5);\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Inject performance measurer\n    Host.measurer = measurer;\n  }\n}\n","import Host from './host';\nimport NativeComponent from './native';\nimport CompositeComponent from './composite';\nimport TextComponent from './text';\nimport FragmentComponent from './fragment';\nimport EmptyComponent from './empty';\nimport reconciler from '../devtools/reconciler';\n\nexport default function inject() {\n  // Inject component class\n  Host.__Empty = EmptyComponent;\n  Host.__Native = NativeComponent;\n  Host.__Text = TextComponent;\n  Host.__Fragment = FragmentComponent;\n  Host.__Composite = CompositeComponent;\n\n  if (process.env.NODE_ENV !== 'production') {\n    // Inject devtool renderer hook\n    Host.reconciler = reconciler;\n  }\n}\n","export default process.env.RAX_VERSION;\n","export createElement from './createElement';\nexport createContext from './createContext';\nexport createRef from './createRef';\nexport forwardRef from './forwardRef';\nexport { useState, useContext, useEffect, useLayoutEffect, useRef, useCallback, useMemo, useReducer, useImperativeHandle } from './hooks';\nexport memo from './memo';\nexport Fragment from './fragment';\nexport render from './render';\nexport Component, { PureComponent } from './vdom/component';\nexport version from './version';\n\nimport Host from './vdom/host';\nimport Instance from './vdom/instance';\nimport Element from './vdom/element';\nimport flattenChildren from './vdom/flattenChildren';\nimport DevtoolsHook from './devtools/index';\n\nexport const shared = {\n  Host,\n  Instance,\n  Element,\n  flattenChildren,\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  /* global __RAX_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __RAX_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n    typeof __RAX_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {\n    __RAX_DEVTOOLS_GLOBAL_HOOK__.inject(DevtoolsHook);\n  }\n\n  if (typeof window !== 'undefined') {\n    if (window.__RAX_INITIALISED__) {\n      console.error('Warning: more than one instance of Rax has been initialised, this could lead to unexpected behaviour.');\n    }\n    window.__RAX_INITIALISED__ = true;\n  }\n}\n"],"names":["Host","__mountID","__isUpdating","driver","rootComponents","rootInstances","owner","Element","type","key","ref","props","_owner","isNull","obj","isFunction","isObject","isPlainObject","EMPTY_OBJECT","toString","call","isArray","array","Array","isString","string","isNumber","isFalsy","val","NOOP","traverseChildren","children","result","i","l","length","push","flattenChildren","updateCallbacks","effectCallbacks","layoutCallbacks","scheduler","setTimeout","invokeFunctionsWithClear","callbacks","callback","shift","schedule","flush","scheduleEffect","flushEffect","scheduleLayout","createMinifiedError","code","ownerComponent","typeInfo","undefined","Object","keys","getTypeInfo","Error","__getName","throwMinifiedError","throwMinifiedWarn","err","RESERVED_PROPS","createElement","config","propName","childrenLength","arguments","childArray","defaultProps","invokeFunctionsWithContext","fns","context","value","hasOwnProperty","is","x","y","shallowEqual","objA","objB","keysA","INTERNAL","INSTANCE","NATIVE_NODE","RENDERED_COMPONENT","getCurrentInstance","getCurrentRenderingInstance","currentInstance","areInputsEqual","inputs","prevInputs","useState","initialState","hookID","getHookID","hooks","getHooks","newState","hook","eagerState","__isScheduled","__update","__shouldUpdate","useContext","useEffect","effect","useEffectImpl","useLayoutEffect","defered","__create","__inputs","__prevInputs","current","immediately","__destory","didMount","willUnmount","didUpdate","useImperativeHandle","create","concat","useRef","initialValue","useCallback","useMemo","useReducer","reducer","initialArg","init","action","queue","__actions","currentState","__eagerState","eagerReducer","__eagerReducer","next","__reRenders","toArray","getNearestParent","instance","matcher","parent","__parentInstance","id","createContext","defaultValue","contextID","getNearestParentProvider","__contextID","Provider","this","__handlers","_proto","prototype","__on","handler","__off","filter","h","_getChildContext","_ref","getValue","componentDidUpdate","prevProps","render","Consumer","_this","provider","setValue","_useState2","consumer","_contextID","_defaultValue","__getNearestParentProvider","createRef","forwardRef","_forwardRef","memo","compare","__compares","Fragment","instantiateComponent","element","__Native","__Composite","__Text","String","__Fragment","__Empty","Component","refs","setState","partialState","updater","forceUpdate","PureComponent","_Component","__isPureComponent","_inheritsLoose","rootID","Root","__element","__rootID","__getPublicInstance","__getRenderedComponent","KEY","Instance","set","node","get","remove","mount","container","hydrate","createBody","parentContext","renderOptions","beforeRender","parentInternal","__processChildContext","_context","prevRootInstance","__penddingContext","afterRender","rootInstance","__mountComponent","updateRef","prevElement","nextElement","component","prevRef","nextRef","detachRef","attachRef","shouldUpdateComponent","prevFalsy","nextFalsy","getElementKeyName","index","elementKey","defaultName","keyName","getPrevSiblingNativeNode","__renderedChildren","__mountIndex","nativeNode","__getNativeNode","BaseComponent","__currentElement","__initComponent","parentInstance","_parent","_mountID","__destoryComponent","nativeNodeMounter","__mountNativeNode","unmountComponent","shouldNotRemoveChild","removeChild","currentElement","displayName","name","appendChild","__createNativeNode","assign","STYLE","CHILDREN","TREE","EVENT_PREFIX_REGEXP","NativeComponent","_BaseComponent","apply","appendType","append","__prevStyleCopy","__mountChildren","__mountChildrenImpl","renderedChildren","renderedChildrenImage","renderedChild","mountImage","__unmountChildren","__updateComponent","prevContext","nextContext","nextProps","__updateProperties","__updateChildren","propKey","styleName","styleUpdates","lastStyle","test","eventListener","removeEventListener","slice","toLowerCase","removeAttribute","nextProp","prevProp","eventName","addEventListener","setAttribute","setStyle","nextChildrenElements","prevChildren","nextChildren","prevChild","__unmount","isFragmentParent","prevFirstChild","prevFirstNativeNode","isPrevFirstEmptyFragment","shouldUnmountPrevFirstChild","lastPlacedNode","shouldRemoveAllChildren","removeChildren","shouldUnmount","insertNodes","nativeNodes","parentNode","insertAfter","insertBefore","nextIndex","nextChild","prevChildNativeNode","ReactiveComponent","pureRender","__isReactiveComponent","__render","__hookID","__hooks","__children","__contexts","state","__prevForwardRef","compares","shouldComponentUpdate","arePropsEqual","_this2","contextItem","__provider","handleContextChange","__lastValue","componentWillMount","componentDidMount","componentWillReceiveProps","componentWillUnmount","dirtyComponents","getPendingStateQueue","internal","__pendingStateQueue","runUpdate","prevUnmaskedContext","nextUnmaskedContext","__isPendingForceUpdate","mountOrderComparator","c1","c2","performUpdate","dirties","c","sort","pop","scheduleUpdate","shouldAsyncUpdate","indexOf","requestUpdate","callbackQueue","__pendingCallbacks","getPendingCallbacks","setPendingCallbacks","enqueueCallback","hasComponentRendered","stateQueue","setPendingStateQueue","enqueueState","__isPendingState","Updater","performInSandbox","fn","e","error","boundary","componentDidCatch","constructor","getDerivedStateFromError","boundaryInternal","handleError","scheduleLayoutInSandbox","scheduleLayoutCallbacksInSandbox","CompositeComponent","renderedElement","publicProps","componentPrototype","publicContext","__processContext","__processPendingState","maskedContext","contextTypes","contextName","currentContext","childContext","getChildContext","nextState","partial","willReceive","shouldUpdate","prevState","componentWillUpdate","__updateRenderedComponent","nextRenderedElement","prevRenderedComponent","prevRenderedElement","prevRenderedUnmaskedContext","nextRenderedUnmaskedContext","lastNativeNode","prevNativeNode","newNativeNode","replaceChild","renderedComponent","TextComponent","updateText","createText","FragmentComponent","_NativeComponent","fragment","map","EmptyComponent","createEmpty","options","componentInstance","version","process","shared"],"mappings":"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"}