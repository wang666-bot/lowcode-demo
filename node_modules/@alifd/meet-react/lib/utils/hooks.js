"use strict";

exports.__esModule = true;
exports.default = useWhyDidYouUpdate;
exports.guid = guid;
exports.useDebounce = useDebounce;
exports.useDeprecated = useDeprecated;
exports.useForceUpdate = useForceUpdate;
exports.useGuid = useGuid;
exports.useValue = useValue;
var _react = _interopRequireWildcard(require("react"));
var _fp = require("./fp");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function useValue(props, defaultValue, options) {
  var _ref = options || {},
    _ref$valueName = _ref.valueName,
    valueName = _ref$valueName === void 0 ? 'value' : _ref$valueName,
    fitValue = _ref.fitValue,
    compare = _ref.compare;
  var defaultName = (0, _react.useMemo)(function () {
    var n = valueName.substr(0, 1).toUpperCase() + valueName.substr(1);
    return "default" + n;
  }, [valueName]);
  var isControlled = (valueName in props);
  var defaultVal = (0, _react.useMemo)(function () {
    var v = defaultValue;
    if (defaultName in props) {
      v = props[defaultName];
    }
    if (isControlled) {
      v = props[valueName];
    }
    if ((0, _fp.isNil)(v)) {
      v = defaultValue;
    }
    if (fitValue) {
      v = fitValue(v);
    }
    return v;
  }, []);
  var getControlledValue = function () {
    var x = props[valueName];
    if ((0, _fp.isNil)(x)) {
      if (fitValue) {
        return fitValue(defaultValue);
      }
      return defaultValue;
    }
    if (fitValue) {
      return fitValue(x);
    }
    return x;
  };
  var _useState = (0, _react.useState)(defaultVal),
    value = _useState[0],
    setValue = _useState[1];
  var propValue = (0, _react.useRef)(defaultVal);
  (0, _react.useEffect)(function () {
    if (isControlled) {
      var newValue = getControlledValue();
      var isSame = compare ? compare(newValue, propValue.current) : newValue === propValue.current;
      if (!isSame) {
        propValue.current = newValue;
        setValue(newValue);
      }
    }
  }, [props[valueName], props.dataSource]);
  var setPropValue = function (val) {
    var isSame = compare ? compare(val, propValue.current) : val === propValue.current;
    if (!isSame) {
      propValue.current = val;
      setValue(val);
    }
  };
  if (isControlled) {
    return [propValue.current, setValue, isControlled, setPropValue];
  }
  return [value, setValue, isControlled, setPropValue];
}
function useDeprecated(comp, props, oldName, newName, defaultValue) {
  (0, _react.useEffect)(function () {
    if (oldName in props && console && console.warn) {
      console.warn("Warning: " + comp + "." + oldName + " is deprecated and will be removed in a future version, please use " + newName + " instead");
    }
  }, []);
  if (newName in props) {
    return props[newName];
  }
  if (oldName in props) {
    return props[oldName];
  }
  return defaultValue;
}
var counter = 0;
function guid(prefix) {
  if (prefix === void 0) {
    prefix = '';
  }
  counter += 1;
  return "" + prefix + counter;
}
function useGuid(prefix) {
  if (prefix === void 0) {
    prefix = '';
  }
  var id = (0, _react.useRef)(guid(prefix));
  return id.current;
}
function useForceUpdate() {
  var _useState2 = (0, _react.useState)(0),
    update = _useState2[1];
  var cb = (0, _react.useCallback)(function () {
    return update(function (x) {
      return x >= Number.MAX_SAFE_INTEGER ? 0 : x + 1;
    });
  }, []);
  return cb;
}
function useWhyDidYouUpdate(componentName, props) {
  var prevProps = (0, _react.useRef)({});
  (0, _react.useEffect)(function () {
    if (prevProps.current) {
      var allKeys = Object.keys(Object.assign(Object.assign({}, prevProps.current), props));
      var changedProps = {};
      allKeys.forEach(function (key) {
        if (prevProps.current[key] !== props[key]) {
          changedProps[key] = {
            from: prevProps.current[key],
            to: props[key]
          };
        }
      });
      if (Object.keys(changedProps).length) {
        console.log('[why-did-you-update]', componentName, changedProps);
      }
    }
    prevProps.current = props;
  });
}
function useDebounce(func, wait, options) {
  var _ref2$leading = (options || {}).leading,
    leading = _ref2$leading === void 0 ? false : _ref2$leading;
  var funcRef = (0, _react.useRef)(func);
  funcRef.current = func;
  return (0, _react.useMemo)(function () {
    var timeout = null;
    var isLeadingInvoked = false;
    var debounced = function () {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (timeout) {
        clearTimeout(timeout);
      }
      if (leading && !timeout) {
        funcRef.current.apply(this, args);
        isLeadingInvoked = true;
      } else {
        isLeadingInvoked = false;
      }
      timeout = setTimeout(function () {
        if (!isLeadingInvoked) {
          funcRef.current.apply(_this, args);
        }
        timeout = null;
      }, wait);
    };
    debounced.cancel = function () {
      return clearTimeout(timeout);
    };
    return debounced;
  }, [wait, leading]);
}