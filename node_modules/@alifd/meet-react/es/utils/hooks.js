function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { isNil } from './fp';
export function useValue(props, defaultValue, options) {
  var _ref = options || {},
    _ref$valueName = _ref.valueName,
    valueName = _ref$valueName === void 0 ? 'value' : _ref$valueName,
    fitValue = _ref.fitValue,
    compare = _ref.compare;
  var defaultName = useMemo(function () {
    var n = valueName.substr(0, 1).toUpperCase() + valueName.substr(1);
    return "default".concat(n);
  }, [valueName]);
  var isControlled = (valueName in props);
  var defaultVal = useMemo(function () {
    var v = defaultValue;
    if (defaultName in props) {
      v = props[defaultName];
    }
    if (isControlled) {
      v = props[valueName];
    }
    if (isNil(v)) {
      v = defaultValue;
    }
    if (fitValue) {
      v = fitValue(v);
    }
    return v;
  }, []);
  var getControlledValue = function getControlledValue() {
    var x = props[valueName];
    if (isNil(x)) {
      if (fitValue) {
        return fitValue(defaultValue);
      }
      return defaultValue;
    }
    if (fitValue) {
      return fitValue(x);
    }
    return x;
  };
  var _useState = useState(defaultVal),
    _useState2 = _slicedToArray(_useState, 2),
    value = _useState2[0],
    setValue = _useState2[1];
  var propValue = useRef(defaultVal);
  useEffect(function () {
    if (isControlled) {
      var newValue = getControlledValue();
      var isSame = compare ? compare(newValue, propValue.current) : newValue === propValue.current;
      if (!isSame) {
        propValue.current = newValue;
        setValue(newValue);
      }
    }
  }, [props[valueName], props.dataSource]);
  var setPropValue = function setPropValue(val) {
    var isSame = compare ? compare(val, propValue.current) : val === propValue.current;
    if (!isSame) {
      propValue.current = val;
      setValue(val);
    }
  };
  if (isControlled) {
    return [propValue.current, setValue, isControlled, setPropValue];
  }
  return [value, setValue, isControlled, setPropValue];
}
export function useDeprecated(comp, props, oldName, newName, defaultValue) {
  useEffect(function () {
    if (oldName in props && console && console.warn) {
      console.warn("Warning: ".concat(comp, ".").concat(oldName, " is deprecated and will be removed in a future version, please use ").concat(newName, " instead"));
    }
  }, []);
  if (newName in props) {
    return props[newName];
  }
  if (oldName in props) {
    return props[oldName];
  }
  return defaultValue;
}
var counter = 0;
export function guid() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  counter += 1;
  return "".concat(prefix).concat(counter);
}
export function useGuid() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var id = useRef(guid(prefix));
  return id.current;
}
export function useForceUpdate() {
  var _useState3 = useState(0),
    _useState4 = _slicedToArray(_useState3, 2),
    update = _useState4[1];
  var cb = useCallback(function () {
    return update(function (x) {
      return x >= Number.MAX_SAFE_INTEGER ? 0 : x + 1;
    });
  }, []);
  return cb;
}
export default function useWhyDidYouUpdate(componentName, props) {
  var prevProps = useRef({});
  useEffect(function () {
    if (prevProps.current) {
      var allKeys = Object.keys(Object.assign(Object.assign({}, prevProps.current), props));
      var changedProps = {};
      allKeys.forEach(function (key) {
        if (prevProps.current[key] !== props[key]) {
          changedProps[key] = {
            from: prevProps.current[key],
            to: props[key]
          };
        }
      });
      if (Object.keys(changedProps).length) {
        console.log('[why-did-you-update]', componentName, changedProps);
      }
    }
    prevProps.current = props;
  });
}
export function useDebounce(func, wait, options) {
  var _ref2 = options || {},
    _ref2$leading = _ref2.leading,
    leading = _ref2$leading === void 0 ? false : _ref2$leading;
  var funcRef = useRef(func);
  funcRef.current = func;
  return useMemo(function () {
    var timeout = null;
    var isLeadingInvoked = false;
    var debounced = function debounced() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (timeout) {
        clearTimeout(timeout);
      }
      if (leading && !timeout) {
        funcRef.current.apply(this, args);
        isLeadingInvoked = true;
      } else {
        isLeadingInvoked = false;
      }
      timeout = setTimeout(function () {
        if (!isLeadingInvoked) {
          funcRef.current.apply(_this, args);
        }
        timeout = null;
      }, wait);
    };
    debounced.cancel = function () {
      return clearTimeout(timeout);
    };
    return debounced;
  }, [wait, leading]);
}