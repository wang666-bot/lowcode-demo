"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _validate2 = _interopRequireDefault(require("@alifd/validate"));
var _utils = require("./utils");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var initMeta = {
  state: '',
  valueName: 'value',
  trigger: 'onChange',
  inputValues: []
};
var Field = /*#__PURE__*/function () {
  function Field(com) {
    var _this2 = this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Field);
    if (!com) {
      (0, _utils.warning)('`this` is missing in `Field`, you should use like `new Field(this)`');
    }
    this.com = com;
    this.fieldsMeta = {};
    this.cachedBind = {};
    this.instance = {};
    this.instanceCount = {};
    this.reRenders = {};
    this.listeners = {};
    // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.
    // Also used caching values when using `parseName: true` before a field is initialized
    this.values = (0, _extends2.default)({}, options.values);
    this.processErrorMessage = options.processErrorMessage;
    this.afterValidateRerender = options.afterValidateRerender;
    this.options = (0, _extends2.default)({
      parseName: false,
      forceUpdate: false,
      scrollToFirstError: true,
      first: false,
      onChange: function onChange() {},
      autoUnmount: true,
      autoValidate: true
    }, options);
    ['init', 'getValue', 'getValues', 'setValue', 'setValues', 'getError', 'getErrors', 'setError', 'setErrors', 'validateCallback', 'validatePromise', 'getState', 'reset', 'resetToDefault', 'remove', 'spliceArray', 'addArrayValue', 'deleteArrayValue', 'getNames'].forEach(function (m) {
      _this2[m] = _this2[m].bind(_this2);
    });
  }
  (0, _createClass2.default)(Field, [{
    key: "setOptions",
    value: function setOptions(options) {
      (0, _extends2.default)(this.options, options);
    }

    /**
     * Controlled Component
     * @param {String} name
     * @param {Object} fieldOption
     * @returns {Object} {value, onChange}
     */
  }, {
    key: "init",
    value: function init(name) {
      var _this3 = this;
      var fieldOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rprops = arguments.length > 2 ? arguments[2] : undefined;
      var id = fieldOption.id,
        initValue = fieldOption.initValue,
        _fieldOption$valueNam = fieldOption.valueName,
        valueName = _fieldOption$valueNam === void 0 ? 'value' : _fieldOption$valueNam,
        _fieldOption$trigger = fieldOption.trigger,
        trigger = _fieldOption$trigger === void 0 ? 'onChange' : _fieldOption$trigger,
        _fieldOption$rules = fieldOption.rules,
        rules = _fieldOption$rules === void 0 ? [] : _fieldOption$rules,
        _fieldOption$props = fieldOption.props,
        props = _fieldOption$props === void 0 ? {} : _fieldOption$props,
        _fieldOption$getValue = fieldOption.getValueFromEvent,
        getValueFromEvent = _fieldOption$getValue === void 0 ? null : _fieldOption$getValue,
        _fieldOption$getValue2 = fieldOption.getValueFormatter,
        getValueFormatter = _fieldOption$getValue2 === void 0 ? getValueFromEvent : _fieldOption$getValue2,
        setValueFormatter = fieldOption.setValueFormatter,
        _fieldOption$autoVali = fieldOption.autoValidate,
        autoValidate = _fieldOption$autoVali === void 0 ? true : _fieldOption$autoVali,
        reRender = fieldOption.reRender;
      var parseName = this.options.parseName;
      if (getValueFromEvent) {
        (0, _utils.warning)('`getValueFromEvent` has been deprecated in `Field`, use `getValueFormatter` instead of it');
      }
      var originalProps = (0, _extends2.default)({}, props, rprops);
      var defaultValueName = "default".concat(valueName[0].toUpperCase()).concat(valueName.slice(1));
      var defaultValue;
      if (typeof initValue !== 'undefined') {
        defaultValue = initValue;
      } else if (typeof originalProps[defaultValueName] !== 'undefined') {
        // here use typeof, in case of defaultValue={0}
        defaultValue = originalProps[defaultValueName];
      }

      // get field from this.fieldsMeta or new one
      var field = this._getInitMeta(name);
      (0, _extends2.default)(field, {
        valueName: valueName,
        initValue: defaultValue,
        disabled: 'disabled' in originalProps ? originalProps.disabled : false,
        getValueFormatter: getValueFormatter,
        setValueFormatter: setValueFormatter,
        rules: (0, _utils.cloneToRuleArr)(rules),
        ref: originalProps.ref
      });
      var oldValue = field.value;

      // Controlled Component, should always equal props.value
      if (valueName in originalProps) {
        var originalValue = originalProps[valueName];

        // When rerendering set the values from props.value
        if (parseName) {
          // when parseName is true, field should not store value locally. To prevent sync issues
          if (!('value' in field)) {
            this._proxyFieldValue(field);
          }
        } else {
          this.values[name] = originalValue;
        }
        field.value = originalValue;
      }

      /**
       * first init field (value not in field)
       * should get field.value from this.values or defaultValue
       */
      if (!('value' in field)) {
        if (parseName) {
          var cachedValue = (0, _utils.getIn)(this.values, name);
          if (typeof cachedValue !== 'undefined') {
            oldValue = cachedValue;
          }
          var _initValue = typeof cachedValue !== 'undefined' ? cachedValue : defaultValue;
          // when parseName is true, field should not store value locally. To prevent sync issues
          this._proxyFieldValue(field);
          field.value = _initValue;
        } else {
          var _cachedValue = this.values[name];
          if (typeof _cachedValue !== 'undefined') {
            field.value = _cachedValue;
            oldValue = _cachedValue;
          } else if (typeof defaultValue !== 'undefined') {
            // should be same with parseName, but compatible with old versions
            field.value = defaultValue;
            this.values[name] = field.value;
          }
        }
      }

      // field value init end
      var newValue = field.value;
      this._triggerFieldChange(name, newValue, oldValue, 'init');

      // Component props
      var inputProps = (0, _defineProperty2.default)({
        'data-meta': 'Field',
        id: id || name,
        ref: this._getCacheBind(name, "".concat(name, "__ref"), this._saveRef)
      }, valueName, setValueFormatter ? setValueFormatter(field.value, field.inputValues) : field.value);
      var rulesMap = {};
      if (this.options.autoValidate && autoValidate !== false) {
        // trigger map in rules,
        rulesMap = (0, _utils.mapValidateRules)(field.rules, trigger);

        // step1 : validate hooks
        var _loop = function _loop(action) {
          // skip default trigger, which will trigger in step2
          if (action === trigger) {
            return 1; // continue
          }
          var actionRule = rulesMap[action];
          inputProps[action] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            _this3._callNativePropsEvent.apply(_this3, [action, originalProps].concat(args));
            _this3._validate(name, actionRule, action);
          };
        };
        for (var action in rulesMap) {
          if (_loop(action)) continue;
        }
      }

      // step2: onChange(trigger=onChange by default) hack
      inputProps[trigger] = function () {
        var oldValue = _this3.getValue(name);
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        _this3._updateFieldValue.apply(_this3, [name].concat(args));
        var newValue = _this3.getValue(name);
        _this3._triggerFieldChange(name, newValue, oldValue, 'change');

        // clear validate error
        _this3._resetError(name);
        _this3._callNativePropsEvent.apply(_this3, [trigger, originalProps].concat(args));
        // call global onChange
        _this3.options.onChange(name, field.value);

        // validate while onChange
        var rule = rulesMap[trigger];
        rule && _this3._validate(name, rule, trigger);
        _this3._reRender(name, trigger);
      };

      // step3: save reRender function
      if (reRender && typeof reRender === 'function') {
        this.reRenders[name] = reRender;
      }
      delete originalProps[defaultValueName];
      return (0, _extends2.default)({}, originalProps, inputProps);
    }

    /**
     * call native event from props.onXx
     * eg: props.onChange props.onBlur props.onFocus
     */
  }, {
    key: "_callNativePropsEvent",
    value: function _callNativePropsEvent(action, props) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }
      action in props && typeof props[action] === 'function' && props[action].apply(props, args);
    }
  }, {
    key: "_getInitMeta",
    value: function _getInitMeta(name) {
      if (!(name in this.fieldsMeta)) {
        this.fieldsMeta[name] = (0, _extends2.default)({
          name: name
        }, initMeta);
      }
      return this.fieldsMeta[name];
    }
  }, {
    key: "_proxyFieldValue",
    value: function _proxyFieldValue(field) {
      var _this = this;
      Object.defineProperty(field, 'value', {
        configurable: true,
        enumerable: true,
        get: function get() {
          return (0, _utils.getIn)(_this.values, this.name);
        },
        set: function set(v) {
          // 此处this解释同上
          _this.values = (0, _utils.setIn)(_this.values, this.name, v);
          return true;
        }
      });
    }

    /**
     * update field.value and validate
     */
  }, {
    key: "_updateFieldValue",
    value: function _updateFieldValue(name) {
      for (var _len4 = arguments.length, others = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        others[_key4 - 1] = arguments[_key4];
      }
      var e = others[0];
      var field = this._get(name);
      if (!field) {
        return;
      }
      field.value = field.getValueFormatter ? field.getValueFormatter.apply(this, others) : (0, _utils.getValueFromEvent)(e);
      field.inputValues = others;
      if (this.options.parseName) {
        this.values = (0, _utils.setIn)(this.values, name, field.value);
      } else {
        this.values[name] = field.value;
      }
    }

    /**
     * ref must always be the same function, or if not it will be triggerd every time.
     * @param {String} name name of component
     * @param {String} action key to find ref
     * @param {Function} fn saveRef
     */
  }, {
    key: "_getCacheBind",
    value: function _getCacheBind(name, action, fn) {
      var cache = this.cachedBind[name] = this.cachedBind[name] || {};
      if (!cache[action]) {
        cache[action] = fn.bind(this, name);
      }
      return cache[action];
    }
  }, {
    key: "_setCache",
    value: function _setCache(name, action, hander) {
      var cache = this.cachedBind[name] = this.cachedBind[name] || {};
      cache[action] = hander;
    }
  }, {
    key: "_getCache",
    value: function _getCache(name, action) {
      var cache = this.cachedBind[name] || {};
      return cache[action];
    }

    /**
     * NOTE: saveRef is async function. it will be called after render
     * @param {String} name name of component
     * @param {Function} component ref
     */
  }, {
    key: "_saveRef",
    value: function _saveRef(name, component) {
      var key = "".concat(name, "_field");
      var autoUnmount = this.options.autoUnmount;
      if (!component && autoUnmount) {
        // more than one component, do nothing
        this.instanceCount[name] && this.instanceCount[name]--;
        if (this.instanceCount[name] > 0) {
          return;
        }

        // component with same name (eg: type ? <A name="n"/>:<B name="n"/>)
        // while type changed, B will render before A unmount. so we should cached value for B
        // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render
        // 1. _saveRef(A, null)
        var cache = this.fieldsMeta[name];
        if (cache) {
          if (this.options.parseName) {
            // 若parseName模式下，因为value为getter、setter，所以将当前值记录到_value内
            cache._value = cache.value;
          }
          this._setCache(name, key, cache);
        }

        // after destroy, delete data
        delete this.instance[name];
        delete this.reRenders[name];
        var oldValue = this.getValue(name);
        this.remove(name);
        var newValue = this.getValue(name);
        this._triggerFieldChange(name, newValue, oldValue, 'unmount');
        return;
      }

      // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)
      if (autoUnmount && !this.fieldsMeta[name] && this._getCache(name, key)) {
        var _cache = this._getCache(name, key);
        this.fieldsMeta[name] = _cache;
        // 若parseName模式，则使用_value作为值设置到values内
        this.setValue(name, this.options.parseName ? _cache._value : _cache.value, false, false);
        this.options.parseName && '_value' in _cache && delete _cache._value;
      }

      // only one time here
      var field = this._get(name);
      if (field) {
        //When the autoUnmount is false, the component uninstallation needs to clear the verification information to avoid blocking the validation.
        if (!component && !autoUnmount) {
          field.state = '';
          delete field.errors;
          delete field.rules;
          delete field.rulesMap;
        }
        var ref = field.ref;
        if (ref) {
          if (typeof ref === 'string') {
            throw new Error("can not set string ref for ".concat(name));
          } else if (typeof ref === 'function') {
            ref(component);
          } else if ((0, _typeof2.default)(ref) === 'object' && 'current' in ref) {
            // while ref = React.createRef() ref={ current: null}
            ref.current = component;
          }
        }

        // mount
        if (autoUnmount && component) {
          var cnt = this.instanceCount[name];
          if (!cnt) {
            cnt = 0;
          }
          this.instanceCount[name] = cnt + 1;
        }
        this.instance[name] = component;
      }
    }

    /**
     * validate one Component
     * @param {String} name name of Component
     * @param {Array} rule
     * @param {String} trigger onChange/onBlur/onItemClick/...
     */
  }, {
    key: "_validate",
    value: function _validate(name, rule, trigger) {
      var _this4 = this;
      var field = this._get(name);
      if (!field) {
        return;
      }
      var value = field.value;
      field.state = 'loading';
      var validate = this._getCache(name, trigger);
      if (validate && typeof validate.abort === 'function') {
        validate.abort();
      }
      validate = new _validate2.default((0, _defineProperty2.default)({}, name, rule), {
        messages: this.options.messages
      });
      this._setCache(name, trigger, validate);
      validate.validate((0, _defineProperty2.default)({}, name, value), function (errors) {
        var newErrors, newState;
        if (errors && errors.length) {
          newErrors = (0, _utils.getErrorStrs)(errors, _this4.processErrorMessage);
          newState = 'error';
        } else {
          newErrors = [];
          newState = 'success';
        }
        var reRender = false;
        // only status or errors changed, Rerender
        if (newState !== field.state || !field.errors || newErrors.length !== field.errors.length || newErrors.find(function (e, idx) {
          return e !== field.errors[idx];
        })) {
          reRender = true;
        }
        field.errors = newErrors;
        field.state = newState;
        reRender && _this4._reRender(name, 'validate');
      });
    }
  }, {
    key: "getValue",
    value: function getValue(name) {
      if (this.options.parseName) {
        return (0, _utils.getIn)(this.values, name);
      }
      return this.values[name];
    }

    /**
     * 1. get values by names.
     * 2. If no names passed, return shallow copy of `field.values`
     * @param {Array} names
     */
  }, {
    key: "getValues",
    value: function getValues(names) {
      var _this5 = this;
      var allValues = {};
      if (names && names.length) {
        names.forEach(function (name) {
          allValues[name] = _this5.getValue(name);
        });
      } else {
        (0, _extends2.default)(allValues, this.values);
      }
      return allValues;
    }
  }, {
    key: "setValue",
    value: function setValue(name, value) {
      var reRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var triggerChange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var oldValue = this.getValue(name);
      if (name in this.fieldsMeta) {
        this.fieldsMeta[name].value = value;
      }
      if (this.options.parseName) {
        this.values = (0, _utils.setIn)(this.values, name, value);
      } else {
        this.values[name] = value;
      }
      var newValue = this.getValue(name);
      if (triggerChange) {
        this._triggerFieldChange(name, newValue, oldValue, 'setValue');
      }
      reRender && this._reRender(name, 'setValue');
    }
  }, {
    key: "setValues",
    value: function setValues() {
      var _this6 = this;
      var fieldsValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var reRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (!this.options.parseName) {
        Object.keys(fieldsValue).forEach(function (name) {
          _this6.setValue(name, fieldsValue[name], false, true);
        });
      } else {
        // NOTE: this is a shallow merge
        // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}
        // fieldsMeta[name].value is proxy from this.values[name] when parseName is true, so there is no need to assign value to fieldMeta
        // shallow merge
        var newValues = (0, _extends2.default)({}, this.values, fieldsValue);
        var fields = this.getNames();
        var allOldFieldValues = this.getValues(fields);
        // record all old field values, exclude items overwritten by fieldsValue
        var oldFieldValues = fields.filter(function (name) {
          return !(0, _utils.isOverwritten)(fieldsValue, name);
        }).map(function (name) {
          return {
            name: name,
            value: _this6.fieldsMeta[name].value
          };
        });
        // assign lost field value to newValues
        oldFieldValues.forEach(function (_ref) {
          var name = _ref.name,
            value = _ref.value;
          if (!(0, _utils.hasIn)(newValues, name)) {
            newValues = (0, _utils.setIn)(newValues, name, value);
          }
        });
        // store the new values
        this.values = newValues;

        // trigger changes after update
        var _iterator = _createForOfIteratorHelper(fields),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var name = _step.value;
            this._triggerFieldChange(name, this.getValue(name), allOldFieldValues[name], 'setValue');
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      reRender && this._reRender();
    }
  }, {
    key: "setError",
    value: function setError(name, errors) {
      var err = Array.isArray(errors) ? errors : errors ? [errors] : [];
      if (name in this.fieldsMeta) {
        this.fieldsMeta[name].errors = err;
      } else {
        this.fieldsMeta[name] = {
          errors: err
        };
      }
      if (this.fieldsMeta[name].errors && this.fieldsMeta[name].errors.length > 0) {
        this.fieldsMeta[name].state = 'error';
      } else {
        this.fieldsMeta[name].state = '';
      }
      this._reRender(name, 'setError');
    }
  }, {
    key: "setErrors",
    value: function setErrors() {
      var _this7 = this;
      var fieldsErrors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.keys(fieldsErrors).forEach(function (name) {
        _this7.setError(name, fieldsErrors[name]);
      });
    }
  }, {
    key: "getError",
    value: function getError(name) {
      var field = this._get(name);
      if (field && field.errors && field.errors.length) {
        return field.errors;
      }
      return null;
    }
  }, {
    key: "getErrors",
    value: function getErrors(names) {
      var _this8 = this;
      var fields = names || this.getNames();
      var allErrors = {};
      fields.forEach(function (f) {
        allErrors[f] = _this8.getError(f);
      });
      return allErrors;
    }
  }, {
    key: "getState",
    value: function getState(name) {
      var field = this._get(name);
      if (field && field.state) {
        return field.state;
      }
      return '';
    }

    /**
     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate
     * @param {Array} fieldNames
     * @return {Object || null} map of inputs and their errors
     */
  }, {
    key: "formatGetErrors",
    value: function formatGetErrors(fieldNames) {
      var errors = this.getErrors(fieldNames);
      var formattedErrors = null;
      for (var field in errors) {
        if (errors.hasOwnProperty(field) && errors[field]) {
          var errorsObj = errors[field];
          if (!formattedErrors) {
            formattedErrors = {};
          }
          formattedErrors[field] = {
            errors: errorsObj
          };
        }
      }
      return formattedErrors;
    }

    /**
     * validate by trigger
     * @param {Array} ns names
     * @param {Function} cb callback after validate
     */
  }, {
    key: "validateCallback",
    value: function validateCallback(ns, cb) {
      var _this9 = this;
      var _getParams = (0, _utils.getParams)(ns, cb),
        names = _getParams.names,
        callback = _getParams.callback;
      var fieldNames = names || this.getNames();
      var descriptor = {};
      var values = {};
      var hasRule = false;
      for (var i = 0; i < fieldNames.length; i++) {
        var name = fieldNames[i];
        var field = this._get(name);
        if (!field) {
          continue;
        }
        if (field.rules && field.rules.length) {
          descriptor[name] = field.rules;
          values[name] = this.getValue(name);
          hasRule = true;

          // clear error
          field.errors = [];
          field.state = '';
        }
      }
      if (!hasRule) {
        var errors = this.formatGetErrors(fieldNames);
        callback && callback(errors, this.getValues(names ? fieldNames : []));
        return;
      }
      var validate = new _validate2.default(descriptor, {
        first: this.options.first,
        messages: this.options.messages
      });
      validate.validate(values, function (errors) {
        var errorsGroup = null;
        if (errors && errors.length) {
          errorsGroup = {};
          errors.forEach(function (e) {
            var fieldName = e.field;
            if (!errorsGroup[fieldName]) {
              errorsGroup[fieldName] = {
                errors: []
              };
            }
            var fieldErrors = errorsGroup[fieldName].errors;
            fieldErrors.push(e.message);
          });
        }
        if (errorsGroup) {
          // update error in every Field
          Object.keys(errorsGroup).forEach(function (i) {
            var field = _this9._get(i);
            if (field) {
              field.errors = (0, _utils.getErrorStrs)(errorsGroup[i].errors, _this9.processErrorMessage);
              field.state = 'error';
            }
          });
        }
        var formattedGetErrors = _this9.formatGetErrors(fieldNames);
        if (formattedGetErrors) {
          errorsGroup = (0, _extends2.default)({}, formattedGetErrors, errorsGroup);
        }

        // update to success which has no error
        for (var _i = 0; _i < fieldNames.length; _i++) {
          var _name = fieldNames[_i];
          var _field = _this9._get(_name);
          if (_field && _field.rules && !(errorsGroup && _name in errorsGroup)) {
            _field.state = 'success';
          }
        }

        // eslint-disable-next-line callback-return
        callback && callback(errorsGroup, _this9.getValues(names ? fieldNames : []));
        _this9._reRender(names, 'validate');
        if (typeof _this9.afterValidateRerender === 'function') {
          _this9.afterValidateRerender({
            errorsGroup: errorsGroup,
            options: _this9.options,
            instance: _this9.instance
          });
        }
      });
    }

    /**
     * validate by trigger - Promise version
     * NOTES:
     * - `afterValidateRerender` is not called in `validatePromise`. The rerender is called just before this function
     *      returns a promise, so use the returned promise to call any after rerender logic.
     *
     * @param {Array} ns names
     * @param {Function} cb (Optional) callback after validate, must return a promise or a value
     *                  - ({errors, values}) => Promise({errors, values}) | {errors, values}
     * @returns {Promise} - resolves with {errors, values}
     */
  }, {
    key: "validatePromise",
    value: function () {
      var _validatePromise = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(ns, cb) {
        var _getParams2, names, callback, fieldNames, descriptor, values, hasRule, i, name, field, _errors, validate, results, errors, errorsGroup, callbackResults;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _getParams2 = (0, _utils.getParams)(ns, cb), names = _getParams2.names, callback = _getParams2.callback;
              fieldNames = names || this.getNames();
              descriptor = {};
              values = {};
              hasRule = false;
              i = 0;
            case 6:
              if (!(i < fieldNames.length)) {
                _context.next = 15;
                break;
              }
              name = fieldNames[i];
              field = this._get(name);
              if (field) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("continue", 12);
            case 11:
              if (field.rules && field.rules.length) {
                descriptor[name] = field.rules;
                values[name] = this.getValue(name);
                hasRule = true;

                // clear error
                field.errors = [];
                field.state = '';
              }
            case 12:
              i++;
              _context.next = 6;
              break;
            case 15:
              if (hasRule) {
                _context.next = 22;
                break;
              }
              _errors = this.formatGetErrors(fieldNames);
              if (!callback) {
                _context.next = 21;
                break;
              }
              return _context.abrupt("return", callback({
                errors: _errors,
                values: this.getValues(names ? fieldNames : [])
              }));
            case 21:
              return _context.abrupt("return", {
                errors: _errors,
                values: this.getValues(names ? fieldNames : [])
              });
            case 22:
              validate = new _validate2.default(descriptor, {
                first: this.options.first,
                messages: this.options.messages
              });
              _context.next = 25;
              return validate.validatePromise(values);
            case 25:
              results = _context.sent;
              errors = results && results.errors || [];
              errorsGroup = this._getErrorsGroup({
                errors: errors,
                fieldNames: fieldNames
              });
              callbackResults = {
                errors: errorsGroup,
                values: this.getValues(names ? fieldNames : [])
              };
              _context.prev = 29;
              if (!callback) {
                _context.next = 34;
                break;
              }
              _context.next = 33;
              return callback(callbackResults);
            case 33:
              callbackResults = _context.sent;
            case 34:
              _context.next = 39;
              break;
            case 36:
              _context.prev = 36;
              _context.t0 = _context["catch"](29);
              return _context.abrupt("return", _context.t0);
            case 39:
              this._reRender(names, 'validate');
              return _context.abrupt("return", callbackResults);
            case 41:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[29, 36]]);
      }));
      function validatePromise(_x, _x2) {
        return _validatePromise.apply(this, arguments);
      }
      return validatePromise;
    }()
  }, {
    key: "_getErrorsGroup",
    value: function _getErrorsGroup(_ref2) {
      var _this10 = this;
      var errors = _ref2.errors,
        fieldNames = _ref2.fieldNames;
      var errorsGroup = null;
      if (errors && errors.length) {
        errorsGroup = {};
        errors.forEach(function (e) {
          var fieldName = e.field;
          if (!errorsGroup[fieldName]) {
            errorsGroup[fieldName] = {
              errors: []
            };
          }
          var fieldErrors = errorsGroup[fieldName].errors;
          fieldErrors.push(e.message);
        });
      }
      if (errorsGroup) {
        // update error in every Field
        Object.keys(errorsGroup).forEach(function (i) {
          var field = _this10._get(i);
          if (field) {
            field.errors = (0, _utils.getErrorStrs)(errorsGroup[i].errors, _this10.processErrorMessage);
            field.state = 'error';
          }
        });
      }
      var formattedGetErrors = this.formatGetErrors(fieldNames);
      if (formattedGetErrors) {
        errorsGroup = (0, _extends2.default)({}, formattedGetErrors, errorsGroup);
      }

      // update to success which has no error
      for (var i = 0; i < fieldNames.length; i++) {
        var name = fieldNames[i];
        var field = this._get(name);
        if (field && field.rules && !(errorsGroup && name in errorsGroup)) {
          field.state = 'success';
        }
      }
      return errorsGroup;
    }
  }, {
    key: "_reset",
    value: function _reset(ns, backToDefault) {
      var _this11 = this;
      if (typeof ns === 'string') {
        ns = [ns];
      }
      var changed = false;
      var names = ns || Object.keys(this.fieldsMeta);
      var oldValues = this.getValues(names);
      if (!ns) {
        this.values = {};
      }
      names.forEach(function (name) {
        var field = _this11._get(name);
        if (field) {
          changed = true;
          field.value = backToDefault ? field.initValue : undefined;
          field.state = '';
          delete field.errors;
          delete field.rules;
          delete field.rulesMap;
          if (_this11.options.parseName) {
            _this11.values = (0, _utils.setIn)(_this11.values, name, field.value);
          } else {
            _this11.values[name] = field.value;
          }
        }
        _this11._triggerFieldChange(name, _this11.getValue(name), oldValues[name], 'reset');
      });
      if (changed) {
        this._reRender(names, 'reset');
      }
    }
  }, {
    key: "reset",
    value: function reset(ns) {
      this._reset(ns, false);
    }
  }, {
    key: "resetToDefault",
    value: function resetToDefault(ns) {
      this._reset(ns, true);
    }
  }, {
    key: "getNames",
    value: function getNames() {
      var fieldsMeta = this.fieldsMeta;
      return Object.keys(fieldsMeta).filter(function () {
        return true;
      });
    }
  }, {
    key: "remove",
    value: function remove(ns) {
      var _this12 = this;
      if (typeof ns === 'string') {
        ns = [ns];
      }
      if (!ns) {
        this.values = {};
      }
      var names = ns || Object.keys(this.fieldsMeta);
      names.forEach(function (name) {
        if (name in _this12.fieldsMeta) {
          delete _this12.fieldsMeta[name];
        }
        if (_this12.options.parseName) {
          _this12.values = (0, _utils.deleteIn)(_this12.values, name);
        } else {
          delete _this12.values[name];
        }
      });
    }
  }, {
    key: "addArrayValue",
    value: function addArrayValue(key, index) {
      for (var _len5 = arguments.length, argv = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
        argv[_key5 - 2] = arguments[_key5];
      }
      return this._spliceArrayValue.apply(this, [key, index, 0].concat(argv));
    }
  }, {
    key: "deleteArrayValue",
    value: function deleteArrayValue(key, index) {
      var howmany = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return this._spliceArrayValue(key, index, howmany);
    }

    /**
     * splice array
     * @param {String} key
     * @param {Number} startIndex
     * @param {Number} howmany
     * @param {Array} argv
     * @param {*} value
     */
  }, {
    key: "_spliceArrayValue",
    value: function _spliceArrayValue(key, index, howmany) {
      var _this13 = this;
      for (var _len6 = arguments.length, argv = new Array(_len6 > 3 ? _len6 - 3 : 0), _key6 = 3; _key6 < _len6; _key6++) {
        argv[_key6 - 3] = arguments[_key6];
      }
      var argc = argv.length;
      var offset = howmany - argc; // how the reset fieldMeta move
      var startIndex = index + howmany; // 计算起点

      /**
       * eg: call _spliceArrayValue('key', 1) to delete 'key.1':
       *   case 1: names=['key.0', 'key.1']; delete 'key.1';
       *   case 2: names=['key.0', 'key.1', 'key.2']; key.1= key.2; delete key.2;
       *   case 3: names=['key.0.name', 'key.0.email', 'key.1.name', 'key.1.email'], should delete 'key.1.name', 'key.1.email'
       * eg: call _spliceArrayValue('key', 1, item) to add 'key.1':
       *   case 1: names=['key.0']; add 'key.1' = item;
       *   case 2: names=['key.0', 'key.1']; key.2= key.1; delete key.1; add key.1 = item;
       */
      var listMap = {}; // eg: {1:[{from: 'key.2.name', to: 'key.1.name'}, {from: 'key.2.email', to: 'key.1.email'}]}
      var replacedReg = /\$/g;
      // 替换特殊字符$
      var replacedKey = key.replace(replacedReg, '\\$&');
      var keyReg = new RegExp("^(".concat(replacedKey, ".)(\\d+)"));
      var replaceArgv = [];
      var names = this.getNames();
      var willChangeNames = [];

      // logic of offset fix begin
      names.forEach(function (n) {
        var ret = keyReg.exec(n);
        if (ret) {
          var idx = parseInt(ret[2]); // get index of 'key.0.name'

          if (idx >= startIndex) {
            var l = listMap[idx];
            var item = {
              from: n,
              to: n.replace(keyReg, function (match, p1) {
                return "".concat(p1).concat(idx - offset);
              })
            };
            willChangeNames.push(item.from);
            if (names.includes(item.to)) {
              willChangeNames.push(item.to);
            }
            if (!l) {
              listMap[idx] = [item];
            } else {
              l.push(item);
            }
          }

          // in case of offsetList.length = 0, eg: delete last element
          if (offset > 0 && idx >= index && idx < index + howmany) {
            replaceArgv.push(n);
          }
        }
      });
      var oldValues = this.getValues(willChangeNames);

      // sort with index eg: [{index:1, list: [{from: 'key.2.name', to: 'key.1.name'}]}, {index:2, list: [...]}]
      var offsetList = Object.keys(listMap).map(function (i) {
        return {
          index: Number(i),
          list: listMap[i]
        };
      }).sort(function (a, b) {
        return offset > 0 ? a.index - b.index : b.index - a.index;
      });
      offsetList.forEach(function (l) {
        var list = l.list;
        list.forEach(function (i) {
          _this13.fieldsMeta[i.to] = _this13.fieldsMeta[i.from];
          // 移位后，同步调整name
          _this13.fieldsMeta[i.to].name = i.to;
        });
      });

      // delete copy data
      if (offsetList.length > 0) {
        var removeList = offsetList.slice(offsetList.length - (offset < 0 ? -offset : offset), offsetList.length);
        removeList.forEach(function (item) {
          item.list.forEach(function (i) {
            delete _this13.fieldsMeta[i.from];
          });
        });
      } else {
        // will get from this.values while rerender
        replaceArgv.forEach(function (i) {
          delete _this13.fieldsMeta[i];
        });
      }
      var p = this.getValue(key);
      if (p) {
        p.splice.apply(p, [index, howmany].concat(argv));
      }
      for (var _i2 = 0, _willChangeNames = willChangeNames; _i2 < _willChangeNames.length; _i2++) {
        var name = _willChangeNames[_i2];
        this._triggerFieldChange(name, this.getValue(name), oldValues[name], 'setValue');
      }
      this._reRender();
    }

    /**
     * splice in a Array [deprecated]
     * @param {String} keyMatch like name.{index}
     * @param {Number} startIndex index
     */
  }, {
    key: "spliceArray",
    value: function spliceArray(keyMatch, startIndex, howmany) {
      var _this14 = this;
      if (keyMatch.match(/{index}$/) === -1) {
        (0, _utils.warning)('key should match /{index}$/');
        return;
      }

      // regex to match field names in the same target array
      var reg = keyMatch.replace('{index}', '(\\d+)');
      var keyReg = new RegExp("^".concat(reg));
      var listMap = {};
      /**
       * keyMatch='key.{index}'
       * case 1: names=['key.0', 'key.1'], should delete 'key.1'
       * case 2: names=['key.0.name', 'key.0.email', 'key.1.name', 'key.1.email'], should delete 'key.1.name', 'key.1.email'
       */
      var names = this.getNames();
      var willChangeNames = [];
      names.forEach(function (n) {
        // is name in the target array?
        var ret = keyReg.exec(n);
        if (ret) {
          var index = parseInt(ret[1]);
          if (index > startIndex) {
            var l = listMap[index];
            var item = {
              from: n,
              to: "".concat(keyMatch.replace('{index}', index - 1)).concat(n.replace(ret[0], ''))
            };
            willChangeNames.push(item.from);
            if (names.includes(item.to)) {
              willChangeNames.push(item.to);
            }
            if (!l) {
              listMap[index] = [item];
            } else {
              l.push(item);
            }
          }
        }
      });
      var oldValues = this.getValues(willChangeNames);
      var idxList = Object.keys(listMap).map(function (i) {
        return {
          index: Number(i),
          list: listMap[i]
        };
      }).sort(function (a, b) {
        return a.index < b.index;
      });

      // should be continuous array
      if (idxList.length > 0 && idxList[0].index === startIndex + 1) {
        idxList.forEach(function (l) {
          var list = l.list;
          list.forEach(function (i) {
            var v = _this14.getValue(i.from); // get index value
            _this14.setValue(i.to, v, false, false); // set value to index - 1
          });
        });

        var lastIdxList = idxList[idxList.length - 1];
        lastIdxList.list.forEach(function (i) {
          _this14.remove(i.from);
        });
        var parentName = keyMatch.replace('.{index}', '');
        parentName = parentName.replace('[{index}]', '');
        var parent = this.getValue(parentName);
        if (parent) {
          // if parseName=true then parent is an Array object but does not know an element was removed
          // this manually decrements the array length
          parent.length--;
        }
      }
      for (var _i3 = 0, _willChangeNames2 = willChangeNames; _i3 < _willChangeNames2.length; _i3++) {
        var name = _willChangeNames2[_i3];
        this._triggerFieldChange(name, this.getValue(name), oldValues[name], 'setValue');
      }
    }
  }, {
    key: "_resetError",
    value: function _resetError(name) {
      var field = this._get(name);
      if (field) {
        delete field.errors; //清空错误
        field.state = '';
      }
    }

    //trigger rerender
  }, {
    key: "_reRender",
    value: function _reRender(name, action) {
      var _this15 = this;
      // 指定了字段列表且字段存在对应的自定义渲染函数
      if (name) {
        var names = Array.isArray(name) ? name : [name];
        if (names.length && names.every(function (n) {
          return _this15.reRenders[n];
        })) {
          names.forEach(function (n) {
            var reRender = _this15.reRenders[n];
            reRender(action);
          });
          return;
        }
      }
      if (this.com) {
        if (!this.options.forceUpdate && this.com.setState) {
          this.com.setState({});
        } else if (this.com.forceUpdate) {
          this.com.forceUpdate(); //forceUpdate 对性能有较大的影响，成指数上升
        }
      }
    }
  }, {
    key: "_get",
    value: function _get(name) {
      return name in this.fieldsMeta ? this.fieldsMeta[name] : null;
    }
  }, {
    key: "get",
    value: function get(name) {
      if (name) {
        return this._get(name);
      } else {
        return this.fieldsMeta;
      }
    }

    /**
     *
     * @param {string} name
     * @param {*} value
     * @param {*} oldValue
     * @param {'init' | 'change' | 'setValue' | 'unmount' | 'reset'} triggerType
     */
  }, {
    key: "_triggerFieldChange",
    value: function _triggerFieldChange(name, value, oldValue, triggerType) {
      // same value should not trigger change
      if (Object.is(value, oldValue)) {
        return;
      }
      var listenerSet = this.listeners[name];
      if (!(listenerSet !== null && listenerSet !== void 0 && listenerSet.size)) {
        return;
      }
      var _iterator2 = _createForOfIteratorHelper(listenerSet),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var callback = _step2.value;
          callback(name, value, oldValue, triggerType);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    /**
     * 监听字段值变化
     * @param {string[]} names 监听的name列表
     * @param {Function} callback 变化回调
     * @returns {Function} 解除监听回调
     */
  }, {
    key: "watch",
    value: function watch(names, callback) {
      var _this16 = this;
      var _iterator3 = _createForOfIteratorHelper(names),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var name = _step3.value;
          if (!this.listeners[name]) {
            this.listeners[name] = new Set();
          }
          var set = this.listeners[name];
          set.add(callback);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return function () {
        var _iterator4 = _createForOfIteratorHelper(names),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var name = _step4.value;
            if (_this16.listeners[name]) {
              _this16.listeners[name].delete(callback);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      };
    }
  }], [{
    key: "create",
    value: function create(com) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new this(com, options);
    }
  }, {
    key: "getUseField",
    value: function getUseField(_ref3) {
      var _this17 = this;
      var useState = _ref3.useState,
        useMemo = _ref3.useMemo;
      return function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _useState = useState(),
          _useState2 = (0, _slicedToArray2.default)(_useState, 2),
          setState = _useState2[1];
        var field = useMemo(function () {
          return _this17.create({
            setState: setState
          }, options);
        }, [setState]);
        return field;
      };
    }
  }]);
  return Field;
}();
var _default = exports.default = Field;