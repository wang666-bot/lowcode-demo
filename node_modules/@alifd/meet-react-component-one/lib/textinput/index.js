"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _react = _interopRequireWildcard(require("react"));
var _universalEnv = require("universal-env");
require("./index.css");
var _keyboardTypeMap = _interopRequireDefault(require("./keyboardTypeMap"));
var _setNativeProps = _interopRequireDefault(require("./setNativeProps"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var inputId = 0;
function getText(event) {
  var text = '';
  if (_universalEnv.isWeex) {
    text = event.value;
  } else {
    text = event.target.value;
  }
  return text;
}
function genEventObject(event) {
  var text = getText(event);
  return {
    nativeEvent: {
      text: text
    },
    originalEvent: event,
    value: text,
    target: event.target
  };
}
function isControlled(props) {
  return 'value' in props;
}
var TextInput = /*#__PURE__*/(0, _react.forwardRef)(function (props, ref) {
  var refEl = (0, _react.useRef)(null);
  var styleCls = (0, _react.useRef)("one-textinput-placeholder-".concat(inputId++));
  var composition = (0, _react.useRef)(false);
  var _useState = (0, _react.useState)(0),
    _useState2 = _slicedToArray(_useState, 2),
    forceUpdate = _useState2[1];
  var className = props.className,
    accessibilityLabel = props.accessibilityLabel,
    autoComplete = props.autoComplete,
    editable = props.editable,
    keyboardType = props.keyboardType,
    maxNumberOfLines = props.maxNumberOfLines,
    maxLength = props.maxLength,
    multiline = props.multiline,
    numberOfLines = props.numberOfLines,
    confirmType = props.confirmType,
    randomNumber = props.randomNumber,
    _props$showCount = props.showCount,
    showCount = _props$showCount === void 0 ? true : _props$showCount,
    selectionStart = props.selectionStart,
    selectionEnd = props.selectionEnd,
    _props$composition = props.composition,
    compositionProp = _props$composition === void 0 ? false : _props$composition,
    onCompositionStart = props.onCompositionStart,
    onCompositionEnd = props.onCompositionEnd,
    onBlur = props.onBlur,
    onFocus = props.onFocus,
    onChange = props.onChange,
    onChangeText = props.onChangeText,
    _onInput = props.onInput,
    password = props.password,
    secureTextEntry = props.secureTextEntry,
    style = props.style,
    _props$placeholderCol = props.placeholderColor,
    placeholderColor = _props$placeholderCol === void 0 ? '#999999' : _props$placeholderCol,
    value = props.value,
    defaultValue = props.defaultValue,
    _props$controlled = props.controlled,
    controlled = _props$controlled === void 0 ? isControlled(props) : _props$controlled;
  var _useState3 = (0, _react.useState)(controlled ? value : defaultValue),
    _useState4 = _slicedToArray(_useState3, 2),
    stateValue = _useState4[0],
    setStateValue = _useState4[1];
  var type = password || secureTextEntry ? 'password' : typeof _keyboardTypeMap["default"][keyboardType] === 'undefined' ? keyboardType : _keyboardTypeMap["default"][keyboardType];
  if (_universalEnv.isMiniApp && !_universalEnv.isWeb) {
    if (!['text', 'number', 'idcard', 'digit'].includes(type) && !my.canIUse("input.type.".concat(type))) {
      type = 'text';
    }
  }
  var setValue = function () {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    (0, _setNativeProps["default"])(refEl.current, {
      value: value
    });
  };
  var triggerChange = function (event) {
    if (onChange) onChange(genEventObject(event));
    if (onChangeText) onChangeText(getText(event));
  };
  var handleInput = function (event) {
    _onInput(genEventObject(event));
  };
  var handleChange = function (event) {
    setStateValue(getText(event));
    if (composition.current) {
      return;
    }
    triggerChange(event);
  };
  var propsCommon = Object.assign(Object.assign({}, props), {
    'aria-label': accessibilityLabel,
    autoComplete: autoComplete && 'on',
    className: ['one-textinput', styleCls.current, className || ''].filter(function (v) {
      return v;
    }).join(' '),
    maxlength: maxLength,
    onChange: (onChange || onChangeText) && handleChange,
    onInput: function onInput(e) {
      _onInput && handleInput(e);
      if (!_universalEnv.isWeChatMiniProgram) {
        forceUpdate(function (tick) {
          return tick + 1;
        });
      }
    },
    onBlur: onBlur && function handleBlur(event) {
      onBlur(genEventObject(event));
    },
    onFocus: onFocus && function handleFocus(event) {
      onFocus(genEventObject(event));
    },
    onCompositionStart: function handleCompositionStart(event) {
      if (compositionProp) {
        composition.current = true;
      }
      if (onCompositionStart) {
        onCompositionStart(genEventObject(event));
      }
    },
    onCompositionEnd: function handleCompositionEnd(event) {
      if (compositionProp) {
        composition.current = false;
      }
      if (onCompositionEnd) {
        onCompositionEnd(genEventObject(event));
      }
      if (compositionProp) {
        triggerChange(event);
      }
    },
    ref: refEl
  });
  var disbaled = Boolean(editable !== undefined && !editable);
  var rows = numberOfLines || maxNumberOfLines;
  (0, _react.useImperativeHandle)(ref, function () {
    return {
      _nativeNode: refEl.current,
      focus: function focus() {
        refEl.current.focus();
      },
      blur: function blur() {
        refEl.current.blur();
      },
      clear: function clear() {
        setValue('');
      }
    };
  });
  (0, _react.useEffect)(function () {
    if (controlled && value !== stateValue && !composition.current) {
      setStateValue(value);
    }
  }, [value]);
  if (multiline) {
    return /*#__PURE__*/_react["default"].createElement(_react.Fragment, null, /*#__PURE__*/_react["default"].createElement("style", {
      "x-if": (_universalEnv.isWeb || _universalEnv.isNode) && placeholderColor,
      dangerouslySetInnerHTML: {
        __html: ".".concat(styleCls.current, "::placeholder {\n            color: ").concat(placeholderColor, "\n          }")
      }
    }), /*#__PURE__*/_react["default"].createElement("textarea", Object.assign({}, propsCommon, {
      style: Object.assign(Object.assign({}, style), {
        placeholderColor: placeholderColor
      }),
      row: rows,
      rows: rows,
      disabled: disbaled,
      onChange: handleChange,
      value: stateValue,
      "confirm-type": confirmType,
      "show-count": showCount
    }), !_universalEnv.isWeex && (stateValue || '')));
  } else {
    return /*#__PURE__*/_react["default"].createElement(_react.Fragment, null, /*#__PURE__*/_react["default"].createElement("style", {
      "x-if": (_universalEnv.isWeb || _universalEnv.isNode) && placeholderColor,
      dangerouslySetInnerHTML: {
        __html: ".".concat(styleCls.current, "::placeholder {\n            color: ").concat(placeholderColor, "\n          }")
      }
    }), /*#__PURE__*/_react["default"].createElement("input", Object.assign({}, propsCommon, {
      style: Object.assign(Object.assign({}, style), {
        placeholderColor: placeholderColor
      }),
      type: type,
      disabled: disbaled,
      value: stateValue,
      "confirm-type": confirmType,
      "random-Number": randomNumber,
      "selection-start": selectionStart,
      "selection-end": selectionEnd
    })));
  }
});
TextInput.displayName = 'TextInput';
var _default = exports["default"] = TextInput;