import { __assign, __read, __spreadArray, __values } from "tslib";
export function splitNameToPath(name) {
    return typeof name === 'string' && name ? name.replace(/\[/, '.').replace(/\]/, '').split('.') : '';
}
export function hasIn(state, name) {
    if (!state) {
        return false;
    }
    var path = splitNameToPath(name);
    var length = path.length;
    if (!length) {
        return false;
    }
    var result = state;
    for (var i = 0; i < length; ++i) {
        // parent is not object
        if (typeof result !== 'object' || result === null) {
            return false;
        }
        // has no property
        var thisName = path[i];
        if (!(thisName in result)) {
            return false;
        }
        // pass on
        result = result[thisName];
    }
    return true;
}
export function getIn(state, name) {
    if (!state) {
        return state;
    }
    var path = splitNameToPath(name);
    var length = path.length;
    if (!length) {
        return undefined;
    }
    var result = state;
    for (var i = 0; i < length; ++i) {
        // parent is not object
        if (typeof result !== 'object' || result === null) {
            return undefined;
        }
        result = result[path[i]];
    }
    return result;
}
function setInWithPath(state, value, path, pathIndex) {
    var _a;
    if (pathIndex >= path.length) {
        return value;
    }
    var first = path[pathIndex];
    var next = setInWithPath(state && state[first], value, path, pathIndex + 1);
    if (!state) {
        var initialized = isNaN(first) ? {} : [];
        initialized[first] = next;
        return initialized;
    }
    if (Array.isArray(state)) {
        var copy = __spreadArray([], __read(state), false);
        copy[first] = next;
        return copy;
    }
    return Object.assign({}, state, (_a = {},
        _a[first] = next,
        _a));
}
export function setIn(state, name, value) {
    return setInWithPath(state, value, typeof name === 'string' ? name.replace(/\[/, '.').replace(/\]/, '').split('.') : '', 0);
}
export function deleteIn(state, name) {
    if (!state) {
        return;
    }
    var path = typeof name === 'string' ? name.replace(/\[/, '.').replace(/\]/, '').split('.') : '';
    var length = path.length;
    if (!length) {
        return state;
    }
    var result = state;
    for (var i = 0; i < length && !!result; ++i) {
        if (i === length - 1) {
            delete result[path[i]];
        }
        else {
            result = result[path[i]];
        }
    }
    return state;
}
export function getErrorStrs(errors, processErrorMessage) {
    if (errors) {
        return errors.map(function (e) {
            var message = typeof e.message !== 'undefined' ? e.message : e;
            if (typeof processErrorMessage === 'function') {
                return processErrorMessage(message);
            }
            return message;
        });
    }
    return errors;
}
export function getParams(ns, cb) {
    var names = typeof ns === 'string' ? [ns] : ns;
    var callback = cb;
    if (cb === undefined && typeof names === 'function') {
        callback = names;
        names = undefined;
    }
    return {
        names: names,
        callback: callback,
    };
}
/**
 * name 是否被覆写
 * e.g. \{ a: \{ b: 1 \} \} and 'a.b', should return true
 * e.g. \{ a: \{ b: 1 \} \} and 'a.b.c', should return true
 * e.g. \{ a: \{ b: 1 \} \} and 'a.b2', should return false
 * e.g. \{ a: \{ b: 1 \} \} and 'a2', should return false
 * e.g. \{ a: \{ b: [0, 1] \} \} and 'a.b[0]' return true
 * e.g. \{ a: \{ b: [0, 1] \} \} and 'a.b[5]' return true (miss index means overwritten in array)
 * @param values - 写入对象
 * @param name - 字段 key
 */
export function isOverwritten(values, name) {
    var e_1, _a;
    if (!values || typeof values !== 'object' || !name || typeof name !== 'string') {
        return false;
    }
    var paths = splitNameToPath(name);
    var obj = values;
    try {
        for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
            var path = paths_1_1.value;
            if (path in obj) {
                var pathValue = obj[path];
                // 任意一层 path 值不是对象了，则代表被覆盖
                if (!pathValue || typeof pathValue !== 'object') {
                    return true;
                }
                else {
                    obj = pathValue;
                }
            }
            else {
                // 数组的 index 已经移除，则代表被覆写
                if (Array.isArray(obj)) {
                    return true;
                }
                return false;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // 代表 name in values，则返回 true
    return true;
}
/**
 * 从组件事件中获取数据
 * @param e - Event 或者 value
 * @returns 数据值
 */
export function getValueFromEvent(e) {
    // support custom element
    if (!e || !e.target || !e.preventDefault) {
        return e;
    }
    var target = e.target;
    if (target.type === 'checkbox') {
        return target.checked;
    }
    else if (target.type === 'radio') {
        //兼容原生 radioGroup
        if (target.value) {
            return target.value;
        }
        else {
            return target.checked;
        }
    }
    return target.value;
}
function validateMap(rulesMap, rule, defaultTrigger) {
    var nrule = Object.assign({}, rule);
    if (!nrule.trigger) {
        nrule.trigger = [defaultTrigger];
    }
    if (typeof nrule.trigger === 'string') {
        nrule.trigger = [nrule.trigger];
    }
    for (var i = 0; i < nrule.trigger.length; i++) {
        var trigger = nrule.trigger[i];
        if (trigger in rulesMap) {
            rulesMap[trigger].push(nrule);
        }
        else {
            rulesMap[trigger] = [nrule];
        }
    }
    delete nrule.trigger;
}
/**
 * 提取rule里面的trigger并且做映射
 * @param rules - 规则
 * @param defaultTrigger - 默认触发器
 */
export function mapValidateRules(rules, defaultTrigger) {
    var rulesMap = {};
    rules.forEach(function (rule) {
        validateMap(rulesMap, rule, defaultTrigger);
    });
    return rulesMap;
}
var warn = function () { };
if (typeof process !== 'undefined' &&
    process.env &&
    process.env.NODE_ENV !== 'production' &&
    typeof window !== 'undefined' &&
    typeof document !== 'undefined') {
    warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        /* eslint-disable no-console */
        if (typeof console !== 'undefined' && console.error) {
            console.error.apply(console, __spreadArray([], __read(args), false));
        }
        /* eslint-enable no-console */
    };
}
export var warning = warn;
export function cloneToRuleArr(rules) {
    if (!rules) {
        return [];
    }
    var rulesArr = Array.isArray(rules) ? rules : [rules];
    // 后续会修改 rule 对象，这里做浅复制以避免对传入对象的修改
    return rulesArr.map(function (rule) { return (__assign({}, rule)); });
}
