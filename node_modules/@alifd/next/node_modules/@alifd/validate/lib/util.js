"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processErrorResults = exports.complementError = exports.asyncMapPromise = exports.asyncMap = exports.format = void 0;
var tslib_1 = require("tslib");
var formatRegExp = /%[sdj%]/g;
function format() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var i = 1;
    var f = args[0];
    var len = args.length;
    if (typeof f === 'function') {
        return f(args.slice(1));
    }
    if (typeof f === 'string') {
        var str = String(f).replace(formatRegExp, function (x) {
            if (x === '%%') {
                return '%';
            }
            if (i >= len) {
                return x;
            }
            switch (x) {
                case '%s':
                    return String(args[i++]);
                case '%d':
                    return Number(args[i++]);
                case '%j':
                    try {
                        return JSON.stringify(args[i++]);
                    }
                    catch (_) {
                        return '[Circular]';
                    }
                default:
                    return x;
            }
        });
        return str;
    }
    return f;
}
exports.format = format;
/**
 * 串联校验一组数据，只返回第一个出错结果
 * @param arr
 * @param validator
 * @param callback 出递归，告诉错误校验完成
 */
function _asyncValidateSerials(arr, validator, callback) {
    var index = 0;
    var arrLength = arr.length;
    function next(errors) {
        if (errors && errors.length) {
            return callback(errors);
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
            validator(arr[original], next);
        }
        else {
            return callback([]);
        }
    }
    next([]);
}
/**
 * 串联校验一组数据，只返回第一个出错结果
 */
function _promiseValidateSeries(arr, validator) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, arr.reduce(function (prevPromise, next) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    var errors, e_1;
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, prevPromise];
                            case 1:
                                errors = _a.sent();
                                return [3 /*break*/, 3];
                            case 2:
                                e_1 = _a.sent();
                                errors = e_1;
                                return [3 /*break*/, 3];
                            case 3:
                                if (errors && errors.length) {
                                    return [2 /*return*/, errors];
                                }
                                return [2 /*return*/, validator(next)];
                        }
                    });
                }); }, [])];
        });
    });
}
/**
 * 平铺规则
 * @param objArr {name: [{value, rule}, {value, rule2}], name2: [{value2, rule3}]}
 * @return [{value, rule}, {value, rule2}, {value2, rule3}]
 */
function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function (k) {
        Object.keys(objArr[k]).forEach(function (r) {
            ret.push(objArr[k][r]);
        });
    });
    return ret;
}
/**
 * 异步调用
 * @param objArr   校验规则对象列表
 * @param option   配置项
 * @param validator     每个校验规则
 * @param callback 全部完成后的执行
 */
function asyncMap(objArr, option, validator, callback) {
    // 发现第一个错误即返回
    if (option.first) {
        var flattenArr = flattenObjArr(objArr);
        return _asyncValidateSerials(flattenArr, validator, callback);
    }
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var next = function (errors) {
        results.push(errors);
        total++;
        if (total === objArrLength) {
            return callback(results);
        }
    };
    objArrKeys.forEach(function (key) {
        var arr = objArr[key];
        _asyncValidateSerials(arr, validator, next);
    });
}
exports.asyncMap = asyncMap;
function asyncMapPromise(objArr, option, validator) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var flatObjArr, objArrValues;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!option.first) return [3 /*break*/, 2];
                    flatObjArr = flattenObjArr(objArr);
                    return [4 /*yield*/, _promiseValidateSeries(flatObjArr, validator)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2:
                    objArrValues = Object.values(objArr);
                    return [4 /*yield*/, Promise.all(objArrValues.map(function (val) { return _promiseValidateSeries(val, validator); }))];
                case 3: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
exports.asyncMapPromise = asyncMapPromise;
function complementError(rule) {
    return function (oe) {
        if (oe && typeof oe === 'object' && oe.message) {
            oe.field = rule.field;
            return oe;
        }
        return {
            message: oe,
            field: rule.field,
        };
    };
}
exports.complementError = complementError;
/**
 *
 * @param results errors from running validation
 * @returns \{ errors: Array, fields: Object }
 */
function processErrorResults(results) {
    if (results === void 0) { results = []; }
    var errors = [];
    var fields = {};
    function add(e) {
        if (Array.isArray(e)) {
            errors = errors.concat(e);
        }
        else {
            errors.push(e);
        }
    }
    for (var i = 0; i < results.length; i++) {
        add(results[i]);
    }
    if (!errors.length) {
        return {
            errors: null,
            fields: null,
        };
    }
    else {
        for (var i = 0; i < errors.length; i++) {
            var field = errors[i].field;
            if (field) {
                fields[field] = fields[field] || [];
                fields[field].push(errors[i]);
            }
        }
        return {
            errors: errors,
            fields: fields,
        };
    }
}
exports.processErrorResults = processErrorResults;
