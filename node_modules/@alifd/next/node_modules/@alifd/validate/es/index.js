import { __assign, __awaiter, __generator } from "tslib";
import { complementError, asyncMap, asyncMapPromise, processErrorResults, } from './util';
import defaultMessages from './messages';
import { getValidationMethod } from './validator';
function noop() { }
/**
 * @param source - 校验对象，如：{name: value, name2: value2}
 * @param rules - 对象内 key 的校验规则集合，如：{name: [rule1, rule2]}
 * @returns 标准的校验项集合，如：{name:[{value,rule1},{value, rule2}]}
 */
function serializeRules(source, rules) {
    // serialize rules
    var arr;
    var value;
    var series = {};
    var names = Object.keys(rules);
    names.forEach(function (name) {
        arr = rules[name];
        value = source[name];
        if (!Array.isArray(arr)) {
            arr = [arr];
        }
        arr.forEach(function (rule) {
            rule.validator = getValidationMethod(rule);
            rule.field = name;
            if (!rule.validator) {
                return;
            }
            series[name] = series[name] || [];
            series[name].push({
                rule: rule,
                value: value,
                source: source,
                field: name,
            });
        });
    });
    return series;
}
var Schema = /** @class */ (function () {
    function Schema(rules, options) {
        if (options === void 0) { options = {}; }
        this._rules = rules;
        this._options = __assign(__assign({}, options), { messages: __assign(__assign({}, defaultMessages), options.messages) });
        this.complete = [];
    }
    Schema.prototype.abort = function () {
        for (var i = 0; i < this.complete.length; i++) {
            this.complete[i] = noop;
        }
    };
    Schema.prototype.messages = function (messages) {
        this._options.messages = Object.assign({}, this._options.messages, messages);
    };
    Schema.prototype.validate = function (source, callback) {
        var _this = this;
        if (!callback) {
            return this.validatePromise(source);
        }
        if (!this._rules || Object.keys(this._rules).length === 0) {
            if (callback) {
                callback(null);
            }
            return;
        }
        var series = serializeRules(source, this._rules);
        if (Object.keys(series).length === 0) {
            callback(null);
        }
        // callback function for all rules return
        function complete(results) {
            var i;
            var field;
            var errors = [];
            var fields = {};
            function add(e) {
                if (Array.isArray(e)) {
                    errors = errors.concat(e);
                }
                else {
                    errors.push(e);
                }
            }
            for (i = 0; i < results.length; i++) {
                add(results[i]);
            }
            if (!errors.length) {
                callback(null, null);
            }
            else {
                for (i = 0; i < errors.length; i++) {
                    field = errors[i].field;
                    fields[field] = fields[field] || [];
                    fields[field].push(errors[i]);
                }
                callback(errors, fields);
            }
        }
        // 这里用数组的原因，是为了方便外部做 abort 调用
        // eg: input onChange 时调用有 异步 validator 被异步调用多次，我们只取最后一次调用。否则可能出现 前一个 validator 返回导致
        this.complete.push(complete);
        var idx = this.complete.length;
        // async validate
        asyncMap(series, this._options, function (data, next) {
            var rule = data.rule;
            rule.field = data.field;
            var cb = function cb(e) {
                var errors = e;
                // fix e=/""/null/undefiend.
                // ignore e=true/false;
                if (typeof errors !== 'boolean' && !errors) {
                    errors = [];
                }
                if (!Array.isArray(errors)) {
                    errors = [errors];
                }
                // 自定义错误
                if (errors.length && rule.message) {
                    errors = [].concat(rule.message);
                }
                var normalizeErrors = errors.map(complementError(rule));
                next(normalizeErrors);
            };
            var res = rule.validator(rule, data.value, cb, _this._options);
            if (res && res.then) {
                res.then(function () { return cb(); }, function (e) { return cb(e); });
            }
        }, function (results) {
            _this.complete[idx - 1](results);
        });
    };
    /**
     * Validate and use `Promise` to receive results
     * @param source - map of field names and values to use in validation
     * @returns Validation results
     */
    Schema.prototype.validatePromise = function (source) {
        return __awaiter(this, void 0, void 0, function () {
            var series, results;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._rules || Object.keys(this._rules).length === 0) {
                            return [2 /*return*/, { errors: null }];
                        }
                        series = serializeRules(source, this._rules);
                        if (Object.keys(series).length === 0) {
                            return [2 /*return*/, { errors: null }];
                        }
                        return [4 /*yield*/, asyncMapPromise(series, this._options, function (data) { return __awaiter(_this, void 0, void 0, function () {
                                var rule, errors, error_1;
                                var _this = this;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            rule = data.rule;
                                            rule.field = data.field;
                                            _a.label = 1;
                                        case 1:
                                            _a.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, new Promise(function (resolve) {
                                                    function cb(e) {
                                                        resolve(e);
                                                    }
                                                    var res = rule.validator(rule, data.value, cb, _this._options);
                                                    if (res && res.then) {
                                                        res.then(function () { return cb(); }, function (e) { return cb(e); });
                                                    }
                                                })];
                                        case 2:
                                            errors = _a.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            error_1 = _a.sent();
                                            errors = error_1;
                                            return [3 /*break*/, 4];
                                        case 4:
                                            if (errors) {
                                                // here is unreachable
                                                // fix e=/""/null/undefiend.
                                                // ignore e=true/false;
                                                // if (typeof errors !== 'boolean' && !errors) {
                                                //     errors = [];
                                                // }
                                                if (!Array.isArray(errors)) {
                                                    errors = [errors];
                                                }
                                                // 自定义错误
                                                if (errors.length && rule.message) {
                                                    errors = [].concat(rule.message);
                                                }
                                                return [2 /*return*/, errors.map(complementError(rule))];
                                            }
                                            else {
                                                return [2 /*return*/, []];
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        results = _a.sent();
                        return [2 /*return*/, processErrorResults(results)];
                }
            });
        });
    };
    return Schema;
}());
export * from './types';
export default Schema;
