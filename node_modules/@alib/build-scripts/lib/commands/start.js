"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const chalk_1 = require("chalk");
const Context_1 = require("../core/Context");
const webpackStats_1 = require("../utils/webpackStats");
const deepmerge = require("deepmerge");
const prepareURLs = require("../utils/prepareURLs");
const log = require("../utils/log");
module.exports = function ({ args, rootDir, eject, plugins, getBuiltInPlugins, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const command = 'start';
        const context = new Context_1.default({
            args,
            command,
            rootDir,
            plugins,
            getBuiltInPlugins,
        });
        log.verbose('OPTIONS', `${command} cliOptions: ${JSON.stringify(args, null, 2)}`);
        let serverUrl = '';
        const { applyHook, webpack } = context;
        let configArr = [];
        try {
            configArr = yield context.setUp();
        }
        catch (err) {
            log.error('CONFIG', chalk_1.default.red('Failed to get config.'));
            yield applyHook(`error`, { err });
            throw err;
        }
        yield applyHook(`before.${command}.load`, { args, webpackConfig: configArr });
        // eject config
        if (eject) {
            return configArr;
        }
        if (!configArr.length) {
            const errorMsg = 'No webpack config found.';
            log.warn('CONFIG', errorMsg);
            yield applyHook(`error`, { err: new Error(errorMsg) });
            return;
        }
        let devServerConfig = {
            port: args.port || 3333,
            host: args.host || '0.0.0.0',
            https: args.https || false,
        };
        for (const item of configArr) {
            const { chainConfig } = item;
            const config = chainConfig.toConfig();
            if (config.devServer) {
                devServerConfig = deepmerge(devServerConfig, config.devServer);
            }
            // if --port or process.env.PORT has been set, overwrite option port
            if (process.env.USE_CLI_PORT) {
                devServerConfig.port = args.port;
            }
        }
        const webpackConfig = configArr.map(v => v.chainConfig.toConfig());
        yield applyHook(`before.${command}.run`, { args, config: webpackConfig });
        let compiler;
        try {
            compiler = webpack(webpackConfig);
        }
        catch (err) {
            log.error('CONFIG', chalk_1.default.red('Failed to load webpack config.'));
            yield applyHook(`error`, { err });
            throw err;
        }
        const protocol = devServerConfig.https ? 'https' : 'http';
        const urls = prepareURLs(protocol, devServerConfig.host, devServerConfig.port);
        serverUrl = urls.localUrlForBrowser;
        let isFirstCompile = true;
        // typeof(stats) is webpack.compilation.MultiStats
        compiler.hooks.done.tap('compileHook', (stats) => __awaiter(this, void 0, void 0, function* () {
            const isSuccessful = webpackStats_1.default({
                urls,
                stats,
                isFirstCompile,
            });
            if (isSuccessful) {
                isFirstCompile = false;
            }
            yield applyHook(`after.${command}.compile`, {
                url: serverUrl,
                urls,
                isFirstCompile,
                stats,
            });
        }));
        // require webpack-dev-server after context setup
        // context may hijack webpack resolve
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const DevServer = require('webpack-dev-server');
        const devServer = new DevServer(compiler, devServerConfig);
        yield applyHook(`before.${command}.devServer`, {
            url: serverUrl,
            urls,
            devServer,
        });
        devServer.listen(devServerConfig.port, devServerConfig.host, (err) => __awaiter(this, void 0, void 0, function* () {
            if (err) {
                log.info('WEBPACK', chalk_1.default.red('[ERR]: Failed to start webpack dev server'));
                log.error('WEBPACK', (err.stack || err.toString()));
            }
            yield applyHook(`after.${command}.devServer`, {
                url: serverUrl,
                urls,
                devServer,
                err,
            });
        }));
        return devServer;
    });
};
