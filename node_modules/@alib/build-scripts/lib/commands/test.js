"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const jest_1 = require("jest");
const chalk_1 = require("chalk");
const Context_1 = require("../core/Context");
const fs = require("fs-extra");
const path = require("path");
const log = require("../utils/log");
module.exports = function ({ args, rootDir, plugins, getBuiltInPlugins, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const command = 'test';
        const context = new Context_1.default({
            args,
            command,
            rootDir,
            plugins,
            getBuiltInPlugins,
        });
        const { jestArgv = {} } = args || {};
        const { config, regexForTestFiles } = jestArgv, restArgv = __rest(jestArgv, ["config", "regexForTestFiles"]);
        const { applyHook, rootDir: ctxRoot } = context;
        yield applyHook(`before.${command}.load`, { args });
        let configArr = [];
        try {
            configArr = yield context.setUp();
        }
        catch (err) {
            log.error('CONFIG', chalk_1.default.red('Failed to get config.'));
            yield applyHook(`error`, { err });
            throw err;
        }
        // get user jest config
        const jestConfigPath = path.join(ctxRoot, config || 'jest.config.js');
        let userJestConfig = { moduleNameMapper: {} };
        if (fs.existsSync(jestConfigPath)) {
            userJestConfig = require(jestConfigPath); // eslint-disable-line
        }
        // get webpack.resolve.alias
        const alias = configArr.reduce((acc, { chainConfig }) => {
            const webpackConfig = chainConfig.toConfig();
            if (webpackConfig.resolve && webpackConfig.resolve.alias) {
                return Object.assign(Object.assign({}, acc), webpackConfig.resolve.alias);
            }
            else {
                return acc;
            }
        }, {});
        const aliasModuleNameMapper = {};
        Object.keys(alias || {}).forEach((key) => {
            const aliasPath = alias[key];
            // check path if it is a directory
            if (fs.existsSync(aliasPath) && fs.statSync(aliasPath).isDirectory()) {
                aliasModuleNameMapper[`^${key}/(.*)$`] = `${aliasPath}/$1`;
            }
            aliasModuleNameMapper[`^${key}$`] = aliasPath;
        });
        // generate default jest config
        const jestConfig = context.runJestConfig(Object.assign(Object.assign(Object.assign({ rootDir: ctxRoot }, userJestConfig), { moduleNameMapper: Object.assign(Object.assign({}, userJestConfig.moduleNameMapper), aliasModuleNameMapper) }), (regexForTestFiles ? { testMatch: regexForTestFiles } : {})));
        // disallow users to modify jest config
        Object.freeze(jestConfig);
        yield applyHook(`before.${command}.run`, { args, config: jestConfig });
        const result = yield new Promise((resolve, reject) => {
            jest_1.runCLI(Object.assign(Object.assign({}, restArgv), { config: JSON.stringify(jestConfig) }), [ctxRoot]).then((data) => {
                const { results } = data;
                if (results.success) {
                    resolve(data);
                }
                else {
                    reject(new Error('Jest failed'));
                }
            }).catch((err) => {
                log.error('JEST', (err.stack || err.toString()));
            });
        });
        yield applyHook(`after.${command}`, { result });
        return result;
    });
};
